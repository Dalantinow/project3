{"ast":null,"code":"var EventEmitter = require('events').EventEmitter,\n    inherits = require('util').inherits; // Get prototypes\n\n\nvar AggregationCursor = require('./aggregation_cursor'),\n    CommandCursor = require('./command_cursor'),\n    OrderedBulkOperation = require('./bulk/ordered').OrderedBulkOperation,\n    UnorderedBulkOperation = require('./bulk/unordered').UnorderedBulkOperation,\n    GridStore = require('./gridfs/grid_store'),\n    Cursor = require('./cursor'),\n    Collection = require('./collection'),\n    Db = require('./db');\n\nvar basicOperationIdGenerator = {\n  operationId: 1,\n  next: function () {\n    return this.operationId++;\n  }\n};\nvar basicTimestampGenerator = {\n  current: function () {\n    return new Date().getTime();\n  },\n  duration: function (start, end) {\n    return end - start;\n  }\n};\nvar senstiveCommands = ['authenticate', 'saslStart', 'saslContinue', 'getnonce', 'createUser', 'updateUser', 'copydbgetnonce', 'copydbsaslstart', 'copydb'];\n\nvar Instrumentation = function (core, options, callback) {\n  options = options || {}; // Optional id generators\n\n  var operationIdGenerator = options.operationIdGenerator || basicOperationIdGenerator; // Optional timestamp generator\n\n  var timestampGenerator = options.timestampGenerator || basicTimestampGenerator; // Extend with event emitter functionality\n\n  EventEmitter.call(this); // Contains all the instrumentation overloads\n\n  this.overloads = []; // ---------------------------------------------------------\n  //\n  // Instrument prototype\n  //\n  // ---------------------------------------------------------\n\n  var instrumentPrototype = function (callback) {\n    var instrumentations = []; // Classes to support\n\n    var classes = [GridStore, OrderedBulkOperation, UnorderedBulkOperation, CommandCursor, AggregationCursor, Cursor, Collection, Db]; // Add instrumentations to the available list\n\n    for (var i = 0; i < classes.length; i++) {\n      if (classes[i].define) {\n        instrumentations.push(classes[i].define.generate());\n      }\n    } // Return the list of instrumentation points\n\n\n    callback(null, instrumentations);\n  }; // Did the user want to instrument the prototype\n\n\n  if (typeof callback == 'function') {\n    instrumentPrototype(callback);\n  } // ---------------------------------------------------------\n  //\n  // Server\n  //\n  // ---------------------------------------------------------\n  // Reference\n\n\n  var self = this; // Names of methods we need to wrap\n\n  var methods = ['command', 'insert', 'update', 'remove']; // Prototype\n\n  var proto = core.Server.prototype; // Core server method we are going to wrap\n\n  methods.forEach(function (x) {\n    var func = proto[x]; // Add to overloaded methods\n\n    self.overloads.push({\n      proto: proto,\n      name: x,\n      func: func\n    }); // The actual prototype\n\n    proto[x] = function () {\n      var requestId = core.Query.nextRequestId(); // Get the arguments\n\n      var args = Array.prototype.slice.call(arguments, 0);\n      var ns = args[0];\n      var commandObj = args[1];\n      var options = args[2] || {};\n      var keys = Object.keys(commandObj);\n      var commandName = keys[0];\n      var db = ns.split('.')[0]; // Get the collection\n\n      var col = ns.split('.');\n      col.shift();\n      col = col.join('.'); // Do we have a legacy insert/update/remove command\n\n      if (x == 'insert') {\n        //} && !this.lastIsMaster().maxWireVersion) {\n        commandName = 'insert'; // Re-write the command\n\n        commandObj = {\n          insert: col,\n          documents: commandObj\n        };\n\n        if (options.writeConcern && Object.keys(options.writeConcern).length > 0) {\n          commandObj.writeConcern = options.writeConcern;\n        }\n\n        commandObj.ordered = options.ordered != undefined ? options.ordered : true;\n      } else if (x == 'update') {\n        // && !this.lastIsMaster().maxWireVersion) {\n        commandName = 'update'; // Re-write the command\n\n        commandObj = {\n          update: col,\n          updates: commandObj\n        };\n\n        if (options.writeConcern && Object.keys(options.writeConcern).length > 0) {\n          commandObj.writeConcern = options.writeConcern;\n        }\n\n        commandObj.ordered = options.ordered != undefined ? options.ordered : true;\n      } else if (x == 'remove') {\n        //&& !this.lastIsMaster().maxWireVersion) {\n        commandName = 'delete'; // Re-write the command\n\n        commandObj = {\n          delete: col,\n          deletes: commandObj\n        };\n\n        if (options.writeConcern && Object.keys(options.writeConcern).length > 0) {\n          commandObj.writeConcern = options.writeConcern;\n        }\n\n        commandObj.ordered = options.ordered != undefined ? options.ordered : true;\n      } // Get the callback\n\n\n      var callback = args.pop(); // Set current callback operation id from the current context or create\n      // a new one\n\n      var ourOpId = callback.operationId || operationIdGenerator.next(); // Get a connection reference for this server instance\n\n      var connection = this.s.pool.get(); // Emit the start event for the command\n\n      var command = {\n        // Returns the command.\n        command: commandObj,\n        // Returns the database name.\n        databaseName: db,\n        // Returns the command name.\n        commandName: commandName,\n        // Returns the driver generated request id.\n        requestId: requestId,\n        // Returns the driver generated operation id.\n        // This is used to link events together such as bulk write operations. OPTIONAL.\n        operationId: ourOpId,\n        // Returns the connection id for the command. For languages that do not have this,\n        // this MUST return the driver equivalent which MUST include the server address and port.\n        // The name of this field is flexible to match the object that is returned from the driver.\n        connectionId: connection\n      }; // Filter out any sensitive commands\n\n      if (senstiveCommands.indexOf(commandName.toLowerCase()) != -1) {\n        command.commandObj = {};\n        command.commandObj[commandName] = true;\n      } // Emit the started event\n\n\n      self.emit('started', command); // Start time\n\n      var startTime = timestampGenerator.current(); // Push our handler callback\n\n      args.push(function (err, r) {\n        var endTime = timestampGenerator.current();\n        var command = {\n          duration: timestampGenerator.duration(startTime, endTime),\n          commandName: commandName,\n          requestId: requestId,\n          operationId: ourOpId,\n          connectionId: connection\n        }; // If we have an error\n\n        if (err || r && r.result && r.result.ok == 0) {\n          command.failure = err || r.result.writeErrors || r.result; // Filter out any sensitive commands\n\n          if (senstiveCommands.indexOf(commandName.toLowerCase()) != -1) {\n            command.failure = {};\n          }\n\n          self.emit('failed', command);\n        } else if (commandObj && commandObj.writeConcern && commandObj.writeConcern.w == 0) {\n          // If we have write concern 0\n          command.reply = {\n            ok: 1\n          };\n          self.emit('succeeded', command);\n        } else {\n          command.reply = r && r.result ? r.result : r; // Filter out any sensitive commands\n\n          if (senstiveCommands.indexOf(commandName.toLowerCase()) != -1) {\n            command.reply = {};\n          }\n\n          self.emit('succeeded', command);\n        } // Return to caller\n\n\n        callback(err, r);\n      }); // Apply the call\n\n      func.apply(this, args);\n    };\n  }); // ---------------------------------------------------------\n  //\n  // Bulk Operations\n  //\n  // ---------------------------------------------------------\n  // Inject ourselves into the Bulk methods\n\n  methods = ['execute'];\n  var prototypes = [require('./bulk/ordered').Bulk.prototype, require('./bulk/unordered').Bulk.prototype];\n  prototypes.forEach(function (proto) {\n    // Core server method we are going to wrap\n    methods.forEach(function (x) {\n      var func = proto[x]; // Add to overloaded methods\n\n      self.overloads.push({\n        proto: proto,\n        name: x,\n        func: func\n      }); // The actual prototype\n\n      proto[x] = function () {\n        // Get the arguments\n        var args = Array.prototype.slice.call(arguments, 0); // Set an operation Id on the bulk object\n\n        this.operationId = operationIdGenerator.next(); // Get the callback\n\n        var callback = args.pop(); // If we have a callback use this\n\n        if (typeof callback == 'function') {\n          args.push(function (err, r) {\n            // Return to caller\n            callback(err, r);\n          }); // Apply the call\n\n          func.apply(this, args);\n        } else {\n          return func.apply(this, args);\n        }\n      };\n    });\n  }); // ---------------------------------------------------------\n  //\n  // Cursor\n  //\n  // ---------------------------------------------------------\n  // Inject ourselves into the Cursor methods\n\n  methods = ['_find', '_getmore', '_killcursor'];\n  prototypes = [require('./cursor').prototype, require('./command_cursor').prototype, require('./aggregation_cursor').prototype]; // Command name translation\n\n  var commandTranslation = {\n    '_find': 'find',\n    '_getmore': 'getMore',\n    '_killcursor': 'killCursors',\n    '_explain': 'explain'\n  };\n  prototypes.forEach(function (proto) {\n    // Core server method we are going to wrap\n    methods.forEach(function (x) {\n      var func = proto[x]; // Add to overloaded methods\n\n      self.overloads.push({\n        proto: proto,\n        name: x,\n        func: func\n      }); // The actual prototype\n\n      proto[x] = function () {\n        var cursor = this;\n        var requestId = core.Query.nextRequestId();\n        var ourOpId = operationIdGenerator.next();\n        var parts = this.ns.split('.');\n        var db = parts[0]; // Get the collection\n\n        parts.shift();\n        var collection = parts.join('.'); // Set the command\n\n        var command = this.query;\n        var cmd = this.s.cmd; // If we have a find method, set the operationId on the cursor\n\n        if (x == '_find') {\n          cursor.operationId = ourOpId;\n        } // Do we have a find command rewrite it\n\n\n        if (x == '_getmore') {\n          command = {\n            getMore: this.cursorState.cursorId,\n            collection: collection,\n            batchSize: cmd.batchSize\n          };\n          if (cmd.maxTimeMS) command.maxTimeMS = cmd.maxTimeMS;\n        } else if (x == '_killcursor') {\n          command = {\n            killCursors: collection,\n            cursors: [this.cursorState.cursorId]\n          };\n        } else if (cmd.find) {\n          command = {\n            find: collection,\n            filter: cmd.query\n          };\n          if (cmd.sort) command.sort = cmd.sort;\n          if (cmd.fields) command.projection = cmd.fields;\n\n          if (cmd.limit && cmd.limit < 0) {\n            command.limit = Math.abs(cmd.limit);\n            command.singleBatch = true;\n          } else if (cmd.limit) {\n            command.limit = Math.abs(cmd.limit);\n          } // Options\n\n\n          if (cmd.skip) command.skip = cmd.skip;\n          if (cmd.hint) command.hint = cmd.hint;\n          if (cmd.batchSize) command.batchSize = cmd.batchSize;\n          if (typeof cmd.returnKey == 'boolean') command.returnKey = cmd.returnKey;\n          if (cmd.comment) command.comment = cmd.comment;\n          if (cmd.min) command.min = cmd.min;\n          if (cmd.max) command.max = cmd.max;\n          if (cmd.maxScan) command.maxScan = cmd.maxScan;\n          if (cmd.maxTimeMS) command.maxTimeMS = cmd.maxTimeMS; // Flags\n\n          if (typeof cmd.awaitData == 'boolean') command.awaitData = cmd.awaitData;\n          if (typeof cmd.snapshot == 'boolean') command.snapshot = cmd.snapshot;\n          if (typeof cmd.tailable == 'boolean') command.tailable = cmd.tailable;\n          if (typeof cmd.oplogReplay == 'boolean') command.oplogReplay = cmd.oplogReplay;\n          if (typeof cmd.noCursorTimeout == 'boolean') command.noCursorTimeout = cmd.noCursorTimeout;\n          if (typeof cmd.partial == 'boolean') command.partial = cmd.partial;\n          if (typeof cmd.showDiskLoc == 'boolean') command.showRecordId = cmd.showDiskLoc; // Read Concern\n\n          if (cmd.readConcern) command.readConcern = cmd.readConcern; // Override method\n\n          if (cmd.explain) command.explain = cmd.explain;\n          if (cmd.exhaust) command.exhaust = cmd.exhaust; // If we have a explain flag\n\n          if (cmd.explain) {\n            // Create fake explain command\n            command = {\n              explain: command,\n              verbosity: 'allPlansExecution' // Set readConcern on the command if available\n\n            };\n            if (cmd.readConcern) command.readConcern = cmd.readConcern; // Set up the _explain name for the command\n\n            x = '_explain';\n          }\n        } else {\n          command = cmd;\n        } // Set up the connection\n\n\n        var connectionId = null; // Set local connection\n\n        if (this.connection) connectionId = this.connection;\n        if (!connectionId && this.server && this.server.getConnection) connectionId = this.server.getConnection(); // Get the command Name\n\n        var commandName = x == '_find' ? Object.keys(command)[0] : commandTranslation[x]; // Emit the start event for the command\n\n        command = {\n          // Returns the command.\n          command: command,\n          // Returns the database name.\n          databaseName: db,\n          // Returns the command name.\n          commandName: commandName,\n          // Returns the driver generated request id.\n          requestId: requestId,\n          // Returns the driver generated operation id.\n          // This is used to link events together such as bulk write operations. OPTIONAL.\n          operationId: this.operationId,\n          // Returns the connection id for the command. For languages that do not have this,\n          // this MUST return the driver equivalent which MUST include the server address and port.\n          // The name of this field is flexible to match the object that is returned from the driver.\n          connectionId: connectionId\n        }; // Get the arguments\n\n        var args = Array.prototype.slice.call(arguments, 0); // Get the callback\n\n        var callback = args.pop(); // We do not have a callback but a Promise\n\n        if (typeof callback == 'function' || command.commandName == 'killCursors') {\n          var startTime = timestampGenerator.current(); // Emit the started event\n\n          self.emit('started', command); // Emit succeeded event with killcursor if we have a legacy protocol\n\n          if (command.commandName == 'killCursors' && this.server.lastIsMaster() && this.server.lastIsMaster().maxWireVersion < 4) {\n            // Emit the succeeded command\n            command = {\n              duration: timestampGenerator.duration(startTime, timestampGenerator.current()),\n              commandName: commandName,\n              requestId: requestId,\n              operationId: cursor.operationId,\n              connectionId: cursor.server.getConnection(),\n              reply: [{\n                ok: 1\n              }]\n            }; // Apply callback to the list of args\n\n            args.push(callback); // Apply the call\n\n            func.apply(this, args); // Emit the command\n\n            return self.emit('succeeded', command);\n          } // Add our callback handler\n\n\n          args.push(function (err, r) {\n            if (err) {\n              // Command\n              var command = {\n                duration: timestampGenerator.duration(startTime, timestampGenerator.current()),\n                commandName: commandName,\n                requestId: requestId,\n                operationId: ourOpId,\n                connectionId: cursor.server.getConnection(),\n                failure: err\n              }; // Emit the command\n\n              self.emit('failed', command);\n            } else {\n              // Do we have a getMore\n              if (commandName.toLowerCase() == 'getmore' && r == null) {\n                r = {\n                  cursor: {\n                    id: cursor.cursorState.cursorId,\n                    ns: cursor.ns,\n                    nextBatch: cursor.cursorState.documents\n                  },\n                  ok: 1\n                };\n              } else if ((commandName.toLowerCase() == 'find' || commandName.toLowerCase() == 'aggregate' || commandName.toLowerCase() == 'listcollections') && r == null) {\n                r = {\n                  cursor: {\n                    id: cursor.cursorState.cursorId,\n                    ns: cursor.ns,\n                    firstBatch: cursor.cursorState.documents\n                  },\n                  ok: 1\n                };\n              } else if (commandName.toLowerCase() == 'killcursors' && r == null) {\n                r = {\n                  cursorsUnknown: [cursor.cursorState.lastCursorId],\n                  ok: 1\n                };\n              } // cursor id is zero, we can issue success command\n\n\n              command = {\n                duration: timestampGenerator.duration(startTime, timestampGenerator.current()),\n                commandName: commandName,\n                requestId: requestId,\n                operationId: cursor.operationId,\n                connectionId: cursor.server.getConnection(),\n                reply: r && r.result ? r.result : r\n              }; // Emit the command\n\n              self.emit('succeeded', command);\n            } // Return\n\n\n            if (!callback) return; // Return to caller\n\n            callback(err, r);\n          }); // Apply the call\n\n          func.apply(this, args);\n        } else {\n          // Assume promise, push back the missing value\n          args.push(callback); // Get the promise\n\n          var promise = func.apply(this, args); // Return a new promise\n\n          return new cursor.s.promiseLibrary(function (resolve, reject) {\n            var startTime = timestampGenerator.current(); // Emit the started event\n\n            self.emit('started', command); // Execute the function\n\n            promise.then(function () {\n              // cursor id is zero, we can issue success command\n              var command = {\n                duration: timestampGenerator.duration(startTime, timestampGenerator.current()),\n                commandName: commandName,\n                requestId: requestId,\n                operationId: cursor.operationId,\n                connectionId: cursor.server.getConnection(),\n                reply: cursor.cursorState.documents\n              }; // Emit the command\n\n              self.emit('succeeded', command);\n            }).catch(function (err) {\n              // Command\n              var command = {\n                duration: timestampGenerator.duration(startTime, timestampGenerator.current()),\n                commandName: commandName,\n                requestId: requestId,\n                operationId: ourOpId,\n                connectionId: cursor.server.getConnection(),\n                failure: err\n              }; // Emit the command\n\n              self.emit('failed', command); // reject the promise\n\n              reject(err);\n            });\n          });\n        }\n      };\n    });\n  });\n};\n\ninherits(Instrumentation, EventEmitter);\n\nInstrumentation.prototype.uninstrument = function () {\n  for (var i = 0; i < this.overloads.length; i++) {\n    var obj = this.overloads[i];\n    obj.proto[obj.name] = obj.func;\n  } // Remove all listeners\n\n\n  this.removeAllListeners('started');\n  this.removeAllListeners('succeeded');\n  this.removeAllListeners('failed');\n};\n\nmodule.exports = Instrumentation;","map":null,"metadata":{},"sourceType":"script"}