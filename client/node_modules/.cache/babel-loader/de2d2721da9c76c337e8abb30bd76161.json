{"ast":null,"code":"\"use strict\";\n\nvar parse = require('./url_parser'),\n    Server = require('./server'),\n    Mongos = require('./mongos'),\n    ReplSet = require('./replset'),\n    EventEmitter = require('events').EventEmitter,\n    inherits = require('util').inherits,\n    Define = require('./metadata'),\n    ReadPreference = require('./read_preference'),\n    Logger = require('mongodb-core').Logger,\n    MongoError = require('mongodb-core').MongoError,\n    Db = require('./db'),\n    f = require('util').format,\n    assign = require('./utils').assign,\n    shallowClone = require('./utils').shallowClone,\n    authenticate = require('./authenticate');\n/**\n * @fileOverview The **MongoClient** class is a class that allows for making Connections to MongoDB.\n *\n * @example\n * var MongoClient = require('mongodb').MongoClient,\n *   test = require('assert');\n * // Connection url\n * var url = 'mongodb://localhost:27017/test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, db) {\n *   // Get an additional db\n *   db.close();\n * });\n */\n\n\nvar validOptionNames = ['poolSize', 'ssl', 'sslValidate', 'sslCA', 'sslCert', 'ciphers', 'ecdhCurve', 'sslKey', 'sslPass', 'sslCRL', 'autoReconnect', 'noDelay', 'keepAlive', 'connectTimeoutMS', 'family', 'socketTimeoutMS', 'reconnectTries', 'reconnectInterval', 'ha', 'haInterval', 'replicaSet', 'secondaryAcceptableLatencyMS', 'acceptableLatencyMS', 'connectWithNoPrimary', 'authSource', 'w', 'wtimeout', 'j', 'forceServerObjectId', 'serializeFunctions', 'ignoreUndefined', 'raw', 'bufferMaxEntries', 'readPreference', 'pkFactory', 'promiseLibrary', 'readConcern', 'maxStalenessSeconds', 'loggerLevel', 'logger', 'promoteValues', 'promoteBuffers', 'promoteLongs', 'domainsEnabled', 'keepAliveInitialDelay', 'checkServerIdentity', 'validateOptions', 'appname', 'auth'];\nvar ignoreOptionNames = ['native_parser'];\nvar legacyOptionNames = ['server', 'replset', 'replSet', 'mongos', 'db'];\n\nfunction validOptions(options) {\n  var _validOptions = validOptionNames.concat(legacyOptionNames);\n\n  for (var name in options) {\n    if (ignoreOptionNames.indexOf(name) != -1) {\n      continue;\n    }\n\n    if (_validOptions.indexOf(name) == -1 && options.validateOptions) {\n      return new MongoError(f('option %s is not supported', name));\n    } else if (_validOptions.indexOf(name) == -1) {\n      console.warn(f('the options [%s] is not supported', name));\n    }\n\n    if (legacyOptionNames.indexOf(name) != -1) {\n      console.warn(f('the server/replset/mongos options are deprecated, ' + 'all their options are supported at the top level of the options object [%s]', validOptionNames));\n    }\n  }\n}\n/**\n * Creates a new MongoClient instance\n * @class\n * @return {MongoClient} a MongoClient instance.\n */\n\n\nfunction MongoClient() {\n  if (!(this instanceof MongoClient)) return new MongoClient(); // Set up event emitter\n\n  EventEmitter.call(this);\n  /**\n   * The callback format for results\n   * @callback MongoClient~connectCallback\n   * @param {MongoError} error An error instance representing the error during the execution.\n   * @param {Db} db The connected database.\n   */\n\n  /**\n   * Connect to MongoDB using a url as documented at\n   *\n   *  docs.mongodb.org/manual/reference/connection-string/\n   *\n   * Note that for replicasets the replicaSet query parameter is required in the 2.0 driver\n   *\n   * @method\n   * @param {string} url The connection URI string\n   * @param {object} [options] Optional settings.\n   * @param {number} [options.poolSize=5] poolSize The maximum size of the individual server pool.\n   * @param {boolean} [options.ssl=false] Enable SSL connection.\n   * @param {Buffer} [options.sslCA=undefined] SSL Certificate store binary buffer\n   * @param {Buffer} [options.sslCRL=undefined] SSL Certificate revocation list binary buffer\n   * @param {Buffer} [options.sslCert=undefined] SSL Certificate binary buffer\n   * @param {Buffer} [options.sslKey=undefined] SSL Key file binary buffer\n   * @param {string} [options.sslPass=undefined] SSL Certificate pass phrase\n   * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n   * @param {boolean} [options.autoReconnect=true] Enable autoReconnect for single server instances\n   * @param {boolean} [options.noDelay=true] TCP Connection no delay\n   * @param {number} [options.family=4] Version of IP stack. Defaults to 4.\n   * @param {number} [options.keepAlive=30000] The number of milliseconds to wait before initiating keepAlive on the TCP socket.\n   * @param {number} [options.connectTimeoutMS=30000] TCP Connection timeout setting\n   * @param {number} [options.socketTimeoutMS=360000] TCP Socket timeout setting\n   * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\n   * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\n   * @param {boolean} [options.ha=true] Control if high availability monitoring runs for Replicaset or Mongos proxies.\n   * @param {number} [options.haInterval=10000] The High availability period for replicaset inquiry\n   * @param {string} [options.replicaSet=undefined] The Replicaset set name\n   * @param {number} [options.secondaryAcceptableLatencyMS=15] Cutoff latency point in MS for Replicaset member selection\n   * @param {number} [options.acceptableLatencyMS=15] Cutoff latency point in MS for Mongos proxies selection.\n   * @param {boolean} [options.connectWithNoPrimary=false] Sets if the driver should connect even if no primary is available\n   * @param {string} [options.authSource=undefined] Define the database to authenticate against\n   * @param {string} [options.auth.user=undefined] The username for auth\n   * @param {string} [options.auth.password=undefined] The password for auth\n   * @param {(number|string)} [options.w=null] The write concern.\n   * @param {number} [options.wtimeout=null] The write concern timeout.\n   * @param {boolean} [options.j=false] Specify a journal write concern.\n   * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.\n   * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.\n   * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.\n   * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n   * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n   * @param {number} [options.bufferMaxEntries=-1] Sets a cap on how many operations the driver will buffer up before giving up on getting a working connection, default is -1 which is unlimited.\n   * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n   * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n   * @param {object} [options.pkFactory=null] A primary key factory object for generation of custom _id keys.\n   * @param {object} [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible\n   * @param {object} [options.readConcern=null] Specify a read concern for the collection. (only MongoDB 3.2 or higher supported)\n   * @param {string} [options.readConcern.level='local'] Specify a read concern level for the collection operations, one of [local|majority]. (only MongoDB 3.2 or higher supported)\n   * @param {number} [options.maxStalenessSeconds=undefined] The max staleness to secondary reads (values under 10 seconds cannot be guaranteed);\n   * @param {string} [options.appname=undefined] The name of the application that created this MongoClient instance. MongoDB 3.4 and newer will print this value in the server log upon establishing each connection. It is also recorded in the slow query log and profile collections.\n   * @param {string} [options.loggerLevel=undefined] The logging level (error/warn/info/debug)\n   * @param {object} [options.logger=undefined] Custom logger object\n   * @param {object} [options.validateOptions=false] Validate MongoClient passed in options for correctness.\n   * @param {MongoClient~connectCallback} [callback] The command result callback\n   * @return {Promise} returns Promise if no callback passed\n   */\n\n  this.connect = MongoClient.connect;\n}\n/**\n * @ignore\n */\n\n\ninherits(MongoClient, EventEmitter);\nvar define = MongoClient.define = new Define('MongoClient', MongoClient, false);\n/**\n * Connect to MongoDB using a url as documented at\n *\n *  docs.mongodb.org/manual/reference/connection-string/\n *\n * Note that for replicasets the replicaSet query parameter is required in the 2.0 driver\n *\n * @method\n * @static\n * @param {string} url The connection URI string\n * @param {object} [options] Optional settings.\n * @param {number} [options.poolSize=5] poolSize The maximum size of the individual server pool.\n * @param {boolean} [options.ssl=false] Enable SSL connection.\n * @param {Buffer} [options.sslCA=undefined] SSL Certificate store binary buffer\n * @param {Buffer} [options.sslCRL=undefined] SSL Certificate revocation list binary buffer\n * @param {Buffer} [options.sslCert=undefined] SSL Certificate binary buffer\n * @param {Buffer} [options.sslKey=undefined] SSL Key file binary buffer\n * @param {string} [options.sslPass=undefined] SSL Certificate pass phrase\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {boolean} [options.autoReconnect=true] Enable autoReconnect for single server instances\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.family=4] Version of IP stack. Defaults to 4.\n * @param {boolean} [options.keepAlive=30000] The number of milliseconds to wait before initiating keepAlive on the TCP socket.\n * @param {number} [options.connectTimeoutMS=30000] TCP Connection timeout setting\n * @param {number} [options.socketTimeoutMS=360000] TCP Socket timeout setting\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\n * @param {boolean} [options.ha=true] Control if high availability monitoring runs for Replicaset or Mongos proxies.\n * @param {number} [options.haInterval=10000] The High availability period for replicaset inquiry\n * @param {string} [options.replicaSet=undefined] The Replicaset set name\n * @param {number} [options.secondaryAcceptableLatencyMS=15] Cutoff latency point in MS for Replicaset member selection\n * @param {number} [options.acceptableLatencyMS=15] Cutoff latency point in MS for Mongos proxies selection.\n * @param {boolean} [options.connectWithNoPrimary=false] Sets if the driver should connect even if no primary is available\n * @param {string} [options.authSource=undefined] Define the database to authenticate against\n * @param {string} [options.auth.user=undefined] The username for auth\n * @param {string} [options.auth.password=undefined] The password for auth\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.\n * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {number} [options.bufferMaxEntries=-1] Sets a cap on how many operations the driver will buffer up before giving up on getting a working connection, default is -1 which is unlimited.\n * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @param {object} [options.pkFactory=null] A primary key factory object for generation of custom _id keys.\n * @param {object} [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible\n * @param {object} [options.readConcern=null] Specify a read concern for the collection. (only MongoDB 3.2 or higher supported)\n * @param {string} [options.readConcern.level='local'] Specify a read concern level for the collection operations, one of [local|majority]. (only MongoDB 3.2 or higher supported)\n * @param {number} [options.maxStalenessSeconds=undefined] The max staleness to secondary reads (values under 10 seconds cannot be guaranteed);\n * @param {string} [options.appname=undefined] The name of the application that created this MongoClient instance. MongoDB 3.4 and newer will print this value in the server log upon establishing each connection. It is also recorded in the slow query log and profile collections.\n * @param {string} [options.loggerLevel=undefined] The logging level (error/warn/info/debug)\n * @param {object} [options.logger=undefined] Custom logger object\n * @param {object} [options.validateOptions=false] Validate MongoClient passed in options for correctness.\n * @param {MongoClient~connectCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nMongoClient.connect = function (url, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = typeof args[args.length - 1] == 'function' ? args.pop() : null;\n  options = args.length ? args.shift() : null;\n  options = options || {};\n  var self = this; // Validate options object\n\n  var err = validOptions(options); // Get the promiseLibrary\n\n  var promiseLibrary = options.promiseLibrary; // No promise library selected fall back\n\n  if (!promiseLibrary) {\n    promiseLibrary = typeof global.Promise == 'function' ? global.Promise : require('es6-promise').Promise;\n  } // Return a promise\n\n\n  if (typeof callback != 'function') {\n    return new promiseLibrary(function (resolve, reject) {\n      // Did we have a validation error\n      if (err) return reject(err); // Attempt to connect\n\n      connect(self, url, options, function (err, db) {\n        if (err) return reject(err);\n        resolve(db);\n      });\n    });\n  } // Did we have a validation error\n\n\n  if (err) return callback(err); // Fallback to callback based connect\n\n  connect(self, url, options, callback);\n};\n\ndefine.staticMethod('connect', {\n  callback: true,\n  promise: true\n});\n\nvar mergeOptions = function (target, source, flatten) {\n  for (var name in source) {\n    if (source[name] && typeof source[name] == 'object' && flatten) {\n      target = mergeOptions(target, source[name], flatten);\n    } else {\n      target[name] = source[name];\n    }\n  }\n\n  return target;\n};\n\nvar createUnifiedOptions = function (finalOptions, options) {\n  var childOptions = ['mongos', 'server', 'db', 'replset', 'db_options', 'server_options', 'rs_options', 'mongos_options'];\n  var noMerge = ['readconcern'];\n\n  for (var name in options) {\n    if (noMerge.indexOf(name.toLowerCase()) != -1) {\n      finalOptions[name] = options[name];\n    } else if (childOptions.indexOf(name.toLowerCase()) != -1) {\n      finalOptions = mergeOptions(finalOptions, options[name], false);\n    } else {\n      if (options[name] && typeof options[name] == 'object' && !Buffer.isBuffer(options[name]) && !Array.isArray(options[name])) {\n        finalOptions = mergeOptions(finalOptions, options[name], true);\n      } else {\n        finalOptions[name] = options[name];\n      }\n    }\n  }\n\n  return finalOptions;\n};\n\nfunction translateOptions(options) {\n  // If we have a readPreference passed in by the db options\n  if (typeof options.readPreference == 'string' || typeof options.read_preference == 'string') {\n    options.readPreference = new ReadPreference(options.readPreference || options.read_preference);\n  } // Do we have readPreference tags, add them\n\n\n  if (options.readPreference && (options.readPreferenceTags || options.read_preference_tags)) {\n    options.readPreference.tags = options.readPreferenceTags || options.read_preference_tags;\n  } // Do we have maxStalenessSeconds\n\n\n  if (options.maxStalenessSeconds) {\n    options.readPreference.maxStalenessSeconds = options.maxStalenessSeconds;\n  } // Set the socket and connection timeouts\n\n\n  if (options.socketTimeoutMS == null) options.socketTimeoutMS = 360000;\n  if (options.connectTimeoutMS == null) options.connectTimeoutMS = 30000; // Create server instances\n\n  return options.servers.map(function (serverObj) {\n    return serverObj.domain_socket ? new Server(serverObj.domain_socket, 27017, options) : new Server(serverObj.host, serverObj.port, options);\n  });\n} //\n// Collect all events in order from SDAM\n//\n\n\nfunction collectEvents(self, db) {\n  var collectedEvents = [];\n\n  if (self instanceof MongoClient) {\n    var events = [\"timeout\", \"close\", 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening', 'topologyClosed', 'topologyDescriptionChanged', 'joined', 'left', 'ping', 'ha', 'all', 'fullsetup'];\n    events.forEach(function (event) {\n      db.serverConfig.on(event, function (object1, object2) {\n        collectedEvents.push({\n          event: event,\n          object1: object1,\n          object2: object2\n        });\n      });\n    });\n  }\n\n  return collectedEvents;\n} //\n// Replay any events due to single server connection switching to Mongos\n//\n\n\nfunction replayEvents(self, events) {\n  for (var i = 0; i < events.length; i++) {\n    self.emit(events[i].event, events[i].object1, events[i].object2);\n  }\n}\n\nfunction relayEvents(self, db) {\n  if (self instanceof MongoClient) {\n    var events = [\"timeout\", \"close\", 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening', 'topologyClosed', 'topologyDescriptionChanged', 'joined', 'left', 'ping', 'ha', 'all', 'fullsetup'];\n    events.forEach(function (event) {\n      db.serverConfig.on(event, function (object1, object2) {\n        self.emit(event, object1, object2);\n      });\n    });\n  }\n}\n\nfunction createReplicaset(self, options, callback) {\n  // Set default options\n  var servers = translateOptions(options); // Create Db instance\n\n  var db = new Db(options.dbName, new ReplSet(servers, options), options); // Propegate the events to the client\n\n  relayEvents(self, db); // Open the connection\n\n  db.open(callback);\n}\n\nfunction createMongos(self, options, callback) {\n  // Set default options\n  var servers = translateOptions(options); // Create Db instance\n\n  var db = new Db(options.dbName, new Mongos(servers, options), options); // Propegate the events to the client\n\n  relayEvents(self, db); // Open the connection\n\n  db.open(callback);\n}\n\nfunction createServer(self, options, callback) {\n  // Set default options\n  var servers = translateOptions(options); // Create db instance\n\n  var db = new Db(options.dbName, servers[0], options); // Propegate the events to the client\n\n  var collectedEvents = collectEvents(self, db); // Create Db instance\n\n  db.open(function (err, db) {\n    if (err) return callback(err); // Check if we are really speaking to a mongos\n\n    var ismaster = db.serverConfig.lastIsMaster(); // Do we actually have a mongos\n\n    if (ismaster && ismaster.msg == 'isdbgrid') {\n      // Destroy the current connection\n      db.close(); // Create mongos connection instead\n\n      return createMongos(self, options, callback);\n    } // Fire all the events\n\n\n    replayEvents(self, collectedEvents); // Propegate the events to the client\n\n    relayEvents(self, db); // Otherwise callback\n\n    callback(err, db);\n  });\n}\n\nfunction connectHandler(options, callback) {\n  return function (err, db) {\n    if (err) {\n      return process.nextTick(function () {\n        try {\n          callback(err, null);\n        } catch (err) {\n          if (db) db.close();\n          throw err;\n        }\n      });\n    } // No authentication just reconnect\n\n\n    if (!options.auth) {\n      return process.nextTick(function () {\n        try {\n          callback(err, db);\n        } catch (err) {\n          if (db) db.close();\n          throw err;\n        }\n      });\n    } // What db to authenticate against\n\n\n    var authentication_db = db;\n\n    if (options.authSource) {\n      authentication_db = db.db(options.authSource);\n    } // Authenticate\n\n\n    authenticate(authentication_db, options.user, options.password, options, function (err, success) {\n      if (success) {\n        process.nextTick(function () {\n          try {\n            callback(null, db);\n          } catch (err) {\n            if (db) db.close();\n            throw err;\n          }\n        });\n      } else {\n        if (db) db.close();\n        process.nextTick(function () {\n          try {\n            callback(err ? err : new Error('Could not authenticate user ' + options.auth[0]), null);\n          } catch (err) {\n            if (db) db.close();\n            throw err;\n          }\n        });\n      }\n    });\n  };\n}\n/*\n * Connect using MongoClient\n */\n\n\nvar connect = function (self, url, options, callback) {\n  options = options || {};\n  options = shallowClone(options); // If callback is null throw an exception\n\n  if (callback == null) {\n    throw new Error(\"no callback function provided\");\n  } // Get a logger for MongoClient\n\n\n  var logger = Logger('MongoClient', options);\n  parse(url, options, function (err, object) {\n    if (err) return callback(err); // Parse the string\n\n    var _finalOptions = createUnifiedOptions({}, object);\n\n    _finalOptions = mergeOptions(_finalOptions, object, false);\n    _finalOptions = createUnifiedOptions(_finalOptions, options); // Check if we have connection and socket timeout set\n\n    if (_finalOptions.socketTimeoutMS == null) _finalOptions.socketTimeoutMS = 360000;\n    if (_finalOptions.connectTimeoutMS == null) _finalOptions.connectTimeoutMS = 30000;\n\n    if (_finalOptions.db_options && _finalOptions.db_options.auth) {\n      delete _finalOptions.db_options.auth;\n    } // Failure modes\n\n\n    if (object.servers.length == 0) {\n      throw new Error(\"connection string must contain at least one seed host\");\n    } // Do we have a replicaset then skip discovery and go straight to connectivity\n\n\n    if (_finalOptions.replicaSet || _finalOptions.rs_name) {\n      return createReplicaset(self, _finalOptions, connectHandler(_finalOptions, connectCallback));\n    } else if (object.servers.length > 1) {\n      return createMongos(self, _finalOptions, connectHandler(_finalOptions, connectCallback));\n    } else {\n      return createServer(self, _finalOptions, connectHandler(_finalOptions, connectCallback));\n    }\n  });\n\n  function connectCallback(err, db) {\n    if (err && err.message == 'no mongos proxies found in seed list') {\n      if (logger.isWarn()) {\n        logger.warn(f('seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name'));\n      } // Return a more specific error message for MongoClient.connect\n\n\n      return callback(new MongoError('seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name'));\n    } // Return the error and db instance\n\n\n    callback(err, db);\n  }\n};\n\nmodule.exports = MongoClient;","map":null,"metadata":{},"sourceType":"script"}