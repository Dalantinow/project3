{"ast":null,"code":"\"use strict\";\n\nvar ReadPreference = require('./read_preference'),\n    parser = require('url'),\n    f = require('util').format,\n    assign = require('./utils').assign,\n    dns = require('dns');\n\nmodule.exports = function (url, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  var result = parser.parse(url, true);\n\n  if (result.protocol !== 'mongodb:' && result.protocol !== 'mongodb+srv:') {\n    return callback(new Error('invalid schema, expected mongodb or mongodb+srv'));\n  }\n\n  if (result.protocol === 'mongodb+srv:') {\n    if (result.hostname.split('.').length < 3) {\n      return callback(new Error('uri does not have hostname, domainname and tld'));\n    }\n\n    result.domainLength = result.hostname.split('.').length;\n\n    if (result.pathname && result.pathname.match(',')) {\n      return callback(new Error('invalid uri, cannot contain multiple hostnames'));\n    }\n\n    if (result.port) {\n      return callback(new Error('Ports not accepted with mongodb+srv'));\n    }\n\n    var srvAddress = '_mongodb._tcp.' + result.host;\n    dns.resolveSrv(srvAddress, function (err, addresses) {\n      if (err) return callback(err);\n\n      if (addresses.length === 0) {\n        return callback(new Error('No addresses found at host'));\n      }\n\n      for (var i = 0; i < addresses.length; i++) {\n        if (!matchesParentDomain(addresses[i].name, result.hostname, result.domainLength)) {\n          return callback(new Error('srv record does not share hostname with parent uri'));\n        }\n      }\n\n      var base = result.auth ? 'mongodb://' + result.auth + '@' : 'mongodb://';\n      var connectionStrings = addresses.map(function (address, i) {\n        if (i === 0) return base + address.name + ':' + address.port;else return address.name + ':' + address.port;\n      });\n      var connectionString = connectionStrings.join(',') + '/';\n      var connectionStringOptions = []; // Default to SSL true\n\n      if (!options.ssl && !result.search) {\n        connectionStringOptions.push('ssl=true');\n      } else if (!options.ssl && result.search && !result.search.match('ssl')) {\n        connectionStringOptions.push('ssl=true');\n      } // Keep original uri options\n\n\n      if (result.search) {\n        connectionStringOptions.push(result.search.replace('?', ''));\n      }\n\n      dns.resolveTxt(result.host, function (err, record) {\n        if (err && err.code !== 'ENODATA') return callback(err);\n        if (err && err.code === 'ENODATA') record = null;\n\n        if (record) {\n          if (record.length > 1) {\n            return callback(new Error('multiple text records not allowed'));\n          }\n\n          record = record[0];\n          if (record.length > 1) record = record.join('');else record = record[0];\n\n          if (!record.includes('authSource') && !record.includes('replicaSet')) {\n            return callback(new Error('text record must only set `authSource` or `replicaSet`'));\n          }\n\n          connectionStringOptions.push(record);\n        } // Add any options to the connection string\n\n\n        if (connectionStringOptions.length) {\n          connectionString += '?' + connectionStringOptions.join('&');\n        }\n\n        parseHandler(connectionString, options, callback);\n      });\n    });\n  } else {\n    parseHandler(url, options, callback);\n  }\n};\n\nfunction matchesParentDomain(srvAddress, parentDomain) {\n  var regex = /^.*?\\./;\n  var srv = '.' + srvAddress.replace(regex, '');\n  var parent = '.' + parentDomain.replace(regex, '');\n  if (srv.endsWith(parent)) return true;else return false;\n}\n\nfunction parseHandler(address, options, callback) {\n  var result, err;\n\n  try {\n    result = parseConnectionString(address, options);\n  } catch (e) {\n    err = e;\n  }\n\n  return err ? callback(err, null) : callback(null, result);\n}\n\nfunction parseConnectionString(url, options) {\n  // Variables\n  var connection_part = '';\n  var auth_part = '';\n  var query_string_part = '';\n  var dbName = 'admin'; // Url parser result\n\n  var result = parser.parse(url, true);\n\n  if ((result.hostname == null || result.hostname == '') && url.indexOf('.sock') == -1) {\n    throw new Error('no hostname or hostnames provided in connection string');\n  }\n\n  if (result.port == '0') {\n    throw new Error('invalid port (zero) with hostname');\n  }\n\n  if (!isNaN(parseInt(result.port, 10)) && parseInt(result.port, 10) > 65535) {\n    throw new Error('invalid port (larger than 65535) with hostname');\n  }\n\n  if (result.path && result.path.length > 0 && result.path[0] != '/' && url.indexOf('.sock') == -1) {\n    throw new Error('missing delimiting slash between hosts and options');\n  }\n\n  if (result.query) {\n    for (var name in result.query) {\n      if (name.indexOf('::') != -1) {\n        throw new Error('double colon in host identifier');\n      }\n\n      if (result.query[name] == '') {\n        throw new Error('query parameter ' + name + ' is an incomplete value pair');\n      }\n    }\n  }\n\n  if (result.auth) {\n    var parts = result.auth.split(':');\n\n    if (url.indexOf(result.auth) != -1 && parts.length > 2) {\n      throw new Error('Username with password containing an unescaped colon');\n    }\n\n    if (url.indexOf(result.auth) != -1 && result.auth.indexOf('@') != -1) {\n      throw new Error('Username containing an unescaped at-sign');\n    }\n  } // Remove query\n\n\n  var clean = url.split('?').shift(); // Extract the list of hosts\n\n  var strings = clean.split(',');\n  var hosts = [];\n\n  for (var i = 0; i < strings.length; i++) {\n    var hostString = strings[i];\n\n    if (hostString.indexOf('mongodb') != -1) {\n      if (hostString.indexOf('@') != -1) {\n        hosts.push(hostString.split('@').pop());\n      } else {\n        hosts.push(hostString.substr('mongodb://'.length));\n      }\n    } else if (hostString.indexOf('/') != -1) {\n      hosts.push(hostString.split('/').shift());\n    } else if (hostString.indexOf('/') == -1) {\n      hosts.push(hostString.trim());\n    }\n  }\n\n  for (i = 0; i < hosts.length; i++) {\n    var r = parser.parse(f('mongodb://%s', hosts[i].trim()));\n\n    if (r.path && r.path.indexOf(':') != -1) {\n      // Not connecting to a socket so check for an extra slash in the hostname.\n      // Using String#split as perf is better than match.\n      if (r.path.split('/').length > 1) {\n        throw new Error('slash in host identifier');\n      } else {\n        throw new Error('double colon in host identifier');\n      }\n    }\n  } // If we have a ? mark cut the query elements off\n\n\n  if (url.indexOf(\"?\") != -1) {\n    query_string_part = url.substr(url.indexOf(\"?\") + 1);\n    connection_part = url.substring(\"mongodb://\".length, url.indexOf(\"?\"));\n  } else {\n    connection_part = url.substring(\"mongodb://\".length);\n  } // Check if we have auth params\n\n\n  if (connection_part.indexOf(\"@\") != -1) {\n    auth_part = connection_part.split(\"@\")[0];\n    connection_part = connection_part.split(\"@\")[1];\n  } // Check if the connection string has a db\n\n\n  if (connection_part.indexOf(\".sock\") != -1) {\n    if (connection_part.indexOf(\".sock/\") != -1) {\n      dbName = connection_part.split(\".sock/\")[1]; // Check if multiple database names provided, or just an illegal trailing backslash\n\n      if (dbName.indexOf(\"/\") != -1) {\n        if (dbName.split(\"/\").length == 2 && dbName.split(\"/\")[1].length == 0) {\n          throw new Error('Illegal trailing backslash after database name');\n        }\n\n        throw new Error('More than 1 database name in URL');\n      }\n\n      connection_part = connection_part.split(\"/\", connection_part.indexOf(\".sock\") + \".sock\".length);\n    }\n  } else if (connection_part.indexOf(\"/\") != -1) {\n    // Check if multiple database names provided, or just an illegal trailing backslash\n    if (connection_part.split(\"/\").length > 2) {\n      if (connection_part.split(\"/\")[2].length == 0) {\n        throw new Error('Illegal trailing backslash after database name');\n      }\n\n      throw new Error('More than 1 database name in URL');\n    }\n\n    dbName = connection_part.split(\"/\")[1];\n    connection_part = connection_part.split(\"/\")[0];\n  } // Result object\n\n\n  var object = {}; // Pick apart the authentication part of the string\n\n  var authPart = auth_part || '';\n  var auth = authPart.split(':', 2); // Decode the URI components\n\n  auth[0] = decodeURIComponent(auth[0]);\n\n  if (auth[1]) {\n    auth[1] = decodeURIComponent(auth[1]);\n  } // Add auth to final object if we have 2 elements\n\n\n  if (auth.length == 2) object.auth = {\n    user: auth[0],\n    password: auth[1]\n  }; // if user provided auth options, use that\n\n  if (options && options.auth != null) object.auth = options.auth; // Variables used for temporary storage\n\n  var hostPart;\n  var urlOptions;\n  var servers;\n  var serverOptions = {\n    socketOptions: {}\n  };\n  var dbOptions = {\n    read_preference_tags: []\n  };\n  var replSetServersOptions = {\n    socketOptions: {}\n  };\n  var mongosOptions = {\n    socketOptions: {}\n  }; // Add server options to final object\n\n  object.server_options = serverOptions;\n  object.db_options = dbOptions;\n  object.rs_options = replSetServersOptions;\n  object.mongos_options = mongosOptions; // Let's check if we are using a domain socket\n\n  if (url.match(/\\.sock/)) {\n    // Split out the socket part\n    var domainSocket = url.substring(url.indexOf(\"mongodb://\") + \"mongodb://\".length, url.lastIndexOf(\".sock\") + \".sock\".length); // Clean out any auth stuff if any\n\n    if (domainSocket.indexOf(\"@\") != -1) domainSocket = domainSocket.split(\"@\")[1];\n    servers = [{\n      domain_socket: domainSocket\n    }];\n  } else {\n    // Split up the db\n    hostPart = connection_part; // Deduplicate servers\n\n    var deduplicatedServers = {}; // Parse all server results\n\n    servers = hostPart.split(',').map(function (h) {\n      var _host, _port, ipv6match; //check if it matches [IPv6]:port, where the port number is optional\n\n\n      if (ipv6match = /\\[([^\\]]+)\\](?:\\:(.+))?/.exec(h)) {\n        _host = ipv6match[1];\n        _port = parseInt(ipv6match[2], 10) || 27017;\n      } else {\n        //otherwise assume it's IPv4, or plain hostname\n        var hostPort = h.split(':', 2);\n        _host = hostPort[0] || 'localhost';\n        _port = hostPort[1] != null ? parseInt(hostPort[1], 10) : 27017; // Check for localhost?safe=true style case\n\n        if (_host.indexOf(\"?\") != -1) _host = _host.split(/\\?/)[0];\n      } // No entry returned for duplicate server\n\n\n      if (deduplicatedServers[_host + \"_\" + _port]) return null;\n      deduplicatedServers[_host + \"_\" + _port] = 1; // Return the mapped object\n\n      return {\n        host: _host,\n        port: _port\n      };\n    }).filter(function (x) {\n      return x != null;\n    });\n  } // Get the db name\n\n\n  object.dbName = dbName || 'admin'; // Split up all the options\n\n  urlOptions = (query_string_part || '').split(/[&;]/); // Ugh, we have to figure out which options go to which constructor manually.\n\n  urlOptions.forEach(function (opt) {\n    if (!opt) return;\n    var splitOpt = opt.split('='),\n        name = splitOpt[0],\n        value = splitOpt[1]; // Options implementations\n\n    switch (name) {\n      case 'slaveOk':\n      case 'slave_ok':\n        serverOptions.slave_ok = value == 'true';\n        dbOptions.slaveOk = value == 'true';\n        break;\n\n      case 'maxPoolSize':\n      case 'poolSize':\n        serverOptions.poolSize = parseInt(value, 10);\n        replSetServersOptions.poolSize = parseInt(value, 10);\n        break;\n\n      case 'appname':\n        object.appname = decodeURIComponent(value);\n        break;\n\n      case 'autoReconnect':\n      case 'auto_reconnect':\n        serverOptions.auto_reconnect = value == 'true';\n        break;\n\n      case 'minPoolSize':\n        throw new Error(\"minPoolSize not supported\");\n\n      case 'maxIdleTimeMS':\n        throw new Error(\"maxIdleTimeMS not supported\");\n\n      case 'waitQueueMultiple':\n        throw new Error(\"waitQueueMultiple not supported\");\n\n      case 'waitQueueTimeoutMS':\n        throw new Error(\"waitQueueTimeoutMS not supported\");\n\n      case 'uuidRepresentation':\n        throw new Error(\"uuidRepresentation not supported\");\n\n      case 'ssl':\n        if (value == 'prefer') {\n          serverOptions.ssl = value;\n          replSetServersOptions.ssl = value;\n          mongosOptions.ssl = value;\n          break;\n        }\n\n        serverOptions.ssl = value == 'true';\n        replSetServersOptions.ssl = value == 'true';\n        mongosOptions.ssl = value == 'true';\n        break;\n\n      case 'sslValidate':\n        serverOptions.sslValidate = value == 'true';\n        replSetServersOptions.sslValidate = value == 'true';\n        mongosOptions.sslValidate = value == 'true';\n        break;\n\n      case 'replicaSet':\n      case 'rs_name':\n        replSetServersOptions.rs_name = value;\n        break;\n\n      case 'reconnectWait':\n        replSetServersOptions.reconnectWait = parseInt(value, 10);\n        break;\n\n      case 'retries':\n        replSetServersOptions.retries = parseInt(value, 10);\n        break;\n\n      case 'readSecondary':\n      case 'read_secondary':\n        replSetServersOptions.read_secondary = value == 'true';\n        break;\n\n      case 'fsync':\n        dbOptions.fsync = value == 'true';\n        break;\n\n      case 'journal':\n        dbOptions.j = value == 'true';\n        break;\n\n      case 'safe':\n        dbOptions.safe = value == 'true';\n        break;\n\n      case 'nativeParser':\n      case 'native_parser':\n        dbOptions.native_parser = value == 'true';\n        break;\n\n      case 'readConcernLevel':\n        dbOptions.readConcern = {\n          level: value\n        };\n        break;\n\n      case 'connectTimeoutMS':\n        serverOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);\n        replSetServersOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);\n        mongosOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);\n        break;\n\n      case 'socketTimeoutMS':\n        serverOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);\n        replSetServersOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);\n        mongosOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);\n        break;\n\n      case 'w':\n        dbOptions.w = parseInt(value, 10);\n        if (isNaN(dbOptions.w)) dbOptions.w = value;\n        break;\n\n      case 'authSource':\n        dbOptions.authSource = value;\n        break;\n\n      case 'gssapiServiceName':\n        dbOptions.gssapiServiceName = value;\n        break;\n\n      case 'authMechanism':\n        if (value == 'GSSAPI') {\n          // If no password provided decode only the principal\n          if (object.auth == null) {\n            var urlDecodeAuthPart = decodeURIComponent(authPart);\n            if (urlDecodeAuthPart.indexOf(\"@\") == -1) throw new Error(\"GSSAPI requires a provided principal\");\n            object.auth = {\n              user: urlDecodeAuthPart,\n              password: null\n            };\n          } else {\n            object.auth.user = decodeURIComponent(object.auth.user);\n          }\n        } else if (value == 'MONGODB-X509') {\n          object.auth = {\n            user: decodeURIComponent(authPart)\n          };\n        } // Only support GSSAPI or MONGODB-CR for now\n\n\n        if (value != 'GSSAPI' && value != 'MONGODB-X509' && value != 'MONGODB-CR' && value != 'DEFAULT' && value != 'SCRAM-SHA-1' && value != 'PLAIN') throw new Error(\"only DEFAULT, GSSAPI, PLAIN, MONGODB-X509, SCRAM-SHA-1 or MONGODB-CR is supported by authMechanism\"); // Authentication mechanism\n\n        dbOptions.authMechanism = value;\n        break;\n\n      case 'authMechanismProperties':\n        // Split up into key, value pairs\n        var values = value.split(',');\n        var o = {}; // For each value split into key, value\n\n        values.forEach(function (x) {\n          var v = x.split(':');\n          o[v[0]] = v[1];\n        }); // Set all authMechanismProperties\n\n        dbOptions.authMechanismProperties = o; // Set the service name value\n\n        if (typeof o.SERVICE_NAME == 'string') dbOptions.gssapiServiceName = o.SERVICE_NAME;\n        if (typeof o.SERVICE_REALM == 'string') dbOptions.gssapiServiceRealm = o.SERVICE_REALM;\n        if (typeof o.CANONICALIZE_HOST_NAME == 'string') dbOptions.gssapiCanonicalizeHostName = o.CANONICALIZE_HOST_NAME == 'true' ? true : false;\n        break;\n\n      case 'wtimeoutMS':\n        dbOptions.wtimeout = parseInt(value, 10);\n        break;\n\n      case 'readPreference':\n        if (!ReadPreference.isValid(value)) throw new Error(\"readPreference must be either primary/primaryPreferred/secondary/secondaryPreferred/nearest\");\n        dbOptions.readPreference = value;\n        break;\n\n      case 'maxStalenessSeconds':\n        dbOptions.maxStalenessSeconds = parseInt(value, 10);\n        break;\n\n      case 'readPreferenceTags':\n        // Decode the value\n        value = decodeURIComponent(value); // Contains the tag object\n\n        var tagObject = {};\n\n        if (value == null || value == '') {\n          dbOptions.read_preference_tags.push(tagObject);\n          break;\n        } // Split up the tags\n\n\n        var tags = value.split(/\\,/);\n\n        for (var i = 0; i < tags.length; i++) {\n          var parts = tags[i].trim().split(/\\:/);\n          tagObject[parts[0]] = parts[1];\n        } // Set the preferences tags\n\n\n        dbOptions.read_preference_tags.push(tagObject);\n        break;\n\n      default:\n        break;\n    }\n  }); // No tags: should be null (not [])\n\n  if (dbOptions.read_preference_tags.length === 0) {\n    dbOptions.read_preference_tags = null;\n  } // Validate if there are an invalid write concern combinations\n\n\n  if ((dbOptions.w == -1 || dbOptions.w == 0) && (dbOptions.journal == true || dbOptions.fsync == true || dbOptions.safe == true)) throw new Error(\"w set to -1 or 0 cannot be combined with safe/w/journal/fsync\"); // If no read preference set it to primary\n\n  if (!dbOptions.readPreference) {\n    dbOptions.readPreference = 'primary';\n  } // make sure that user-provided options are applied with priority\n\n\n  dbOptions = assign(dbOptions, options); // Add servers to result\n\n  object.servers = servers; // Returned parsed object\n\n  return object;\n}","map":null,"metadata":{},"sourceType":"script"}