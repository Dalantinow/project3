{"ast":null,"code":"'use strict';\n\nconst MongoClient = require('mongodb');\n\nfunction withCallback(promise, cb) {\n  // Assume that cb is a function - type checks and handling type errors\n  // can be done by caller\n  if (cb) {\n    promise.then(res => cb(null, res)).catch(cb);\n  }\n\n  return promise;\n}\n\nfunction defaultSerializeFunction(session) {\n  // Copy each property of the session to a new object\n  const obj = {};\n  let prop;\n\n  for (prop in session) {\n    if (prop === 'cookie') {\n      // Convert the cookie instance to an object, if possible\n      // This gets rid of the duplicate object under session.cookie.data property\n      obj.cookie = session.cookie.toJSON ? session.cookie.toJSON() : session.cookie;\n    } else {\n      obj[prop] = session[prop];\n    }\n  }\n\n  return obj;\n}\n\nfunction computeTransformFunctions(options, defaultStringify) {\n  if (options.serialize || options.unserialize) {\n    return {\n      serialize: options.serialize || defaultSerializeFunction,\n      unserialize: options.unserialize || (x => x)\n    };\n  }\n\n  if (options.stringify === false || defaultStringify === false) {\n    return {\n      serialize: defaultSerializeFunction,\n      unserialize: x => x\n    };\n  }\n\n  if (options.stringify === true || defaultStringify === true) {\n    return {\n      serialize: JSON.stringify,\n      unserialize: JSON.parse\n    };\n  }\n}\n\nmodule.exports = function (connect) {\n  const Store = connect.Store || connect.session.Store;\n  const MemoryStore = connect.MemoryStore || connect.session.MemoryStore;\n\n  class MongoStore extends Store {\n    constructor(options) {\n      options = options || {};\n      /* Fallback */\n\n      if (options.fallbackMemory && MemoryStore) {\n        return new MemoryStore();\n      }\n\n      super(options);\n      /* Options */\n\n      this.ttl = options.ttl || 1209600; // 14 days\n\n      this.collectionName = options.collection || 'sessions';\n      this.autoRemove = options.autoRemove || 'native';\n      this.autoRemoveInterval = options.autoRemoveInterval || 10;\n      this.transformFunctions = computeTransformFunctions(options, true);\n      this.options = options;\n      this.changeState('init');\n\n      const newConnectionCallback = (err, db) => {\n        if (err) {\n          this.connectionFailed(err);\n        } else {\n          this.handleNewConnectionAsync(db);\n        }\n      };\n\n      if (options.url) {\n        // New native connection using url + mongoOptions\n        MongoClient.connect(options.url, options.mongoOptions || {}, newConnectionCallback);\n      } else if (options.mongooseConnection) {\n        // Re-use existing or upcoming mongoose connection\n        if (options.mongooseConnection.readyState === 1) {\n          this.handleNewConnectionAsync(options.mongooseConnection.db);\n        } else {\n          options.mongooseConnection.once('open', () => this.handleNewConnectionAsync(options.mongooseConnection.db));\n        }\n      } else if (options.db && options.db.listCollections) {\n        // Re-use existing or upcoming native connection\n        if (options.db.openCalled || options.db.openCalled === undefined) {\n          // OpenCalled is undefined in mongodb@2.x\n          this.handleNewConnectionAsync(options.db);\n        } else {\n          options.db.open(newConnectionCallback);\n        }\n      } else if (options.dbPromise) {\n        options.dbPromise.then(db => this.handleNewConnectionAsync(db)).catch(err => this.connectionFailed(err));\n      } else {\n        throw new Error('Connection strategy not found');\n      }\n\n      this.changeState('connecting');\n    }\n\n    connectionFailed(err) {\n      this.changeState('disconnected');\n      throw err;\n    }\n\n    handleNewConnectionAsync(db) {\n      this.db = db;\n      return this.setCollection(db.collection(this.collectionName)).setAutoRemoveAsync().then(() => this.changeState('connected'));\n    }\n\n    setAutoRemoveAsync() {\n      const removeQuery = () => {\n        return {\n          expires: {\n            $lt: new Date()\n          }\n        };\n      };\n\n      switch (this.autoRemove) {\n        case 'native':\n          return this.collection.createIndex({\n            expires: 1\n          }, {\n            expireAfterSeconds: 0\n          });\n\n        case 'interval':\n          this.timer = setInterval(() => this.collection.remove(removeQuery(), {\n            w: 0\n          }), this.autoRemoveInterval * 1000 * 60);\n          this.timer.unref();\n          return Promise.resolve();\n\n        default:\n          return Promise.resolve();\n      }\n    }\n\n    changeState(newState) {\n      if (newState !== this.state) {\n        this.state = newState;\n        this.emit(newState);\n      }\n    }\n\n    setCollection(collection) {\n      if (this.timer) {\n        clearInterval(this.timer);\n      }\n\n      this.collectionReadyPromise = undefined;\n      this.collection = collection;\n      return this;\n    }\n\n    collectionReady() {\n      let promise = this.collectionReadyPromise;\n\n      if (!promise) {\n        promise = new Promise((resolve, reject) => {\n          if (this.state === 'connected') {\n            return resolve(this.collection);\n          }\n\n          if (this.state === 'connecting') {\n            return this.once('connected', () => resolve(this.collection));\n          }\n\n          reject(new Error('Not connected'));\n        });\n        this.collectionReadyPromise = promise;\n      }\n\n      return promise;\n    }\n\n    computeStorageId(sessionId) {\n      if (this.options.transformId && typeof this.options.transformId === 'function') {\n        return this.options.transformId(sessionId);\n      }\n\n      return sessionId;\n    }\n    /* Public API */\n\n\n    get(sid, callback) {\n      return withCallback(this.collectionReady().then(collection => collection.findOne({\n        _id: this.computeStorageId(sid),\n        $or: [{\n          expires: {\n            $exists: false\n          }\n        }, {\n          expires: {\n            $gt: new Date()\n          }\n        }]\n      })).then(session => {\n        if (session) {\n          const s = this.transformFunctions.unserialize(session.session);\n\n          if (this.options.touchAfter > 0 && session.lastModified) {\n            s.lastModified = session.lastModified;\n          }\n\n          this.emit('get', sid);\n          return s;\n        }\n      }), callback);\n    }\n\n    set(sid, session, callback) {\n      // Removing the lastModified prop from the session object before update\n      if (this.options.touchAfter > 0 && session && session.lastModified) {\n        delete session.lastModified;\n      }\n\n      let s;\n\n      try {\n        s = {\n          _id: this.computeStorageId(sid),\n          session: this.transformFunctions.serialize(session)\n        };\n      } catch (err) {\n        return callback(err);\n      }\n\n      if (session && session.cookie && session.cookie.expires) {\n        s.expires = new Date(session.cookie.expires);\n      } else {\n        // If there's no expiration date specified, it is\n        // browser-session cookie or there is no cookie at all,\n        // as per the connect docs.\n        //\n        // So we set the expiration to two-weeks from now\n        // - as is common practice in the industry (e.g Django) -\n        // or the default specified in the options.\n        s.expires = new Date(Date.now() + this.ttl * 1000);\n      }\n\n      if (this.options.touchAfter > 0) {\n        s.lastModified = new Date();\n      }\n\n      return withCallback(this.collectionReady().then(collection => collection.updateOne({\n        _id: this.computeStorageId(sid)\n      }, {\n        $set: s\n      }, {\n        upsert: true\n      })).then(rawResponse => {\n        if (rawResponse.result) {\n          rawResponse = rawResponse.result;\n        }\n\n        if (rawResponse && rawResponse.upserted) {\n          this.emit('create', sid);\n        } else {\n          this.emit('update', sid);\n        }\n\n        this.emit('set', sid);\n      }), callback);\n    }\n\n    touch(sid, session, callback) {\n      const updateFields = {};\n      const touchAfter = this.options.touchAfter * 1000;\n      const lastModified = session.lastModified ? session.lastModified.getTime() : 0;\n      const currentDate = new Date(); // If the given options has a touchAfter property, check if the\n      // current timestamp - lastModified timestamp is bigger than\n      // the specified, if it's not, don't touch the session\n\n      if (touchAfter > 0 && lastModified > 0) {\n        const timeElapsed = currentDate.getTime() - session.lastModified;\n\n        if (timeElapsed < touchAfter) {\n          return callback();\n        }\n\n        updateFields.lastModified = currentDate;\n      }\n\n      if (session && session.cookie && session.cookie.expires) {\n        updateFields.expires = new Date(session.cookie.expires);\n      } else {\n        updateFields.expires = new Date(Date.now() + this.ttl * 1000);\n      }\n\n      return withCallback(this.collectionReady().then(collection => collection.updateOne({\n        _id: this.computeStorageId(sid)\n      }, {\n        $set: updateFields\n      })).then(result => {\n        if (result.nModified === 0) {\n          throw new Error('Unable to find the session to touch');\n        } else {\n          this.emit('touch', sid, session);\n        }\n      }), callback);\n    }\n\n    destroy(sid, callback) {\n      return withCallback(this.collectionReady().then(collection => collection.deleteOne({\n        _id: this.computeStorageId(sid)\n      })).then(() => this.emit('destroy', sid)), callback);\n    }\n\n    length(callback) {\n      return withCallback(this.collectionReady().then(collection => collection.count({})), callback);\n    }\n\n    clear(callback) {\n      return withCallback(this.collectionReady().then(collection => collection.drop()), callback);\n    }\n\n    close() {\n      if (this.db) {\n        this.db.close();\n      }\n    }\n\n  }\n\n  return MongoStore;\n};","map":null,"metadata":{},"sourceType":"script"}