{"ast":null,"code":"\"use strict\";\n\nvar inherits = require('util').inherits,\n    f = require('util').format,\n    EventEmitter = require('events').EventEmitter,\n    ReadPreference = require('./read_preference'),\n    BasicCursor = require('../cursor'),\n    retrieveBSON = require('../connection/utils').retrieveBSON,\n    Logger = require('../connection/logger'),\n    MongoError = require('../error'),\n    Server = require('./server'),\n    ReplSetState = require('./replset_state'),\n    assign = require('../utils').assign,\n    clone = require('./shared').clone,\n    Timeout = require('./shared').Timeout,\n    Interval = require('./shared').Interval,\n    createClientInfo = require('./shared').createClientInfo;\n\nvar MongoCR = require('../auth/mongocr'),\n    X509 = require('../auth/x509'),\n    Plain = require('../auth/plain'),\n    GSSAPI = require('../auth/gssapi'),\n    SSPI = require('../auth/sspi'),\n    ScramSHA1 = require('../auth/scram');\n\nvar BSON = retrieveBSON(); //\n// States\n\nvar DISCONNECTED = 'disconnected';\nvar CONNECTING = 'connecting';\nvar CONNECTED = 'connected';\nvar UNREFERENCED = 'unreferenced';\nvar DESTROYED = 'destroyed';\n\nfunction stateTransition(self, newState) {\n  var legalTransitions = {\n    'disconnected': [CONNECTING, DESTROYED, DISCONNECTED],\n    'connecting': [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],\n    'connected': [CONNECTED, DISCONNECTED, DESTROYED, UNREFERENCED],\n    'unreferenced': [UNREFERENCED, DESTROYED],\n    'destroyed': [DESTROYED] // Get current state\n\n  };\n  var legalStates = legalTransitions[self.state];\n\n  if (legalStates && legalStates.indexOf(newState) != -1) {\n    self.state = newState;\n  } else {\n    self.s.logger.error(f('Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]', self.id, self.state, newState, legalStates));\n  }\n} //\n// ReplSet instance id\n\n\nvar id = 1;\nvar handlers = ['connect', 'close', 'error', 'timeout', 'parseError'];\n/**\n * Creates a new Replset instance\n * @class\n * @param {array} seedlist A list of seeds for the replicaset\n * @param {boolean} options.setName The Replicaset set name\n * @param {boolean} [options.secondaryOnlyConnectionAllowed=false] Allow connection to a secondary only replicaset\n * @param {number} [options.haInterval=10000] The High availability period for replicaset inquiry\n * @param {boolean} [options.emitError=false] Server will emit errors events\n * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors\n * @param {number} [options.size=5] Server connection pool size\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=10000] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n * @param {boolean} [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {number} [options.pingInterval=5000] Ping interval to check the response time to the different servers\n * @param {number} [options.localThresholdMS=15] Cutoff latency point in MS for Replicaset member selection\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @return {ReplSet} A cursor instance\n * @fires ReplSet#connect\n * @fires ReplSet#ha\n * @fires ReplSet#joined\n * @fires ReplSet#left\n * @fires ReplSet#failed\n * @fires ReplSet#fullsetup\n * @fires ReplSet#all\n * @fires ReplSet#error\n * @fires ReplSet#serverHeartbeatStarted\n * @fires ReplSet#serverHeartbeatSucceeded\n * @fires ReplSet#serverHeartbeatFailed\n * @fires ReplSet#topologyOpening\n * @fires ReplSet#topologyClosed\n * @fires ReplSet#topologyDescriptionChanged\n * @property {string} type the topology type.\n * @property {string} parserType the parser type used (c++ or js).\n */\n\nvar ReplSet = function (seedlist, options) {\n  var self = this;\n  options = options || {}; // Validate seedlist\n\n  if (!Array.isArray(seedlist)) throw new MongoError(\"seedlist must be an array\"); // Validate list\n\n  if (seedlist.length == 0) throw new MongoError(\"seedlist must contain at least one entry\"); // Validate entries\n\n  seedlist.forEach(function (e) {\n    if (typeof e.host != 'string' || typeof e.port != 'number') throw new MongoError(\"seedlist entry must contain a host and port\");\n  }); // Add event listener\n\n  EventEmitter.call(this); // Get replSet Id\n\n  this.id = id++; // Get the localThresholdMS\n\n  var localThresholdMS = options.localThresholdMS || 15; // Backward compatibility\n\n  if (options.acceptableLatency) localThresholdMS = options.acceptableLatency; // Create a logger\n\n  var logger = Logger('ReplSet', options); // Internal state\n\n  this.s = {\n    options: assign({}, options),\n    // BSON instance\n    bson: options.bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]),\n    // Factory overrides\n    Cursor: options.cursorFactory || BasicCursor,\n    // Logger instance\n    logger: logger,\n    // Seedlist\n    seedlist: seedlist,\n    // Replicaset state\n    replicaSetState: new ReplSetState({\n      id: this.id,\n      setName: options.setName,\n      acceptableLatency: localThresholdMS,\n      heartbeatFrequencyMS: options.haInterval ? options.haInterval : 10000,\n      logger: logger\n    }),\n    // Current servers we are connecting to\n    connectingServers: [],\n    // Ha interval\n    haInterval: options.haInterval ? options.haInterval : 10000,\n    // Minimum heartbeat frequency used if we detect a server close\n    minHeartbeatFrequencyMS: 500,\n    // Disconnect handler\n    disconnectHandler: options.disconnectHandler,\n    // Server selection index\n    index: 0,\n    // Connect function options passed in\n    connectOptions: {},\n    // Are we running in debug mode\n    debug: typeof options.debug == 'boolean' ? options.debug : false,\n    // Client info\n    clientInfo: createClientInfo(options),\n    // Authentication context\n    authenticationContexts: [] // Add handler for topology change\n\n  };\n  this.s.replicaSetState.on('topologyDescriptionChanged', function (r) {\n    self.emit('topologyDescriptionChanged', r);\n  }); // Log info warning if the socketTimeout < haInterval as it will cause\n  // a lot of recycled connections to happen.\n\n  if (this.s.logger.isWarn() && this.s.options.socketTimeout != 0 && this.s.options.socketTimeout < this.s.haInterval) {\n    this.s.logger.warn(f('warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts', this.s.options.socketTimeout, this.s.haInterval));\n  } // All the authProviders\n\n\n  this.authProviders = options.authProviders || {\n    'mongocr': new MongoCR(this.s.bson),\n    'x509': new X509(this.s.bson),\n    'plain': new Plain(this.s.bson),\n    'gssapi': new GSSAPI(this.s.bson),\n    'sspi': new SSPI(this.s.bson),\n    'scram-sha-1': new ScramSHA1(this.s.bson) // Add forwarding of events from state handler\n\n  };\n  var types = ['joined', 'left'];\n  types.forEach(function (x) {\n    self.s.replicaSetState.on(x, function (t, s) {\n      self.emit(x, t, s);\n    });\n  }); // Connect stat\n\n  this.initialConnectState = {\n    connect: false,\n    fullsetup: false,\n    all: false // Disconnected state\n\n  };\n  this.state = DISCONNECTED;\n  this.haTimeoutId = null; // Are we authenticating\n\n  this.authenticating = false; // Last ismaster\n\n  this.ismaster = null; // Contains the intervalId\n\n  this.intervalIds = [];\n};\n\ninherits(ReplSet, EventEmitter);\nObject.defineProperty(ReplSet.prototype, 'type', {\n  enumerable: true,\n  get: function () {\n    return 'replset';\n  }\n});\nObject.defineProperty(ReplSet.prototype, 'parserType', {\n  enumerable: true,\n  get: function () {\n    return BSON.native ? \"c++\" : \"js\";\n  }\n});\n\nfunction rexecuteOperations(self) {\n  // If we have a primary and a disconnect handler, execute\n  // buffered operations\n  if (self.s.replicaSetState.hasPrimaryAndSecondary() && self.s.disconnectHandler) {\n    self.s.disconnectHandler.execute();\n  } else if (self.s.replicaSetState.hasPrimary() && self.s.disconnectHandler) {\n    self.s.disconnectHandler.execute({\n      executePrimary: true\n    });\n  } else if (self.s.replicaSetState.hasSecondary() && self.s.disconnectHandler) {\n    self.s.disconnectHandler.execute({\n      executeSecondary: true\n    });\n  }\n}\n\nfunction connectNewServers(self, servers, callback) {\n  // Count lefts\n  var count = servers.length;\n  var error = null; // Handle events\n\n  var _handleEvent = function (self, event) {\n    return function (err) {\n      var _self = this;\n\n      count = count - 1; // Destroyed\n\n      if (self.state == DESTROYED || self.state == UNREFERENCED) {\n        return this.destroy({\n          force: true\n        });\n      }\n\n      if (event == 'connect' && !self.authenticating) {\n        // Destroyed\n        if (self.state == DESTROYED || self.state == UNREFERENCED) {\n          return _self.destroy({\n            force: true\n          });\n        } // Do we have authentication contexts that need to be applied\n\n\n        applyAuthenticationContexts(self, _self, function () {\n          // Destroy the instance\n          if (self.state == DESTROYED || self.state == UNREFERENCED) {\n            return _self.destroy({\n              force: true\n            });\n          } // Update the state\n\n\n          var result = self.s.replicaSetState.update(_self); // Update the state with the new server\n\n          if (result) {\n            // Primary lastIsMaster store it\n            if (_self.lastIsMaster() && _self.lastIsMaster().ismaster) {\n              self.ismaster = _self.lastIsMaster();\n            } // Remove the handlers\n\n\n            for (var i = 0; i < handlers.length; i++) {\n              _self.removeAllListeners(handlers[i]);\n            } // Add stable state handlers\n\n\n            _self.on('error', handleEvent(self, 'error'));\n\n            _self.on('close', handleEvent(self, 'close'));\n\n            _self.on('timeout', handleEvent(self, 'timeout'));\n\n            _self.on('parseError', handleEvent(self, 'parseError')); // Enalbe the monitoring of the new server\n\n\n            monitorServer(_self.lastIsMaster().me, self, {}); // Rexecute any stalled operation\n\n            rexecuteOperations(self);\n          } else {\n            _self.destroy({\n              force: true\n            });\n          }\n        });\n      } else if (event == 'connect' && self.authenticating) {\n        this.destroy({\n          force: true\n        });\n      } else if (event == 'error') {\n        error = err;\n      } // Rexecute any stalled operation\n\n\n      rexecuteOperations(self); // Are we done finish up callback\n\n      if (count == 0) {\n        callback(error);\n      }\n    };\n  }; // No new servers\n\n\n  if (count == 0) return callback(); // Execute method\n\n  function execute(_server, i) {\n    setTimeout(function () {\n      // Destroyed\n      if (self.state == DESTROYED || self.state == UNREFERENCED) {\n        return;\n      } // Create a new server instance\n\n\n      var server = new Server(assign({}, self.s.options, {\n        host: _server.split(':')[0],\n        port: parseInt(_server.split(':')[1], 10)\n      }, {\n        authProviders: self.authProviders,\n        reconnect: false,\n        monitoring: false,\n        inTopology: true\n      }, {\n        clientInfo: clone(self.s.clientInfo)\n      })); // Add temp handlers\n\n      server.once('connect', _handleEvent(self, 'connect'));\n      server.once('close', _handleEvent(self, 'close'));\n      server.once('timeout', _handleEvent(self, 'timeout'));\n      server.once('error', _handleEvent(self, 'error'));\n      server.once('parseError', _handleEvent(self, 'parseError')); // SDAM Monitoring events\n\n      server.on('serverOpening', function (e) {\n        self.emit('serverOpening', e);\n      });\n      server.on('serverDescriptionChanged', function (e) {\n        self.emit('serverDescriptionChanged', e);\n      });\n      server.on('serverClosed', function (e) {\n        self.emit('serverClosed', e);\n      });\n      server.connect(self.s.connectOptions);\n    }, i);\n  } // Create new instances\n\n\n  for (var i = 0; i < servers.length; i++) {\n    execute(servers[i], i);\n  }\n} // Ping the server\n\n\nvar pingServer = function (self, server, cb) {\n  // Measure running time\n  var start = new Date().getTime(); // Emit the server heartbeat start\n\n  emitSDAMEvent(self, 'serverHeartbeatStarted', {\n    connectionId: server.name\n  }); // Execute ismaster\n  // Set the socketTimeout for a monitoring message to a low number\n  // Ensuring ismaster calls are timed out quickly\n\n  server.command('admin.$cmd', {\n    ismaster: true\n  }, {\n    monitoring: true,\n    socketTimeout: self.s.options.connectionTimeout || 2000\n  }, function (err, r) {\n    if (self.state == DESTROYED || self.state == UNREFERENCED) {\n      server.destroy({\n        force: true\n      });\n      return cb(err, r);\n    } // Calculate latency\n\n\n    var latencyMS = new Date().getTime() - start; // Set the last updatedTime\n\n    var hrTime = process.hrtime(); // Calculate the last update time\n\n    server.lastUpdateTime = hrTime[0] * 1000 + Math.round(hrTime[1] / 1000); // We had an error, remove it from the state\n\n    if (err) {\n      // Emit the server heartbeat failure\n      emitSDAMEvent(self, 'serverHeartbeatFailed', {\n        durationMS: latencyMS,\n        failure: err,\n        connectionId: server.name\n      }); // Remove server from the state\n\n      self.s.replicaSetState.remove(server);\n    } else {\n      // Update the server ismaster\n      server.ismaster = r.result; // Check if we have a lastWriteDate convert it to MS\n      // and store on the server instance for later use\n\n      if (server.ismaster.lastWrite && server.ismaster.lastWrite.lastWriteDate) {\n        server.lastWriteDate = server.ismaster.lastWrite.lastWriteDate.getTime();\n      } // Do we have a brand new server\n\n\n      if (server.lastIsMasterMS == -1) {\n        server.lastIsMasterMS = latencyMS;\n      } else if (server.lastIsMasterMS) {\n        // After the first measurement, average RTT MUST be computed using an\n        // exponentially-weighted moving average formula, with a weighting factor (alpha) of 0.2.\n        // If the prior average is denoted old_rtt, then the new average (new_rtt) is\n        // computed from a new RTT measurement (x) using the following formula:\n        // alpha = 0.2\n        // new_rtt = alpha * x + (1 - alpha) * old_rtt\n        server.lastIsMasterMS = 0.2 * latencyMS + (1 - 0.2) * server.lastIsMasterMS;\n      }\n\n      if (self.s.replicaSetState.update(server)) {\n        // Primary lastIsMaster store it\n        if (server.lastIsMaster() && server.lastIsMaster().ismaster) {\n          self.ismaster = server.lastIsMaster();\n        }\n      } // Server heart beat event\n\n\n      emitSDAMEvent(self, 'serverHeartbeatSucceeded', {\n        durationMS: latencyMS,\n        reply: r.result,\n        connectionId: server.name\n      });\n    } // Calculate the staleness for this server\n\n\n    self.s.replicaSetState.updateServerMaxStaleness(server, self.s.haInterval); // Callback\n\n    cb(err, r);\n  });\n}; // Each server is monitored in parallel in their own timeout loop\n\n\nvar monitorServer = function (host, self, options) {\n  // If this is not the initial scan\n  // Is this server already being monitoried, then skip monitoring\n  if (!options.haInterval) {\n    for (var i = 0; i < self.intervalIds.length; i++) {\n      if (self.intervalIds[i].__host === host) {\n        return;\n      }\n    }\n  } // Get the haInterval\n\n\n  var _process = options.haInterval ? Timeout : Interval;\n\n  var _haInterval = options.haInterval ? options.haInterval : self.s.haInterval; // Create the interval\n\n\n  var intervalId = new _process(function () {\n    if (self.state == DESTROYED || self.state == UNREFERENCED) {\n      // clearInterval(intervalId);\n      intervalId.stop();\n      return;\n    } // Do we already have server connection available for this host\n\n\n    var _server = self.s.replicaSetState.get(host); // Check if we have a known server connection and reuse\n\n\n    if (_server) {\n      // Ping the server\n      return pingServer(self, _server, function (err) {\n        if (self.state == DESTROYED || self.state == UNREFERENCED) {\n          intervalId.stop();\n          return;\n        } // Filter out all called intervaliIds\n\n\n        self.intervalIds = self.intervalIds.filter(function (intervalId) {\n          return intervalId.isRunning();\n        }); // Initial sweep\n\n        if (_process === Timeout) {\n          if (self.state == CONNECTING && (self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed || self.s.replicaSetState.hasPrimary())) {\n            self.state = CONNECTED; // Emit connected sign\n\n            process.nextTick(function () {\n              self.emit('connect', self);\n            }); // Start topology interval check\n\n            topologyMonitor(self, {});\n          }\n        } else {\n          if (self.state == DISCONNECTED && (self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed || self.s.replicaSetState.hasPrimary())) {\n            self.state = CONNECTED; // Rexecute any stalled operation\n\n            rexecuteOperations(self); // Emit connected sign\n\n            process.nextTick(function () {\n              self.emit('reconnect', self);\n            });\n          }\n        }\n\n        if (self.initialConnectState.connect && !self.initialConnectState.fullsetup && self.s.replicaSetState.hasPrimaryAndSecondary()) {\n          // Set initial connect state\n          self.initialConnectState.fullsetup = true;\n          self.initialConnectState.all = true;\n          process.nextTick(function () {\n            self.emit('fullsetup', self);\n            self.emit('all', self);\n          });\n        }\n      });\n    }\n  }, _haInterval); // Start the interval\n\n  intervalId.start(); // Add the intervalId host name\n\n  intervalId.__host = host; // Add the intervalId to our list of intervalIds\n\n  self.intervalIds.push(intervalId);\n};\n\nfunction topologyMonitor(self, options) {\n  if (self.state == DESTROYED || self.state == UNREFERENCED) return;\n  options = options || {}; // Get the servers\n\n  var servers = Object.keys(self.s.replicaSetState.set); // Get the haInterval\n\n  var _process = options.haInterval ? Timeout : Interval;\n\n  var _haInterval = options.haInterval ? options.haInterval : self.s.haInterval;\n\n  if (_process === Timeout) {\n    return connectNewServers(self, self.s.replicaSetState.unknownServers, function (err) {\n      // Don't emit errors if the connection was already\n      if (self.state === DESTROYED || self.state === UNREFERENCED) {\n        return;\n      }\n\n      if (!self.s.replicaSetState.hasPrimary() && !self.s.options.secondaryOnlyConnectionAllowed) {\n        if (err) return self.emit('error', err);\n        self.emit('error', new MongoError('no primary found in replicaset or invalid replica set name'));\n        return self.destroy({\n          force: true\n        });\n      } else if (!self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed) {\n        if (err) return self.emit('error', err);\n        self.emit('error', new MongoError('no secondary found in replicaset or invalid replica set name'));\n        return self.destroy({\n          force: true\n        });\n      }\n\n      for (var i = 0; i < servers.length; i++) {\n        monitorServer(servers[i], self, options);\n      }\n    });\n  } else {\n    for (var i = 0; i < servers.length; i++) {\n      monitorServer(servers[i], self, options);\n    }\n  } // Run the reconnect process\n\n\n  function executeReconnect(self) {\n    return function () {\n      if (self.state == DESTROYED || self.state == UNREFERENCED) {\n        return;\n      }\n\n      connectNewServers(self, self.s.replicaSetState.unknownServers, function () {\n        var monitoringFrequencey = self.s.replicaSetState.hasPrimary() ? _haInterval : self.s.minHeartbeatFrequencyMS; // Create a timeout\n\n        self.intervalIds.push(new Timeout(executeReconnect(self), monitoringFrequencey).start());\n      });\n    };\n  } // Decide what kind of interval to use\n\n\n  var intervalTime = !self.s.replicaSetState.hasPrimary() ? self.s.minHeartbeatFrequencyMS : _haInterval;\n  self.intervalIds.push(new Timeout(executeReconnect(self), intervalTime).start());\n}\n\nfunction addServerToList(list, server) {\n  for (var i = 0; i < list.length; i++) {\n    if (list[i].name.toLowerCase() === server.name.toLowerCase()) return true;\n  }\n\n  list.push(server);\n}\n\nfunction handleEvent(self, event) {\n  return function () {\n    if (self.state == DESTROYED || self.state == UNREFERENCED) return; // Debug log\n\n    if (self.s.logger.isDebug()) {\n      self.s.logger.debug(f('handleEvent %s from server %s in replset with id %s', event, this.name, self.id));\n    } // Remove from the replicaset state\n\n\n    self.s.replicaSetState.remove(this); // Are we in a destroyed state return\n\n    if (self.state == DESTROYED || self.state == UNREFERENCED) return; // If no primary and secondary available\n\n    if (!self.s.replicaSetState.hasPrimary() && !self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed) {\n      stateTransition(self, DISCONNECTED);\n    } else if (!self.s.replicaSetState.hasPrimary()) {\n      stateTransition(self, DISCONNECTED);\n    }\n\n    addServerToList(self.s.connectingServers, this);\n  };\n}\n\nfunction applyAuthenticationContexts(self, server, callback) {\n  if (self.s.authenticationContexts.length == 0) {\n    return callback();\n  } // Do not apply any auth contexts if it's an arbiter\n\n\n  if (server.lastIsMaster() && server.lastIsMaster().arbiterOnly) {\n    return callback();\n  } // Copy contexts to ensure no modificiation in the middle of\n  // auth process.\n\n\n  var authContexts = self.s.authenticationContexts.slice(0); // Apply one of the contexts\n\n  function applyAuth(authContexts, server, callback) {\n    if (authContexts.length == 0) return callback(); // Get the first auth context\n\n    var authContext = authContexts.shift(); // Copy the params\n\n    var customAuthContext = authContext.slice(0); // Push our callback handler\n\n    customAuthContext.push(function (err) {\n      applyAuth(authContexts, server, callback);\n    }); // Attempt authentication\n\n    server.auth.apply(server, customAuthContext);\n  } // Apply all auth contexts\n\n\n  applyAuth(authContexts, server, callback);\n}\n\nfunction shouldTriggerConnect(self) {\n  var secondaryReadPreferenceString = ReadPreference.secondary.preference || ReadPreference.secondary.mode;\n  var currentReadPreferenceString = self.s.connectOptions.readPreference && (self.s.connectOptions.readPreference.preference || self.s.connectOptions.readPreference.mode);\n  var isConnecting = self.state === CONNECTING;\n  var hasPrimary = self.s.replicaSetState.hasPrimary();\n  var hasSecondary = self.s.replicaSetState.hasSecondary();\n  var secondaryOnlyConnectionAllowed = self.s.options.secondaryOnlyConnectionAllowed;\n  var readPreferenceSecondary = secondaryReadPreferenceString === currentReadPreferenceString;\n  return isConnecting && (readPreferenceSecondary && hasSecondary || !readPreferenceSecondary && hasPrimary) || hasSecondary && secondaryOnlyConnectionAllowed;\n}\n\nfunction handleInitialConnectEvent(self, event) {\n  return function () {\n    var _this = this; // Debug log\n\n\n    if (self.s.logger.isDebug()) {\n      self.s.logger.debug(f('handleInitialConnectEvent %s from server %s in replset with id %s', event, this.name, self.id));\n    } // Destroy the instance\n\n\n    if (self.state == DESTROYED || self.state == UNREFERENCED) {\n      return this.destroy({\n        force: true\n      });\n    } // Check the type of server\n\n\n    if (event == 'connect') {\n      // Do we have authentication contexts that need to be applied\n      applyAuthenticationContexts(self, _this, function () {\n        // Destroy the instance\n        if (self.state == DESTROYED || self.state == UNREFERENCED) {\n          return _this.destroy({\n            force: true\n          });\n        } // Update the state\n\n\n        var result = self.s.replicaSetState.update(_this);\n\n        if (result == true) {\n          // Primary lastIsMaster store it\n          if (_this.lastIsMaster() && _this.lastIsMaster().ismaster) {\n            self.ismaster = _this.lastIsMaster();\n          } // Debug log\n\n\n          if (self.s.logger.isDebug()) {\n            self.s.logger.debug(f('handleInitialConnectEvent %s from server %s in replset with id %s has state [%s]', event, _this.name, self.id, JSON.stringify(self.s.replicaSetState.set)));\n          } // Remove the handlers\n\n\n          for (var i = 0; i < handlers.length; i++) {\n            _this.removeAllListeners(handlers[i]);\n          } // Add stable state handlers\n\n\n          _this.on('error', handleEvent(self, 'error'));\n\n          _this.on('close', handleEvent(self, 'close'));\n\n          _this.on('timeout', handleEvent(self, 'timeout'));\n\n          _this.on('parseError', handleEvent(self, 'parseError')); // Do we have a primary or primaryAndSecondary\n\n\n          if (shouldTriggerConnect(self)) {\n            // We are connected\n            self.state = CONNECTED; // Set initial connect state\n\n            self.initialConnectState.connect = true; // Emit connect event\n\n            process.nextTick(function () {\n              self.emit('connect', self);\n            });\n            topologyMonitor(self, {});\n          }\n        } else if (result instanceof MongoError) {\n          _this.destroy({\n            force: true\n          });\n\n          self.destroy({\n            force: true\n          });\n          return self.emit('error', result);\n        } else {\n          _this.destroy({\n            force: true\n          });\n        }\n      });\n    } else {\n      // Emit failure to connect\n      self.emit('failed', this);\n      addServerToList(self.s.connectingServers, this); // Remove from the state\n\n      self.s.replicaSetState.remove(this);\n    }\n\n    if (self.initialConnectState.connect && !self.initialConnectState.fullsetup && self.s.replicaSetState.hasPrimaryAndSecondary()) {\n      // Set initial connect state\n      self.initialConnectState.fullsetup = true;\n      self.initialConnectState.all = true;\n      process.nextTick(function () {\n        self.emit('fullsetup', self);\n        self.emit('all', self);\n      });\n    } // Remove from the list from connectingServers\n\n\n    for (var i = 0; i < self.s.connectingServers.length; i++) {\n      if (self.s.connectingServers[i].equals(this)) {\n        self.s.connectingServers.splice(i, 1);\n      }\n    } // Trigger topologyMonitor\n\n\n    if (self.s.connectingServers.length == 0 && self.state == CONNECTING) {\n      topologyMonitor(self, {\n        haInterval: 1\n      });\n    }\n  };\n}\n\nfunction connectServers(self, servers) {\n  // Update connectingServers\n  self.s.connectingServers = self.s.connectingServers.concat(servers); // Index used to interleaf the server connects, avoiding\n  // runtime issues on io constrained vm's\n\n  var timeoutInterval = 0;\n\n  function connect(server, timeoutInterval) {\n    setTimeout(function () {\n      // Add the server to the state\n      if (self.s.replicaSetState.update(server)) {\n        // Primary lastIsMaster store it\n        if (server.lastIsMaster() && server.lastIsMaster().ismaster) {\n          self.ismaster = server.lastIsMaster();\n        }\n      } // Add event handlers\n\n\n      server.once('close', handleInitialConnectEvent(self, 'close'));\n      server.once('timeout', handleInitialConnectEvent(self, 'timeout'));\n      server.once('parseError', handleInitialConnectEvent(self, 'parseError'));\n      server.once('error', handleInitialConnectEvent(self, 'error'));\n      server.once('connect', handleInitialConnectEvent(self, 'connect')); // SDAM Monitoring events\n\n      server.on('serverOpening', function (e) {\n        self.emit('serverOpening', e);\n      });\n      server.on('serverDescriptionChanged', function (e) {\n        self.emit('serverDescriptionChanged', e);\n      });\n      server.on('serverClosed', function (e) {\n        self.emit('serverClosed', e);\n      }); // Start connection\n\n      server.connect(self.s.connectOptions);\n    }, timeoutInterval);\n  } // Start all the servers\n\n\n  while (servers.length > 0) {\n    connect(servers.shift(), timeoutInterval++);\n  }\n}\n/**\n * Emit event if it exists\n * @method\n */\n\n\nfunction emitSDAMEvent(self, event, description) {\n  if (self.listeners(event).length > 0) {\n    self.emit(event, description);\n  }\n}\n/**\n * Initiate server connect\n * @method\n * @param {array} [options.auth=null] Array of auth options to apply on connect\n */\n\n\nReplSet.prototype.connect = function (options) {\n  var self = this; // Add any connect level options to the internal state\n\n  this.s.connectOptions = options || {}; // Set connecting state\n\n  stateTransition(this, CONNECTING); // Create server instances\n\n  var servers = this.s.seedlist.map(function (x) {\n    return new Server(assign({}, self.s.options, x, {\n      authProviders: self.authProviders,\n      reconnect: false,\n      monitoring: false,\n      inTopology: true\n    }, {\n      clientInfo: clone(self.s.clientInfo)\n    }));\n  }); // Error out as high availbility interval must be < than socketTimeout\n\n  if (this.s.options.socketTimeout > 0 && this.s.options.socketTimeout <= this.s.options.haInterval) {\n    return self.emit('error', new MongoError(f(\"haInterval [%s] MS must be set to less than socketTimeout [%s] MS\", this.s.options.haInterval, this.s.options.socketTimeout)));\n  } // Emit the topology opening event\n\n\n  emitSDAMEvent(this, 'topologyOpening', {\n    topologyId: this.id\n  }); // Start all server connections\n\n  connectServers(self, servers);\n};\n/**\n * Destroy the server connection\n * @param {boolean} [options.force=false] Force destroy the pool\n * @method\n */\n\n\nReplSet.prototype.destroy = function (options) {\n  options = options || {}; // Transition state\n\n  stateTransition(this, DESTROYED); // Clear out any monitoring process\n\n  if (this.haTimeoutId) clearTimeout(this.haTimeoutId); // Destroy the replicaset\n\n  this.s.replicaSetState.destroy(options); // Clear out authentication contexts\n\n  this.s.authenticationContexts = []; // Destroy all connecting servers\n\n  this.s.connectingServers.forEach(function (x) {\n    x.destroy(options);\n  }); // Clear out all monitoring\n\n  for (var i = 0; i < this.intervalIds.length; i++) {\n    this.intervalIds[i].stop();\n    this.intervalIds[i].stop();\n  } // Reset list of intervalIds\n\n\n  this.intervalIds = []; // Emit toplogy closing event\n\n  emitSDAMEvent(this, 'topologyClosed', {\n    topologyId: this.id\n  });\n};\n/**\n * Unref all connections belong to this server\n * @method\n */\n\n\nReplSet.prototype.unref = function () {\n  // Transition state\n  stateTransition(this, UNREFERENCED);\n  this.s.replicaSetState.allServers().forEach(function (x) {\n    x.unref();\n  });\n  clearTimeout(this.haTimeoutId);\n};\n/**\n * Returns the last known ismaster document for this server\n * @method\n * @return {object}\n */\n\n\nReplSet.prototype.lastIsMaster = function () {\n  // If secondaryOnlyConnectionAllowed and no primary but secondary\n  // return the secondaries ismaster result.\n  if (this.s.options.secondaryOnlyConnectionAllowed && !this.s.replicaSetState.hasPrimary() && this.s.replicaSetState.hasSecondary()) {\n    return this.s.replicaSetState.secondaries[0].lastIsMaster();\n  }\n\n  return this.s.replicaSetState.primary ? this.s.replicaSetState.primary.lastIsMaster() : this.ismaster;\n};\n/**\n * All raw connections\n * @method\n * @return {Connection[]}\n */\n\n\nReplSet.prototype.connections = function () {\n  var servers = this.s.replicaSetState.allServers();\n  var connections = [];\n\n  for (var i = 0; i < servers.length; i++) {\n    connections = connections.concat(servers[i].connections());\n  }\n\n  return connections;\n};\n/**\n * Figure out if the server is connected\n * @method\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @return {boolean}\n */\n\n\nReplSet.prototype.isConnected = function (options) {\n  options = options || {}; // If we are authenticating signal not connected\n  // To avoid interleaving of operations\n\n  if (this.authenticating) return false; // If we specified a read preference check if we are connected to something\n  // than can satisfy this\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.secondary)) {\n    return this.s.replicaSetState.hasSecondary();\n  }\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.primary)) {\n    return this.s.replicaSetState.hasPrimary();\n  }\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.primaryPreferred)) {\n    return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();\n  }\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.secondaryPreferred)) {\n    return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();\n  }\n\n  if (this.s.options.secondaryOnlyConnectionAllowed && this.s.replicaSetState.hasSecondary()) {\n    return true;\n  }\n\n  return this.s.replicaSetState.hasPrimary();\n};\n/**\n * Figure out if the replicaset instance was destroyed by calling destroy\n * @method\n * @return {boolean}\n */\n\n\nReplSet.prototype.isDestroyed = function () {\n  return this.state == DESTROYED;\n};\n/**\n * Get server\n * @method\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @return {Server}\n */\n\n\nReplSet.prototype.getServer = function (options) {\n  // Ensure we have no options\n  options = options || {}; // Pick the right server baspickServerd on readPreference\n\n  var server = this.s.replicaSetState.pickServer(options.readPreference);\n  if (this.s.debug) this.emit('pickedServer', options.readPreference, server);\n  return server;\n};\n/**\n * Get a direct connection\n * @method\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @return {Connection}\n */\n\n\nReplSet.prototype.getConnection = function (options) {\n  var server = this.getServer(options);\n  if (server) return server.getConnection();\n};\n/**\n * Get all connected servers\n * @method\n * @return {Server[]}\n */\n\n\nReplSet.prototype.getServers = function () {\n  return this.s.replicaSetState.allServers();\n}; //\n// Execute write operation\n\n\nvar executeWriteOperation = function (self, op, ns, ops, options, callback) {\n  if (typeof options == 'function') callback = options, options = {}, options = options || {}; // Ensure we have no options\n\n  options = options || {}; // No server returned we had an error\n\n  if (self.s.replicaSetState.primary == null) {\n    return callback(new MongoError(\"no primary server found\"));\n  }\n\n  function cb(err) {\n    if (err && err.message && err.message.match(/not master/)) {\n      self.s.replicaSetState.remove(self.s.replicaSetState.primary, {\n        force: true\n      });\n    }\n\n    return callback.apply(undefined, arguments);\n  } // Execute the command\n\n\n  self.s.replicaSetState.primary[op](ns, ops, options, cb);\n};\n/**\n * Insert one or more documents\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of documents to insert\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {opResultCallback} callback A callback function\n */\n\n\nReplSet.prototype.insert = function (ns, ops, options, callback) {\n  if (typeof options == 'function') callback = options, options = {}, options = options || {};\n  if (this.state == DESTROYED) return callback(new MongoError(f('topology was destroyed'))); // Not connected but we have a disconnecthandler\n\n  if (!this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {\n    return this.s.disconnectHandler.add('insert', ns, ops, options, callback);\n  } // Execute write operation\n\n\n  executeWriteOperation(this, 'insert', ns, ops, options, callback);\n};\n/**\n * Perform one or more update operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of updates\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {opResultCallback} callback A callback function\n */\n\n\nReplSet.prototype.update = function (ns, ops, options, callback) {\n  if (typeof options == 'function') callback = options, options = {}, options = options || {};\n  if (this.state == DESTROYED) return callback(new MongoError(f('topology was destroyed'))); // Not connected but we have a disconnecthandler\n\n  if (!this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {\n    return this.s.disconnectHandler.add('update', ns, ops, options, callback);\n  } // Execute write operation\n\n\n  executeWriteOperation(this, 'update', ns, ops, options, callback);\n};\n/**\n * Perform one or more remove operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of removes\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {opResultCallback} callback A callback function\n */\n\n\nReplSet.prototype.remove = function (ns, ops, options, callback) {\n  if (typeof options == 'function') callback = options, options = {}, options = options || {};\n  if (this.state == DESTROYED) return callback(new MongoError(f('topology was destroyed'))); // Not connected but we have a disconnecthandler\n\n  if (!this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {\n    return this.s.disconnectHandler.add('remove', ns, ops, options, callback);\n  } // Execute write operation\n\n\n  executeWriteOperation(this, 'remove', ns, ops, options, callback);\n};\n/**\n * Execute a command\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cmd The command hash\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Connection} [options.connection] Specify connection object to execute command against\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {opResultCallback} callback A callback function\n */\n\n\nReplSet.prototype.command = function (ns, cmd, options, callback) {\n  if (typeof options == 'function') callback = options, options = {}, options = options || {};\n  if (this.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));\n  var self = this; // Establish readPreference\n\n  var readPreference = options.readPreference ? options.readPreference : ReadPreference.primary; // If the readPreference is primary and we have no primary, store it\n\n  if (readPreference.preference == 'primary' && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\n  } else if (readPreference.preference == 'secondary' && !this.s.replicaSetState.hasSecondary() && this.s.disconnectHandler != null) {\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\n  } else if (readPreference.preference != 'primary' && !this.s.replicaSetState.hasSecondary() && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\n  } // Pick a server\n\n\n  var server = this.s.replicaSetState.pickServer(readPreference); // We received an error, return it\n\n  if (!(server instanceof Server)) return callback(server); // Emit debug event\n\n  if (self.s.debug) self.emit('pickedServer', ReadPreference.primary, server); // No server returned we had an error\n\n  if (server == null) {\n    return callback(new MongoError(f(\"no server found that matches the provided readPreference %s\", readPreference)));\n  } // Execute the command\n\n\n  server.command(ns, cmd, options, callback);\n};\n/**\n * Authenticate using a specified mechanism\n * @method\n * @param {string} mechanism The Auth mechanism we are invoking\n * @param {string} db The db we are invoking the mechanism against\n * @param {...object} param Parameters for the specific mechanism\n * @param {authResultCallback} callback A callback function\n */\n\n\nReplSet.prototype.auth = function (mechanism, db) {\n  var allArgs = Array.prototype.slice.call(arguments, 0).slice(0);\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 2);\n  var callback = args.pop();\n  var currentContextIndex = 0; // If we don't have the mechanism fail\n\n  if (this.authProviders[mechanism] == null && mechanism != 'default') {\n    return callback(new MongoError(f(\"auth provider %s does not exist\", mechanism)));\n  } // Are we already authenticating, throw\n\n\n  if (this.authenticating) {\n    return callback(new MongoError('authentication or logout allready in process'));\n  } // Topology is not connected, save the call in the provided store to be\n  // Executed at some point when the handler deems it's reconnected\n\n\n  if (self.s.disconnectHandler != null) {\n    if (!self.s.replicaSetState.hasPrimary() && !self.s.options.secondaryOnlyConnectionAllowed) {\n      return self.s.disconnectHandler.add('auth', db, allArgs, {}, callback);\n    } else if (!self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed) {\n      return self.s.disconnectHandler.add('auth', db, allArgs, {}, callback);\n    }\n  } // Set to authenticating\n\n\n  this.authenticating = true; // All errors\n\n  var errors = []; // Get all the servers\n\n  var servers = this.s.replicaSetState.allServers(); // No servers return\n\n  if (servers.length == 0) {\n    this.authenticating = false;\n    callback(null, true);\n  } // Authenticate\n\n\n  function auth(server) {\n    // Arguments without a callback\n    var argsWithoutCallback = [mechanism, db].concat(args.slice(0)); // Create arguments\n\n    var finalArguments = argsWithoutCallback.concat([function (err) {\n      count = count - 1; // Save all the errors\n\n      if (err) errors.push({\n        name: server.name,\n        err: err\n      }); // We are done\n\n      if (count == 0) {\n        // Auth is done\n        self.authenticating = false; // Return the auth error\n\n        if (errors.length) {\n          // Remove the entry from the stored authentication contexts\n          self.s.authenticationContexts.splice(currentContextIndex, 0); // Return error\n\n          return callback(MongoError.create({\n            message: 'authentication fail',\n            errors: errors\n          }), false);\n        } // Successfully authenticated session\n\n\n        callback(null, self);\n      }\n    }]);\n\n    if (!server.lastIsMaster().arbiterOnly) {\n      // Execute the auth only against non arbiter servers\n      server.auth.apply(server, finalArguments);\n    } else {\n      // If we are authenticating against an arbiter just ignore it\n      finalArguments.pop()(null);\n    }\n  } // Get total count\n\n\n  var count = servers.length; // Save current context index\n\n  currentContextIndex = this.s.authenticationContexts.length; // Store the auth context and return the last index\n\n  this.s.authenticationContexts.push([mechanism, db].concat(args.slice(0))); // Authenticate against all servers\n\n  while (servers.length > 0) {\n    auth(servers.shift());\n  }\n};\n/**\n * Logout from a database\n * @method\n * @param {string} db The db we are logging out from\n * @param {authResultCallback} callback A callback function\n */\n\n\nReplSet.prototype.logout = function (dbName, callback) {\n  var self = this; // Are we authenticating or logging out, throw\n\n  if (this.authenticating) {\n    throw new MongoError('authentication or logout allready in process');\n  } // Ensure no new members are processed while logging out\n\n\n  this.authenticating = true; // Remove from all auth providers (avoid any reaplication of the auth details)\n\n  var providers = Object.keys(this.authProviders);\n\n  for (var i = 0; i < providers.length; i++) {\n    this.authProviders[providers[i]].logout(dbName);\n  } // Clear out any contexts associated with the db\n\n\n  self.s.authenticationContexts = self.s.authenticationContexts.filter(function (context) {\n    return context[1] !== dbName;\n  }); // Now logout all the servers\n\n  var servers = this.s.replicaSetState.allServers();\n  var count = servers.length;\n  if (count == 0) return callback();\n  var errors = [];\n\n  function logoutServer(_server, cb) {\n    _server.logout(dbName, function (err) {\n      if (err) errors.push({\n        name: _server.name,\n        err: err\n      });\n      cb();\n    });\n  } // Execute logout on all server instances\n\n\n  for (i = 0; i < servers.length; i++) {\n    logoutServer(servers[i], function () {\n      count = count - 1;\n\n      if (count == 0) {\n        // Do not block new operations\n        self.authenticating = false; // If we have one or more errors\n\n        if (errors.length) return callback(MongoError.create({\n          message: f('logout failed against db %s', dbName),\n          errors: errors\n        }), false); // No errors\n\n        callback();\n      }\n    });\n  }\n};\n/**\n * Perform one or more remove operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {{object}|{Long}} cmd Can be either a command returning a cursor or a cursorId\n * @param {object} [options.batchSize=0] Batchsize for the operation\n * @param {array} [options.documents=[]] Initial documents list for cursor\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {opResultCallback} callback A callback function\n */\n\n\nReplSet.prototype.cursor = function (ns, cmd, cursorOptions) {\n  cursorOptions = cursorOptions || {};\n  var FinalCursor = cursorOptions.cursorFactory || this.s.Cursor;\n  return new FinalCursor(this.s.bson, ns, cmd, cursorOptions, this, this.s.options);\n};\n/**\n * A replset connect event, used to verify that the connection is up and running\n *\n * @event ReplSet#connect\n * @type {ReplSet}\n */\n\n/**\n * A replset reconnect event, used to verify that the topology reconnected\n *\n * @event ReplSet#reconnect\n * @type {ReplSet}\n */\n\n/**\n * A replset fullsetup event, used to signal that all topology members have been contacted.\n *\n * @event ReplSet#fullsetup\n * @type {ReplSet}\n */\n\n/**\n * A replset all event, used to signal that all topology members have been contacted.\n *\n * @event ReplSet#all\n * @type {ReplSet}\n */\n\n/**\n * A replset failed event, used to signal that initial replset connection failed.\n *\n * @event ReplSet#failed\n * @type {ReplSet}\n */\n\n/**\n * A server member left the replicaset\n *\n * @event ReplSet#left\n * @type {function}\n * @param {string} type The type of member that left (primary|secondary|arbiter)\n * @param {Server} server The server object that left\n */\n\n/**\n * A server member joined the replicaset\n *\n * @event ReplSet#joined\n * @type {function}\n * @param {string} type The type of member that joined (primary|secondary|arbiter)\n * @param {Server} server The server object that joined\n */\n\n/**\n * A server opening SDAM monitoring event\n *\n * @event ReplSet#serverOpening\n * @type {object}\n */\n\n/**\n * A server closed SDAM monitoring event\n *\n * @event ReplSet#serverClosed\n * @type {object}\n */\n\n/**\n * A server description SDAM change monitoring event\n *\n * @event ReplSet#serverDescriptionChanged\n * @type {object}\n */\n\n/**\n * A topology open SDAM event\n *\n * @event ReplSet#topologyOpening\n * @type {object}\n */\n\n/**\n * A topology closed SDAM event\n *\n * @event ReplSet#topologyClosed\n * @type {object}\n */\n\n/**\n * A topology structure SDAM change event\n *\n * @event ReplSet#topologyDescriptionChanged\n * @type {object}\n */\n\n/**\n * A topology serverHeartbeatStarted SDAM event\n *\n * @event ReplSet#serverHeartbeatStarted\n * @type {object}\n */\n\n/**\n * A topology serverHeartbeatFailed SDAM event\n *\n * @event ReplSet#serverHeartbeatFailed\n * @type {object}\n */\n\n/**\n * A topology serverHeartbeatSucceeded SDAM change event\n *\n * @event ReplSet#serverHeartbeatSucceeded\n * @type {object}\n */\n\n\nmodule.exports = ReplSet;","map":null,"metadata":{},"sourceType":"script"}