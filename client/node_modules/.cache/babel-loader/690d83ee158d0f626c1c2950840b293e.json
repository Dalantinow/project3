{"ast":null,"code":"\"use strict\";\n\nvar f = require('util').format,\n    crypto = require('crypto'),\n    retrieveBSON = require('../connection/utils').retrieveBSON,\n    Query = require('../connection/commands').Query,\n    MongoError = require('../error');\n\nvar BSON = retrieveBSON(),\n    Binary = BSON.Binary;\n\nvar AuthSession = function (db, username, password) {\n  this.db = db;\n  this.username = username;\n  this.password = password;\n};\n\nAuthSession.prototype.equal = function (session) {\n  return session.db == this.db && session.username == this.username && session.password == this.password;\n};\n\nvar id = 0;\n/**\n * Creates a new ScramSHA1 authentication mechanism\n * @class\n * @return {ScramSHA1} A cursor instance\n */\n\nvar ScramSHA1 = function (bson) {\n  this.bson = bson;\n  this.authStore = [];\n  this.id = id++;\n};\n\nvar parsePayload = function (payload) {\n  var dict = {};\n  var parts = payload.split(',');\n\n  for (var i = 0; i < parts.length; i++) {\n    var valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n};\n\nvar passwordDigest = function (username, password) {\n  if (typeof username != 'string') throw new MongoError(\"username must be a string\");\n  if (typeof password != 'string') throw new MongoError(\"password must be a string\");\n  if (password.length == 0) throw new MongoError(\"password cannot be empty\"); // Use node md5 generator\n\n  var md5 = crypto.createHash('md5'); // Generate keys used for authentication\n\n  md5.update(username + \":mongo:\" + password, 'utf8');\n  return md5.digest('hex');\n}; // XOR two buffers\n\n\nvar xor = function (a, b) {\n  if (!Buffer.isBuffer(a)) a = new Buffer(a);\n  if (!Buffer.isBuffer(b)) b = new Buffer(b);\n  var res = [];\n\n  if (a.length > b.length) {\n    for (var i = 0; i < b.length; i++) {\n      res.push(a[i] ^ b[i]);\n    }\n  } else {\n    for (i = 0; i < a.length; i++) {\n      res.push(a[i] ^ b[i]);\n    }\n  }\n\n  return new Buffer(res);\n};\n\nvar _hiCache = {};\nvar _hiCacheCount = 0;\n\nvar _hiCachePurge = function () {\n  _hiCache = {};\n  _hiCacheCount = 0;\n};\n\nvar hi = function (data, salt, iterations) {\n  // omit the work if already generated\n  var key = [data, salt.toString('base64'), iterations].join('_');\n\n  if (_hiCache[key] !== undefined) {\n    return _hiCache[key];\n  } // generate the salt\n\n\n  var saltedData = crypto.pbkdf2Sync(data, salt, iterations, 20, \"sha1\"); // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n};\n/**\n * Authenticate\n * @method\n * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on\n * @param {[]Connections} connections Connections to authenticate using this authenticator\n * @param {string} db Name of the database\n * @param {string} username Username\n * @param {string} password Password\n * @param {authResultCallback} callback The callback to return the result from the authentication\n * @return {object}\n */\n\n\nScramSHA1.prototype.auth = function (server, connections, db, username, password, callback) {\n  var self = this; // Total connections\n\n  var count = connections.length;\n  if (count == 0) return callback(null, null); // Valid connections\n\n  var numberOfValidConnections = 0;\n  var errorObject = null; // Execute MongoCR\n\n  var executeScram = function (connection) {\n    // Clean up the user\n    username = username.replace('=', \"=3D\").replace(',', '=2C'); // Create a random nonce\n\n    var nonce = crypto.randomBytes(24).toString('base64'); // var nonce = 'MsQUY9iw0T9fx2MUEz6LZPwGuhVvWAhc'\n\n    var firstBare = f(\"n=%s,r=%s\", username, nonce); // Build command structure\n\n    var cmd = {\n      saslStart: 1,\n      mechanism: 'SCRAM-SHA-1',\n      payload: new Binary(f(\"n,,%s\", firstBare)),\n      autoAuthorize: 1 // Handle the error\n\n    };\n\n    var handleError = function (err, r) {\n      if (err) {\n        numberOfValidConnections = numberOfValidConnections - 1;\n        errorObject = err;\n        return false;\n      } else if (r.result['$err']) {\n        errorObject = r.result;\n        return false;\n      } else if (r.result['errmsg']) {\n        errorObject = r.result;\n        return false;\n      } else {\n        numberOfValidConnections = numberOfValidConnections + 1;\n      }\n\n      return true;\n    }; // Finish up\n\n\n    var finish = function (_count, _numberOfValidConnections) {\n      if (_count == 0 && _numberOfValidConnections > 0) {\n        // Store the auth details\n        addAuthSession(self.authStore, new AuthSession(db, username, password)); // Return correct authentication\n\n        return callback(null, true);\n      } else if (_count == 0) {\n        if (errorObject == null) errorObject = new MongoError(f(\"failed to authenticate using scram\"));\n        return callback(errorObject, false);\n      }\n    };\n\n    var handleEnd = function (_err, _r) {\n      // Handle any error\n      handleError(_err, _r); // Adjust the number of connections\n\n      count = count - 1; // Execute the finish\n\n      finish(count, numberOfValidConnections);\n    }; // Write the commmand on the connection\n\n\n    server(connection, new Query(self.bson, f(\"%s.$cmd\", db), cmd, {\n      numberToSkip: 0,\n      numberToReturn: 1\n    }), function (err, r) {\n      // Do we have an error, handle it\n      if (handleError(err, r) == false) {\n        count = count - 1;\n\n        if (count == 0 && numberOfValidConnections > 0) {\n          // Store the auth details\n          addAuthSession(self.authStore, new AuthSession(db, username, password)); // Return correct authentication\n\n          return callback(null, true);\n        } else if (count == 0) {\n          if (errorObject == null) errorObject = new MongoError(f(\"failed to authenticate using scram\"));\n          return callback(errorObject, false);\n        }\n\n        return;\n      } // Get the dictionary\n\n\n      var dict = parsePayload(r.result.payload.value()); // Unpack dictionary\n\n      var iterations = parseInt(dict.i, 10);\n      var salt = dict.s;\n      var rnonce = dict.r; // Set up start of proof\n\n      var withoutProof = f(\"c=biws,r=%s\", rnonce);\n      var passwordDig = passwordDigest(username, password);\n      var saltedPassword = hi(passwordDig, new Buffer(salt, 'base64'), iterations); // Create the client key\n\n      var hmac = crypto.createHmac('sha1', saltedPassword);\n      hmac.update(new Buffer(\"Client Key\"));\n      var clientKey = new Buffer(hmac.digest('base64'), 'base64'); // Create the stored key\n\n      var hash = crypto.createHash('sha1');\n      hash.update(clientKey);\n      var storedKey = new Buffer(hash.digest('base64'), 'base64'); // Create the authentication message\n\n      var authMsg = [firstBare, r.result.payload.value().toString('base64'), withoutProof].join(','); // Create client signature\n\n      hmac = crypto.createHmac('sha1', storedKey);\n      hmac.update(new Buffer(authMsg));\n      var clientSig = new Buffer(hmac.digest('base64'), 'base64'); // Create client proof\n\n      var clientProof = f(\"p=%s\", new Buffer(xor(clientKey, clientSig)).toString('base64')); // Create client final\n\n      var clientFinal = [withoutProof, clientProof].join(','); //\n      // Create continue message\n\n      var cmd = {\n        saslContinue: 1,\n        conversationId: r.result.conversationId,\n        payload: new Binary(new Buffer(clientFinal)) //\n        // Execute sasl continue\n        // Write the commmand on the connection\n\n      };\n      server(connection, new Query(self.bson, f(\"%s.$cmd\", db), cmd, {\n        numberToSkip: 0,\n        numberToReturn: 1\n      }), function (err, r) {\n        if (r && r.result.done == false) {\n          var cmd = {\n            saslContinue: 1,\n            conversationId: r.result.conversationId,\n            payload: new Buffer(0) // Write the commmand on the connection\n\n          };\n          server(connection, new Query(self.bson, f(\"%s.$cmd\", db), cmd, {\n            numberToSkip: 0,\n            numberToReturn: 1\n          }), function (err, r) {\n            handleEnd(err, r);\n          });\n        } else {\n          handleEnd(err, r);\n        }\n      });\n    });\n  };\n\n  var _execute = function (_connection) {\n    process.nextTick(function () {\n      executeScram(_connection);\n    });\n  }; // For each connection we need to authenticate\n\n\n  while (connections.length > 0) {\n    _execute(connections.shift());\n  }\n}; // Add to store only if it does not exist\n\n\nvar addAuthSession = function (authStore, session) {\n  var found = false;\n\n  for (var i = 0; i < authStore.length; i++) {\n    if (authStore[i].equal(session)) {\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) authStore.push(session);\n};\n/**\n * Remove authStore credentials\n * @method\n * @param {string} db Name of database we are removing authStore details about\n * @return {object}\n */\n\n\nScramSHA1.prototype.logout = function (dbName) {\n  this.authStore = this.authStore.filter(function (x) {\n    return x.db != dbName;\n  });\n};\n/**\n * Re authenticate pool\n * @method\n * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on\n * @param {[]Connections} connections Connections to authenticate using this authenticator\n * @param {authResultCallback} callback The callback to return the result from the authentication\n * @return {object}\n */\n\n\nScramSHA1.prototype.reauthenticate = function (server, connections, callback) {\n  var authStore = this.authStore.slice(0);\n  var count = authStore.length; // No connections\n\n  if (count == 0) return callback(null, null); // Iterate over all the auth details stored\n\n  for (var i = 0; i < authStore.length; i++) {\n    this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, function (err) {\n      count = count - 1; // Done re-authenticating\n\n      if (count == 0) {\n        callback(err, null);\n      }\n    });\n  }\n};\n\nmodule.exports = ScramSHA1;","map":null,"metadata":{},"sourceType":"script"}