{"ast":null,"code":"\"use strict\";\n\nvar os = require('os'),\n    f = require('util').format;\n/**\n * Emit event if it exists\n * @method\n */\n\n\nfunction emitSDAMEvent(self, event, description) {\n  if (self.listeners(event).length > 0) {\n    self.emit(event, description);\n  }\n} // Get package.json variable\n\n\nvar driverVersion = require('../../package.json').version;\n\nvar nodejsversion = f('Node.js %s, %s', process.version, os.endianness());\nvar type = os.type();\nvar name = process.platform;\nvar architecture = process.arch;\nvar release = os.release();\n\nfunction createClientInfo(options) {\n  // Build default client information\n  var clientInfo = options.clientInfo ? clone(options.clientInfo) : {\n    driver: {\n      name: \"nodejs-core\",\n      version: driverVersion\n    },\n    os: {\n      type: type,\n      name: name,\n      architecture: architecture,\n      version: release\n    } // Is platform specified\n\n  };\n\n  if (clientInfo.platform && clientInfo.platform.indexOf('mongodb-core') == -1) {\n    clientInfo.platform = f('%s, mongodb-core: %s', clientInfo.platform, driverVersion);\n  } else if (!clientInfo.platform) {\n    clientInfo.platform = nodejsversion;\n  } // Do we have an application specific string\n\n\n  if (options.appname) {\n    // Cut at 128 bytes\n    var buffer = new Buffer(options.appname); // Return the truncated appname\n\n    var appname = buffer.length > 128 ? buffer.slice(0, 128).toString('utf8') : options.appname; // Add to the clientInfo\n\n    clientInfo.application = {\n      name: appname\n    };\n  }\n\n  return clientInfo;\n}\n\nfunction clone(object) {\n  return JSON.parse(JSON.stringify(object));\n}\n\nvar getPreviousDescription = function (self) {\n  if (!self.s.serverDescription) {\n    self.s.serverDescription = {\n      address: self.name,\n      arbiters: [],\n      hosts: [],\n      passives: [],\n      type: 'Unknown'\n    };\n  }\n\n  return self.s.serverDescription;\n};\n\nvar emitServerDescriptionChanged = function (self, description) {\n  if (self.listeners('serverDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('serverDescriptionChanged', {\n      topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.id,\n      address: self.name,\n      previousDescription: getPreviousDescription(self),\n      newDescription: description\n    });\n    self.s.serverDescription = description;\n  }\n};\n\nvar getPreviousTopologyDescription = function (self) {\n  if (!self.s.topologyDescription) {\n    self.s.topologyDescription = {\n      topologyType: 'Unknown',\n      servers: [{\n        address: self.name,\n        arbiters: [],\n        hosts: [],\n        passives: [],\n        type: 'Unknown'\n      }]\n    };\n  }\n\n  return self.s.topologyDescription;\n};\n\nvar emitTopologyDescriptionChanged = function (self, description) {\n  if (self.listeners('topologyDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('topologyDescriptionChanged', {\n      topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.id,\n      address: self.name,\n      previousDescription: getPreviousTopologyDescription(self),\n      newDescription: description\n    });\n    self.s.serverDescription = description;\n  }\n};\n\nvar changedIsMaster = function (self, currentIsmaster, ismaster) {\n  var currentType = getTopologyType(self, currentIsmaster);\n  var newType = getTopologyType(self, ismaster);\n  if (newType != currentType) return true;\n  return false;\n};\n\nvar getTopologyType = function (self, ismaster) {\n  if (!ismaster) {\n    ismaster = self.ismaster;\n  }\n\n  if (!ismaster) return 'Unknown';\n  if (ismaster.ismaster && ismaster.msg == 'isdbgrid') return 'Mongos';\n  if (ismaster.ismaster && !ismaster.hosts) return 'Standalone';\n  if (ismaster.ismaster) return 'RSPrimary';\n  if (ismaster.secondary) return 'RSSecondary';\n  if (ismaster.arbiterOnly) return 'RSArbiter';\n  return 'Unknown';\n};\n\nvar inquireServerState = function (self) {\n  return function (callback) {\n    if (self.s.state == 'destroyed') return; // Record response time\n\n    var start = new Date().getTime(); // emitSDAMEvent\n\n    emitSDAMEvent(self, 'serverHeartbeatStarted', {\n      connectionId: self.name\n    }); // Attempt to execute ismaster command\n\n    self.command('admin.$cmd', {\n      ismaster: true\n    }, {\n      monitoring: true\n    }, function (err, r) {\n      if (!err) {\n        // Legacy event sender\n        self.emit('ismaster', r, self); // Calculate latencyMS\n\n        var latencyMS = new Date().getTime() - start; // Server heart beat event\n\n        emitSDAMEvent(self, 'serverHeartbeatSucceeded', {\n          durationMS: latencyMS,\n          reply: r.result,\n          connectionId: self.name\n        }); // Did the server change\n\n        if (changedIsMaster(self, self.s.ismaster, r.result)) {\n          // Emit server description changed if something listening\n          emitServerDescriptionChanged(self, {\n            address: self.name,\n            arbiters: [],\n            hosts: [],\n            passives: [],\n            type: !self.s.inTopology ? 'Standalone' : getTopologyType(self)\n          });\n        } // Updat ismaster view\n\n\n        self.s.ismaster = r.result; // Set server response time\n\n        self.s.isMasterLatencyMS = latencyMS;\n      } else {\n        emitSDAMEvent(self, 'serverHeartbeatFailed', {\n          durationMS: latencyMS,\n          failure: err,\n          connectionId: self.name\n        });\n      } // Peforming an ismaster monitoring callback operation\n\n\n      if (typeof callback == 'function') {\n        return callback(err, r);\n      } // Perform another sweep\n\n\n      self.s.inquireServerStateTimeout = setTimeout(inquireServerState(self), self.s.haInterval);\n    });\n  };\n}; //\n// Clone the options\n\n\nvar cloneOptions = function (options) {\n  var opts = {};\n\n  for (var name in options) {\n    opts[name] = options[name];\n  }\n\n  return opts;\n};\n\nfunction Interval(fn, time) {\n  var timer = false;\n\n  this.start = function () {\n    if (!this.isRunning()) {\n      timer = setInterval(fn, time);\n    }\n\n    return this;\n  };\n\n  this.stop = function () {\n    clearInterval(timer);\n    timer = false;\n    return this;\n  };\n\n  this.isRunning = function () {\n    return timer !== false;\n  };\n}\n\nfunction Timeout(fn, time) {\n  var timer = false;\n\n  this.start = function () {\n    if (!this.isRunning()) {\n      timer = setTimeout(function () {\n        fn();\n\n        if (timer && timer._called === undefined) {\n          // The artificial _called is set here for compatibility with node.js 0.10.x/0.12.x versions\n          timer._called = true;\n        }\n      }, time);\n    }\n\n    return this;\n  };\n\n  this.stop = function () {\n    clearTimeout(timer);\n    timer = false;\n    return this;\n  };\n\n  this.isRunning = function () {\n    if (timer && timer._called) return false;\n    return timer !== false;\n  };\n}\n\nfunction diff(previous, current) {\n  // Difference document\n  var diff = {\n    servers: [] // Previous entry\n\n  };\n\n  if (!previous) {\n    previous = {\n      servers: []\n    };\n  } // Check if we have any previous servers missing in the current ones\n\n\n  for (var i = 0; i < previous.servers.length; i++) {\n    var found = false;\n\n    for (var j = 0; j < current.servers.length; j++) {\n      if (current.servers[j].address.toLowerCase() === previous.servers[i].address.toLowerCase()) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      // Add to the diff\n      diff.servers.push({\n        address: previous.servers[i].address,\n        from: previous.servers[i].type,\n        to: 'Unknown'\n      });\n    }\n  } // Check if there are any severs that don't exist\n\n\n  for (var j = 0; j < current.servers.length; j++) {\n    var found = false; // Go over all the previous servers\n\n    for (var i = 0; i < previous.servers.length; i++) {\n      if (previous.servers[i].address.toLowerCase() === current.servers[j].address.toLowerCase()) {\n        found = true;\n        break;\n      }\n    } // Add the server to the diff\n\n\n    if (!found) {\n      diff.servers.push({\n        address: current.servers[j].address,\n        from: 'Unknown',\n        to: current.servers[j].type\n      });\n    }\n  } // Got through all the servers\n\n\n  for (var i = 0; i < previous.servers.length; i++) {\n    var prevServer = previous.servers[i]; // Go through all current servers\n\n    for (var j = 0; j < current.servers.length; j++) {\n      var currServer = current.servers[j]; // Matching server\n\n      if (prevServer.address.toLowerCase() === currServer.address.toLowerCase()) {\n        // We had a change in state\n        if (prevServer.type != currServer.type) {\n          diff.servers.push({\n            address: prevServer.address,\n            from: prevServer.type,\n            to: currServer.type\n          });\n        }\n      }\n    }\n  } // Return difference\n\n\n  return diff;\n}\n\nmodule.exports.inquireServerState = inquireServerState;\nmodule.exports.getTopologyType = getTopologyType;\nmodule.exports.emitServerDescriptionChanged = emitServerDescriptionChanged;\nmodule.exports.emitTopologyDescriptionChanged = emitTopologyDescriptionChanged;\nmodule.exports.cloneOptions = cloneOptions;\nmodule.exports.createClientInfo = createClientInfo;\nmodule.exports.clone = clone;\nmodule.exports.diff = diff;\nmodule.exports.Interval = Interval;\nmodule.exports.Timeout = Timeout;","map":null,"metadata":{},"sourceType":"script"}