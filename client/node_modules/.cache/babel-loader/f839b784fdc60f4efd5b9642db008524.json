{"ast":null,"code":"\"use strict\";\n\nvar EventEmitter = require('events').EventEmitter,\n    inherits = require('util').inherits,\n    f = require('util').format,\n    ServerCapabilities = require('./topology_base').ServerCapabilities,\n    MongoError = require('mongodb-core').MongoError,\n    CMongos = require('mongodb-core').Mongos,\n    Cursor = require('./cursor'),\n    AggregationCursor = require('./aggregation_cursor'),\n    CommandCursor = require('./command_cursor'),\n    Define = require('./metadata'),\n    Server = require('./server'),\n    Store = require('./topology_base').Store,\n    MAX_JS_INT = require('./utils').MAX_JS_INT,\n    translateOptions = require('./utils').translateOptions,\n    filterOptions = require('./utils').filterOptions,\n    mergeOptions = require('./utils').mergeOptions,\n    getReadPreference = require('./utils').getReadPreference,\n    os = require('os'); // Get package.json variable\n\n\nvar driverVersion = require('../package.json').version;\n\nvar nodejsversion = f('Node.js %s, %s', process.version, os.endianness());\nvar type = os.type();\nvar name = process.platform;\nvar architecture = process.arch;\nvar release = os.release();\n/**\n * @fileOverview The **Mongos** class is a class that represents a Mongos Proxy topology and is\n * used to construct connections.\n *\n * **Mongos Should not be used, use MongoClient.connect**\n * @example\n * var Db = require('mongodb').Db,\n *   Mongos = require('mongodb').Mongos,\n *   Server = require('mongodb').Server,\n *   test = require('assert');\n * // Connect using Mongos\n * var server = new Server('localhost', 27017);\n * var db = new Db('test', new Mongos([server]));\n * db.open(function(err, db) {\n *   // Get an additional db\n *   db.close();\n * });\n */\n// Allowed parameters\n\nvar legalOptionNames = ['ha', 'haInterval', 'acceptableLatencyMS', 'poolSize', 'ssl', 'checkServerIdentity', 'sslValidate', 'ciphers', 'ecdhCurve', 'sslCA', 'sslCRL', 'sslCert', 'sslKey', 'sslPass', 'socketOptions', 'bufferMaxEntries', 'store', 'auto_reconnect', 'autoReconnect', 'emitError', 'keepAlive', 'noDelay', 'connectTimeoutMS', 'socketTimeoutMS', 'loggerLevel', 'logger', 'reconnectTries', 'appname', 'domainsEnabled', 'servername', 'promoteLongs', 'promoteValues', 'promoteBuffers'];\n/**\n * Creates a new Mongos instance\n * @class\n * @deprecated\n * @param {Server[]} servers A seedlist of servers participating in the replicaset.\n * @param {object} [options=null] Optional settings.\n * @param {booelan} [options.ha=true] Turn on high availability monitoring.\n * @param {number} [options.haInterval=5000] Time between each replicaset status check.\n * @param {number} [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.\n * @param {number} [options.acceptableLatencyMS=15] Cutoff latency point in MS for MongoS proxy selection\n * @param {boolean} [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support)\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {object} [options.sslValidate=true] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {array} [options.sslCA=null] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {array} [options.sslCRL=null] Array of revocation certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {(Buffer|string)} [options.sslCert=null] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {(Buffer|string)} [options.sslKey=null] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {(Buffer|string)} [options.sslPass=null] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.\n * @param {object} [options.socketOptions=null] Socket options\n * @param {boolean} [options.socketOptions.noDelay=true] TCP Socket NoDelay option.\n * @param {number} [options.socketOptions.keepAlive=0] TCP KeepAlive on the socket with a X ms delay before start.\n * @param {number} [options.socketOptions.connectTimeoutMS=0] TCP Connection timeout setting\n * @param {number} [options.socketOptions.socketTimeoutMS=0] TCP Socket timeout setting\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @fires Mongos#connect\n * @fires Mongos#ha\n * @fires Mongos#joined\n * @fires Mongos#left\n * @fires Mongos#fullsetup\n * @fires Mongos#open\n * @fires Mongos#close\n * @fires Mongos#error\n * @fires Mongos#timeout\n * @fires Mongos#parseError\n * @property {string} parserType the parser type used (c++ or js).\n * @return {Mongos} a Mongos instance.\n */\n\nvar Mongos = function (servers, options) {\n  if (!(this instanceof Mongos)) return new Mongos(servers, options);\n  options = options || {};\n  var self = this; // Filter the options\n\n  options = filterOptions(options, legalOptionNames); // Ensure all the instances are Server\n\n  for (var i = 0; i < servers.length; i++) {\n    if (!(servers[i] instanceof Server)) {\n      throw MongoError.create({\n        message: \"all seed list instances must be of the Server type\",\n        driver: true\n      });\n    }\n  } // Stored options\n\n\n  var storeOptions = {\n    force: false,\n    bufferMaxEntries: typeof options.bufferMaxEntries == 'number' ? options.bufferMaxEntries : MAX_JS_INT // Shared global store\n\n  };\n  var store = options.store || new Store(self, storeOptions); // Set up event emitter\n\n  EventEmitter.call(this); // Build seed list\n\n  var seedlist = servers.map(function (x) {\n    return {\n      host: x.host,\n      port: x.port\n    };\n  }); // Get the reconnect option\n\n  var reconnect = typeof options.auto_reconnect == 'boolean' ? options.auto_reconnect : true;\n  reconnect = typeof options.autoReconnect == 'boolean' ? options.autoReconnect : reconnect; // Clone options\n\n  var clonedOptions = mergeOptions({}, {\n    disconnectHandler: store,\n    cursorFactory: Cursor,\n    reconnect: reconnect,\n    emitError: typeof options.emitError == 'boolean' ? options.emitError : true,\n    size: typeof options.poolSize == 'number' ? options.poolSize : 5\n  }); // Translate any SSL options and other connectivity options\n\n  clonedOptions = translateOptions(clonedOptions, options); // Socket options\n\n  var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options; // Translate all the options to the mongodb-core ones\n\n  clonedOptions = translateOptions(clonedOptions, socketOptions);\n\n  if (typeof clonedOptions.keepAlive == 'number') {\n    clonedOptions.keepAliveInitialDelay = clonedOptions.keepAlive;\n    clonedOptions.keepAlive = clonedOptions.keepAlive > 0;\n  } // Build default client information\n\n\n  this.clientInfo = {\n    driver: {\n      name: \"nodejs\",\n      version: driverVersion\n    },\n    os: {\n      type: type,\n      name: name,\n      architecture: architecture,\n      version: release\n    },\n    platform: nodejsversion // Build default client information\n\n  };\n  clonedOptions.clientInfo = this.clientInfo; // Do we have an application specific string\n\n  if (options.appname) {\n    clonedOptions.clientInfo.application = {\n      name: options.appname\n    };\n  } // Create the Mongos\n\n\n  var mongos = new CMongos(seedlist, clonedOptions); // Server capabilities\n\n  var sCapabilities = null; // Internal state\n\n  this.s = {\n    // Create the Mongos\n    mongos: mongos // Server capabilities\n    ,\n    sCapabilities: sCapabilities // Debug turned on\n    ,\n    debug: clonedOptions.debug // Store option defaults\n    ,\n    storeOptions: storeOptions // Cloned options\n    ,\n    clonedOptions: clonedOptions // Actual store of callbacks\n    ,\n    store: store // Options\n    ,\n    options: options\n  };\n};\n\nvar define = Mongos.define = new Define('Mongos', Mongos, false);\n/**\n * @ignore\n */\n\ninherits(Mongos, EventEmitter); // Last ismaster\n\nObject.defineProperty(Mongos.prototype, 'isMasterDoc', {\n  enumerable: true,\n  get: function () {\n    return this.s.mongos.lastIsMaster();\n  }\n});\nObject.defineProperty(Mongos.prototype, 'parserType', {\n  enumerable: true,\n  get: function () {\n    return this.s.mongos.parserType;\n  }\n}); // BSON property\n\nObject.defineProperty(Mongos.prototype, 'bson', {\n  enumerable: true,\n  get: function () {\n    return this.s.mongos.s.bson;\n  }\n});\nObject.defineProperty(Mongos.prototype, 'haInterval', {\n  enumerable: true,\n  get: function () {\n    return this.s.mongos.s.haInterval;\n  }\n}); // Connect\n\nMongos.prototype.connect = function (db, _options, callback) {\n  var self = this;\n  if ('function' === typeof _options) callback = _options, _options = {};\n  if (_options == null) _options = {};\n  if (!('function' === typeof callback)) callback = null;\n  self.s.options = _options; // Update bufferMaxEntries\n\n  self.s.storeOptions.bufferMaxEntries = db.bufferMaxEntries; // Error handler\n\n  var connectErrorHandler = function () {\n    return function (err) {\n      // Remove all event handlers\n      var events = ['timeout', 'error', 'close'];\n      events.forEach(function (e) {\n        self.removeListener(e, connectErrorHandler);\n      });\n      self.s.mongos.removeListener('connect', connectErrorHandler); // Try to callback\n\n      try {\n        callback(err);\n      } catch (err) {\n        process.nextTick(function () {\n          throw err;\n        });\n      }\n    };\n  }; // Actual handler\n\n\n  var errorHandler = function (event) {\n    return function (err) {\n      if (event != 'error') {\n        self.emit(event, err);\n      }\n    };\n  }; // Error handler\n\n\n  var reconnectHandler = function () {\n    self.emit('reconnect');\n    self.s.store.execute();\n  }; // relay the event\n\n\n  var relay = function (event) {\n    return function (t, server) {\n      self.emit(event, t, server);\n    };\n  }; // Connect handler\n\n\n  var connectHandler = function () {\n    // Clear out all the current handlers left over\n    var events = [\"timeout\", \"error\", \"close\", 'fullsetup'];\n    events.forEach(function (e) {\n      self.s.mongos.removeAllListeners(e);\n    }); // Set up listeners\n\n    self.s.mongos.once('timeout', errorHandler('timeout'));\n    self.s.mongos.once('error', errorHandler('error'));\n    self.s.mongos.once('close', errorHandler('close')); // Set up serverConfig listeners\n\n    self.s.mongos.on('fullsetup', function () {\n      self.emit('fullsetup', self);\n    }); // Emit open event\n\n    self.emit('open', null, self); // Return correctly\n\n    try {\n      callback(null, self);\n    } catch (err) {\n      process.nextTick(function () {\n        throw err;\n      });\n    }\n  }; // Clear out all the current handlers left over\n\n\n  var events = [\"timeout\", \"error\", \"close\", 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening', 'topologyClosed', 'topologyDescriptionChanged'];\n  events.forEach(function (e) {\n    self.s.mongos.removeAllListeners(e);\n  }); // Set up SDAM listeners\n\n  self.s.mongos.on('serverDescriptionChanged', relay('serverDescriptionChanged'));\n  self.s.mongos.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));\n  self.s.mongos.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));\n  self.s.mongos.on('serverHeartbeatFailed', relay('serverHeartbeatFailed'));\n  self.s.mongos.on('serverOpening', relay('serverOpening'));\n  self.s.mongos.on('serverClosed', relay('serverClosed'));\n  self.s.mongos.on('topologyOpening', relay('topologyOpening'));\n  self.s.mongos.on('topologyClosed', relay('topologyClosed'));\n  self.s.mongos.on('topologyDescriptionChanged', relay('topologyDescriptionChanged')); // Set up listeners\n\n  self.s.mongos.once('timeout', connectErrorHandler('timeout'));\n  self.s.mongos.once('error', connectErrorHandler('error'));\n  self.s.mongos.once('close', connectErrorHandler('close'));\n  self.s.mongos.once('connect', connectHandler); // Join and leave events\n\n  self.s.mongos.on('joined', relay('joined'));\n  self.s.mongos.on('left', relay('left')); // Reconnect server\n\n  self.s.mongos.on('reconnect', reconnectHandler); // Start connection\n\n  self.s.mongos.connect(_options);\n}; // Server capabilities\n\n\nMongos.prototype.capabilities = function () {\n  if (this.s.sCapabilities) return this.s.sCapabilities;\n  if (this.s.mongos.lastIsMaster() == null) return null;\n  this.s.sCapabilities = new ServerCapabilities(this.s.mongos.lastIsMaster());\n  return this.s.sCapabilities;\n};\n\ndefine.classMethod('capabilities', {\n  callback: false,\n  promise: false,\n  returns: [ServerCapabilities]\n}); // Command\n\nMongos.prototype.command = function (ns, cmd, options, callback) {\n  this.s.mongos.command(ns, cmd, getReadPreference(options), callback);\n};\n\ndefine.classMethod('command', {\n  callback: true,\n  promise: false\n}); // Insert\n\nMongos.prototype.insert = function (ns, ops, options, callback) {\n  this.s.mongos.insert(ns, ops, options, function (e, m) {\n    callback(e, m);\n  });\n};\n\ndefine.classMethod('insert', {\n  callback: true,\n  promise: false\n}); // Update\n\nMongos.prototype.update = function (ns, ops, options, callback) {\n  this.s.mongos.update(ns, ops, options, callback);\n};\n\ndefine.classMethod('update', {\n  callback: true,\n  promise: false\n}); // Remove\n\nMongos.prototype.remove = function (ns, ops, options, callback) {\n  this.s.mongos.remove(ns, ops, options, callback);\n};\n\ndefine.classMethod('remove', {\n  callback: true,\n  promise: false\n}); // Destroyed\n\nMongos.prototype.isDestroyed = function () {\n  return this.s.mongos.isDestroyed();\n}; // IsConnected\n\n\nMongos.prototype.isConnected = function () {\n  return this.s.mongos.isConnected();\n};\n\ndefine.classMethod('isConnected', {\n  callback: false,\n  promise: false,\n  returns: [Boolean]\n}); // Insert\n\nMongos.prototype.cursor = function (ns, cmd, options) {\n  options.disconnectHandler = this.s.store;\n  return this.s.mongos.cursor(ns, cmd, options);\n};\n\ndefine.classMethod('cursor', {\n  callback: false,\n  promise: false,\n  returns: [Cursor, AggregationCursor, CommandCursor]\n});\n\nMongos.prototype.lastIsMaster = function () {\n  return this.s.mongos.lastIsMaster();\n};\n/**\n * Unref all sockets\n * @method\n */\n\n\nMongos.prototype.unref = function () {\n  return this.s.mongos.unref();\n};\n\nMongos.prototype.close = function (forceClosed) {\n  this.s.mongos.destroy({\n    force: typeof forceClosed == 'boolean' ? forceClosed : false\n  }); // We need to wash out all stored processes\n\n  if (forceClosed == true) {\n    this.s.storeOptions.force = forceClosed;\n    this.s.store.flush();\n  }\n};\n\ndefine.classMethod('close', {\n  callback: false,\n  promise: false\n});\n\nMongos.prototype.auth = function () {\n  var args = Array.prototype.slice.call(arguments, 0);\n  this.s.mongos.auth.apply(this.s.mongos, args);\n};\n\ndefine.classMethod('auth', {\n  callback: true,\n  promise: false\n});\n\nMongos.prototype.logout = function () {\n  var args = Array.prototype.slice.call(arguments, 0);\n  this.s.mongos.logout.apply(this.s.mongos, args);\n};\n\ndefine.classMethod('logout', {\n  callback: true,\n  promise: false\n});\n/**\n * All raw connections\n * @method\n * @return {array}\n */\n\nMongos.prototype.connections = function () {\n  return this.s.mongos.connections();\n};\n\ndefine.classMethod('connections', {\n  callback: false,\n  promise: false,\n  returns: [Array]\n});\n/**\n * A mongos connect event, used to verify that the connection is up and running\n *\n * @event Mongos#connect\n * @type {Mongos}\n */\n\n/**\n * The mongos high availability event\n *\n * @event Mongos#ha\n * @type {function}\n * @param {string} type The stage in the high availability event (start|end)\n * @param {boolean} data.norepeat This is a repeating high availability process or a single execution only\n * @param {number} data.id The id for this high availability request\n * @param {object} data.state An object containing the information about the current replicaset\n */\n\n/**\n * A server member left the mongos set\n *\n * @event Mongos#left\n * @type {function}\n * @param {string} type The type of member that left (primary|secondary|arbiter)\n * @param {Server} server The server object that left\n */\n\n/**\n * A server member joined the mongos set\n *\n * @event Mongos#joined\n * @type {function}\n * @param {string} type The type of member that joined (primary|secondary|arbiter)\n * @param {Server} server The server object that joined\n */\n\n/**\n * Mongos fullsetup event, emitted when all proxies in the topology have been connected to.\n *\n * @event Mongos#fullsetup\n * @type {Mongos}\n */\n\n/**\n * Mongos open event, emitted when mongos can start processing commands.\n *\n * @event Mongos#open\n * @type {Mongos}\n */\n\n/**\n * Mongos close event\n *\n * @event Mongos#close\n * @type {object}\n */\n\n/**\n * Mongos error event, emitted if there is an error listener.\n *\n * @event Mongos#error\n * @type {MongoError}\n */\n\n/**\n * Mongos timeout event\n *\n * @event Mongos#timeout\n * @type {object}\n */\n\n/**\n * Mongos parseError event\n *\n * @event Mongos#parseError\n * @type {object}\n */\n\nmodule.exports = Mongos;","map":null,"metadata":{},"sourceType":"script"}