{"ast":null,"code":"\"use strict\";\n\nvar MongoError = require('mongodb-core').MongoError,\n    ReadPreference = require('./read_preference'),\n    CoreReadPreference = require('mongodb-core').ReadPreference;\n\nvar shallowClone = function (obj) {\n  var copy = {};\n\n  for (var name in obj) copy[name] = obj[name];\n\n  return copy;\n}; // Figure out the read preference\n\n\nvar getReadPreference = function (options) {\n  var r = null;\n\n  if (options.readPreference) {\n    r = options.readPreference;\n  } else {\n    return options;\n  }\n\n  if (r instanceof ReadPreference) {\n    options.readPreference = new CoreReadPreference(r.mode, r.tags, {\n      maxStalenessSeconds: r.maxStalenessSeconds\n    });\n  } else if (typeof r == 'string') {\n    options.readPreference = new CoreReadPreference(r);\n  } else if (r && !(r instanceof ReadPreference) && typeof r == 'object') {\n    var mode = r.mode || r.preference;\n\n    if (mode && typeof mode == 'string') {\n      options.readPreference = new CoreReadPreference(mode, r.tags, {\n        maxStalenessSeconds: r.maxStalenessSeconds\n      });\n    }\n  }\n\n  return options;\n}; // Set simple property\n\n\nvar getSingleProperty = function (obj, name, value) {\n  Object.defineProperty(obj, name, {\n    enumerable: true,\n    get: function () {\n      return value;\n    }\n  });\n};\n\nvar formatSortValue = exports.formatSortValue = function (sortDirection) {\n  var value = (\"\" + sortDirection).toLowerCase();\n\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n\n    default:\n      throw new Error(\"Illegal sort clause, must be of the form \" + \"[['field1', '(ascending|descending)'], \" + \"['field2', '(ascending|descending)']]\");\n  }\n};\n\nvar formattedOrderClause = exports.formattedOrderClause = function (sortValue) {\n  var orderBy = {};\n  if (sortValue == null) return null;\n\n  if (Array.isArray(sortValue)) {\n    if (sortValue.length === 0) {\n      return null;\n    }\n\n    for (var i = 0; i < sortValue.length; i++) {\n      if (sortValue[i].constructor == String) {\n        orderBy[sortValue[i]] = 1;\n      } else {\n        orderBy[sortValue[i][0]] = formatSortValue(sortValue[i][1]);\n      }\n    }\n  } else if (sortValue != null && typeof sortValue == 'object') {\n    orderBy = sortValue;\n  } else if (typeof sortValue == 'string') {\n    orderBy[sortValue] = 1;\n  } else {\n    throw new Error(\"Illegal sort clause, must be of the form \" + \"[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]\");\n  }\n\n  return orderBy;\n};\n\nvar checkCollectionName = function checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new MongoError(\"collection name must be a String\");\n  }\n\n  if (!collectionName || collectionName.indexOf('..') != -1) {\n    throw new MongoError(\"collection names cannot be empty\");\n  }\n\n  if (collectionName.indexOf('$') != -1 && collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n    throw new MongoError(\"collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    throw new MongoError(\"collection names must not start or end with '.'\");\n  } // Validate that we are not passing 0x00 in the collection name\n\n\n  if (!!~collectionName.indexOf(\"\\x00\")) {\n    throw new MongoError(\"collection names cannot contain a null character\");\n  }\n};\n\nvar handleCallback = function (callback, err, value1, value2) {\n  try {\n    if (callback == null) return;\n\n    if (callback) {\n      return value2 ? callback(err, value1, value2) : callback(err, value1);\n    }\n  } catch (err) {\n    process.nextTick(function () {\n      throw err;\n    });\n    return false;\n  }\n\n  return true;\n};\n/**\n * Wrap a Mongo error document in an Error instance\n * @ignore\n * @api private\n */\n\n\nvar toError = function (error) {\n  if (error instanceof Error) return error;\n  var msg = error.err || error.errmsg || error.errMessage || error;\n  var e = MongoError.create({\n    message: msg,\n    driver: true\n  }); // Get all object keys\n\n  var keys = typeof error == 'object' ? Object.keys(error) : [];\n\n  for (var i = 0; i < keys.length; i++) {\n    try {\n      e[keys[i]] = error[keys[i]];\n    } catch (err) {// continue\n    }\n  }\n\n  return e;\n};\n/**\n * @ignore\n */\n\n\nvar normalizeHintField = function normalizeHintField(hint) {\n  var finalHint = null;\n\n  if (typeof hint == 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n    hint.forEach(function (param) {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint == 'object') {\n    finalHint = {};\n\n    for (var name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n};\n/**\n * Create index name based on field spec\n *\n * @ignore\n * @api private\n */\n\n\nvar parseIndexOptions = function (fieldOrSpec) {\n  var fieldHash = {};\n  var indexes = [];\n  var keys; // Get all the fields accordingly\n\n  if ('string' == typeof fieldOrSpec) {\n    // 'type'\n    indexes.push(fieldOrSpec + '_' + 1);\n    fieldHash[fieldOrSpec] = 1;\n  } else if (Array.isArray(fieldOrSpec)) {\n    fieldOrSpec.forEach(function (f) {\n      if ('string' == typeof f) {\n        // [{location:'2d'}, 'type']\n        indexes.push(f + '_' + 1);\n        fieldHash[f] = 1;\n      } else if (Array.isArray(f)) {\n        // [['location', '2d'],['type', 1]]\n        indexes.push(f[0] + '_' + (f[1] || 1));\n        fieldHash[f[0]] = f[1] || 1;\n      } else if (isObject(f)) {\n        // [{location:'2d'}, {type:1}]\n        keys = Object.keys(f);\n        keys.forEach(function (k) {\n          indexes.push(k + '_' + f[k]);\n          fieldHash[k] = f[k];\n        });\n      } else {// undefined (ignore)\n      }\n    });\n  } else if (isObject(fieldOrSpec)) {\n    // {location:'2d', type:1}\n    keys = Object.keys(fieldOrSpec);\n    keys.forEach(function (key) {\n      indexes.push(key + '_' + fieldOrSpec[key]);\n      fieldHash[key] = fieldOrSpec[key];\n    });\n  }\n\n  return {\n    name: indexes.join(\"_\"),\n    keys: keys,\n    fieldHash: fieldHash\n  };\n};\n\nvar isObject = exports.isObject = function (arg) {\n  return '[object Object]' == Object.prototype.toString.call(arg);\n};\n\nvar debugOptions = function (debugFields, options) {\n  var finaloptions = {};\n  debugFields.forEach(function (n) {\n    finaloptions[n] = options[n];\n  });\n  return finaloptions;\n};\n\nvar decorateCommand = function (command, options, exclude) {\n  for (var name in options) {\n    if (exclude[name] == null) command[name] = options[name];\n  }\n\n  return command;\n};\n\nvar mergeOptions = function (target, source) {\n  for (var name in source) {\n    target[name] = source[name];\n  }\n\n  return target;\n}; // Merge options with translation\n\n\nvar translateOptions = function (target, source) {\n  var translations = {\n    // SSL translation options\n    'sslCA': 'ca',\n    'sslCRL': 'crl',\n    'sslValidate': 'rejectUnauthorized',\n    'sslKey': 'key',\n    'sslCert': 'cert',\n    'sslPass': 'passphrase',\n    // SocketTimeout translation options\n    'socketTimeoutMS': 'socketTimeout',\n    'connectTimeoutMS': 'connectionTimeout',\n    // Replicaset options\n    'replicaSet': 'setName',\n    'rs_name': 'setName',\n    'secondaryAcceptableLatencyMS': 'acceptableLatency',\n    'connectWithNoPrimary': 'secondaryOnlyConnectionAllowed',\n    // Mongos options\n    'acceptableLatencyMS': 'localThresholdMS'\n  };\n\n  for (var name in source) {\n    if (translations[name]) {\n      target[translations[name]] = source[name];\n    } else {\n      target[name] = source[name];\n    }\n  }\n\n  return target;\n};\n\nvar filterOptions = function (options, names) {\n  var filterOptions = {};\n\n  for (var name in options) {\n    if (names.indexOf(name) != -1) filterOptions[name] = options[name];\n  } // Filtered options\n\n\n  return filterOptions;\n}; // Object.assign method or polyfill\n\n\nvar assign = Object.assign ? Object.assign : function assign(target) {\n  if (target === undefined || target === null) {\n    throw new TypeError('Cannot convert first argument to object');\n  }\n\n  var to = Object(target);\n\n  for (var i = 1; i < arguments.length; i++) {\n    var nextSource = arguments[i];\n\n    if (nextSource === undefined || nextSource === null) {\n      continue;\n    }\n\n    var keysArray = Object.keys(Object(nextSource));\n\n    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\n      var nextKey = keysArray[nextIndex];\n      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n\n      if (desc !== undefined && desc.enumerable) {\n        to[nextKey] = nextSource[nextKey];\n      }\n    }\n  }\n\n  return to;\n}; // Write concern keys\n\nvar writeConcernKeys = ['w', 'j', 'wtimeout', 'fsync']; // Merge the write concern options\n\nvar mergeOptionsAndWriteConcern = function (targetOptions, sourceOptions, keys, mergeWriteConcern) {\n  // Mix in any allowed options\n  for (var i = 0; i < keys.length; i++) {\n    if (!targetOptions[keys[i]] && sourceOptions[keys[i]] != undefined) {\n      targetOptions[keys[i]] = sourceOptions[keys[i]];\n    }\n  } // No merging of write concern\n\n\n  if (!mergeWriteConcern) return targetOptions; // Found no write Concern options\n\n  var found = false;\n\n  for (var i = 0; i < writeConcernKeys.length; i++) {\n    if (targetOptions[writeConcernKeys[i]]) {\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) {\n    for (var i = 0; i < writeConcernKeys.length; i++) {\n      if (sourceOptions[writeConcernKeys[i]]) {\n        targetOptions[writeConcernKeys[i]] = sourceOptions[writeConcernKeys[i]];\n      }\n    }\n  }\n\n  return targetOptions;\n};\n\nexports.filterOptions = filterOptions;\nexports.mergeOptions = mergeOptions;\nexports.translateOptions = translateOptions;\nexports.shallowClone = shallowClone;\nexports.getSingleProperty = getSingleProperty;\nexports.checkCollectionName = checkCollectionName;\nexports.toError = toError;\nexports.formattedOrderClause = formattedOrderClause;\nexports.parseIndexOptions = parseIndexOptions;\nexports.normalizeHintField = normalizeHintField;\nexports.handleCallback = handleCallback;\nexports.decorateCommand = decorateCommand;\nexports.isObject = isObject;\nexports.debugOptions = debugOptions;\nexports.MAX_JS_INT = 0x20000000000000;\nexports.assign = assign;\nexports.mergeOptionsAndWriteConcern = mergeOptionsAndWriteConcern;\nexports.getReadPreference = getReadPreference;","map":null,"metadata":{},"sourceType":"script"}