{"ast":null,"code":"\"use strict\";\n\nvar checkCollectionName = require('./utils').checkCollectionName,\n    ObjectID = require('mongodb-core').BSON.ObjectID,\n    Long = require('mongodb-core').BSON.Long,\n    Code = require('mongodb-core').BSON.Code,\n    f = require('util').format,\n    AggregationCursor = require('./aggregation_cursor'),\n    MongoError = require('mongodb-core').MongoError,\n    shallowClone = require('./utils').shallowClone,\n    isObject = require('./utils').isObject,\n    toError = require('./utils').toError,\n    normalizeHintField = require('./utils').normalizeHintField,\n    handleCallback = require('./utils').handleCallback,\n    decorateCommand = require('./utils').decorateCommand,\n    formattedOrderClause = require('./utils').formattedOrderClause,\n    ReadPreference = require('./read_preference'),\n    CoreReadPreference = require('mongodb-core').ReadPreference,\n    CommandCursor = require('./command_cursor'),\n    Define = require('./metadata'),\n    Cursor = require('./cursor'),\n    unordered = require('./bulk/unordered'),\n    ordered = require('./bulk/ordered'),\n    assign = require('./utils').assign;\n/**\n * @fileOverview The **Collection** class is an internal class that embodies a MongoDB collection\n * allowing for insert/update/remove/find and other command operation on that MongoDB collection.\n *\n * **COLLECTION Cannot directly be instantiated**\n * @example\n * var MongoClient = require('mongodb').MongoClient,\n *   test = require('assert');\n * // Connection url\n * var url = 'mongodb://localhost:27017/test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, db) {\n *   // Create a collection we want to drop later\n *   var col = db.collection('createIndexExample1');\n *   // Show that duplicate records got dropped\n *   col.find({}).toArray(function(err, items) {\n *     test.equal(null, err);\n *     test.equal(4, items.length);\n *     db.close();\n *   });\n * });\n */\n\n\nvar mergeKeys = ['readPreference', 'ignoreUndefined'];\n/**\n * Create a new Collection instance (INTERNAL TYPE, do not instantiate directly)\n * @class\n * @property {string} collectionName Get the collection name.\n * @property {string} namespace Get the full collection namespace.\n * @property {object} writeConcern The current write concern values.\n * @property {object} readConcern The current read concern values.\n * @property {object} hint Get current index hint for collection.\n * @return {Collection} a Collection instance.\n */\n\nvar Collection = function (db, topology, dbName, name, pkFactory, options) {\n  checkCollectionName(name); // Unpack variables\n\n  var internalHint = null;\n  var slaveOk = options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk;\n  var serializeFunctions = options == null || options.serializeFunctions == null ? db.s.options.serializeFunctions : options.serializeFunctions;\n  var raw = options == null || options.raw == null ? db.s.options.raw : options.raw;\n  var promoteLongs = options == null || options.promoteLongs == null ? db.s.options.promoteLongs : options.promoteLongs;\n  var promoteValues = options == null || options.promoteValues == null ? db.s.options.promoteValues : options.promoteValues;\n  var promoteBuffers = options == null || options.promoteBuffers == null ? db.s.options.promoteBuffers : options.promoteBuffers;\n  var readPreference = null;\n  var collectionHint = null;\n  var namespace = f(\"%s.%s\", dbName, name); // Get the promiseLibrary\n\n  var promiseLibrary = options.promiseLibrary; // No promise library selected fall back\n\n  if (!promiseLibrary) {\n    promiseLibrary = typeof global.Promise == 'function' ? global.Promise : require('es6-promise').Promise;\n  } // Assign the right collection level readPreference\n\n\n  if (options && options.readPreference) {\n    readPreference = options.readPreference;\n  } else if (db.options.readPreference) {\n    readPreference = db.options.readPreference;\n  } // Set custom primary key factory if provided\n\n\n  pkFactory = pkFactory == null ? ObjectID : pkFactory; // Internal state\n\n  this.s = {\n    // Set custom primary key factory if provided\n    pkFactory: pkFactory // Db\n    ,\n    db: db // Topology\n    ,\n    topology: topology // dbName\n    ,\n    dbName: dbName // Options\n    ,\n    options: options // Namespace\n    ,\n    namespace: namespace // Read preference\n    ,\n    readPreference: readPreference // SlaveOK\n    ,\n    slaveOk: slaveOk // Serialize functions\n    ,\n    serializeFunctions: serializeFunctions // Raw\n    ,\n    raw: raw // promoteLongs\n    ,\n    promoteLongs: promoteLongs // promoteValues\n    ,\n    promoteValues: promoteValues // promoteBuffers\n    ,\n    promoteBuffers: promoteBuffers // internalHint\n    ,\n    internalHint: internalHint // collectionHint\n    ,\n    collectionHint: collectionHint // Name\n    ,\n    name: name // Promise library\n    ,\n    promiseLibrary: promiseLibrary // Read Concern\n    ,\n    readConcern: options.readConcern\n  };\n};\n\nvar define = Collection.define = new Define('Collection', Collection, false);\nObject.defineProperty(Collection.prototype, 'collectionName', {\n  enumerable: true,\n  get: function () {\n    return this.s.name;\n  }\n});\nObject.defineProperty(Collection.prototype, 'namespace', {\n  enumerable: true,\n  get: function () {\n    return this.s.namespace;\n  }\n});\nObject.defineProperty(Collection.prototype, 'readConcern', {\n  enumerable: true,\n  get: function () {\n    return this.s.readConcern || {\n      level: 'local'\n    };\n  }\n});\nObject.defineProperty(Collection.prototype, 'writeConcern', {\n  enumerable: true,\n  get: function () {\n    var ops = {};\n    if (this.s.options.w != null) ops.w = this.s.options.w;\n    if (this.s.options.j != null) ops.j = this.s.options.j;\n    if (this.s.options.fsync != null) ops.fsync = this.s.options.fsync;\n    if (this.s.options.wtimeout != null) ops.wtimeout = this.s.options.wtimeout;\n    return ops;\n  }\n});\n/**\n * @ignore\n */\n\nObject.defineProperty(Collection.prototype, \"hint\", {\n  enumerable: true,\n  get: function () {\n    return this.s.collectionHint;\n  },\n  set: function (v) {\n    this.s.collectionHint = normalizeHintField(v);\n  }\n});\n/**\n * Creates a cursor for a query that can be used to iterate over results from MongoDB\n * @method\n * @param {object} query The cursor query object.\n * @throws {MongoError}\n * @return {Cursor}\n */\n\nCollection.prototype.find = function () {\n  var options,\n      args = Array.prototype.slice.call(arguments, 0),\n      has_callback = typeof args[args.length - 1] === 'function',\n      has_weird_callback = typeof args[0] === 'function',\n      callback = has_callback ? args.pop() : has_weird_callback ? args.shift() : null,\n      len = args.length,\n      selector = len >= 1 ? args[0] : {},\n      fields = len >= 2 ? args[1] : undefined;\n\n  if (len === 1 && has_weird_callback) {\n    // backwards compat for callback?, options case\n    selector = {};\n    options = args[0];\n  }\n\n  if (len === 2 && fields !== undefined && !Array.isArray(fields)) {\n    var fieldKeys = Object.keys(fields);\n    var is_option = false;\n\n    for (var i = 0; i < fieldKeys.length; i++) {\n      if (testForFields[fieldKeys[i]] != null) {\n        is_option = true;\n        break;\n      }\n    }\n\n    if (is_option) {\n      options = fields;\n      fields = undefined;\n    } else {\n      options = {};\n    }\n  } else if (len === 2 && Array.isArray(fields) && !Array.isArray(fields[0])) {\n    var newFields = {}; // Rewrite the array\n\n    for (i = 0; i < fields.length; i++) {\n      newFields[fields[i]] = 1;\n    } // Set the fields\n\n\n    fields = newFields;\n  }\n\n  if (3 === len) {\n    options = args[2];\n  } // Ensure selector is not null\n\n\n  selector = selector == null ? {} : selector; // Validate correctness off the selector\n\n  var object = selector;\n\n  if (Buffer.isBuffer(object)) {\n    var object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;\n\n    if (object_size != object.length) {\n      var error = new Error(\"query selector raw message size does not match message header size [\" + object.length + \"] != [\" + object_size + \"]\");\n      error.name = 'MongoError';\n      throw error;\n    }\n  } // Validate correctness of the field selector\n\n\n  object = fields;\n\n  if (Buffer.isBuffer(object)) {\n    object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;\n\n    if (object_size != object.length) {\n      error = new Error(\"query fields raw message size does not match message header size [\" + object.length + \"] != [\" + object_size + \"]\");\n      error.name = 'MongoError';\n      throw error;\n    }\n  } // Check special case where we are using an objectId\n\n\n  if (selector != null && selector._bsontype == 'ObjectID') {\n    selector = {\n      _id: selector\n    };\n  } // If it's a serialized fields field we need to just let it through\n  // user be warned it better be good\n\n\n  if (options && options.fields && !Buffer.isBuffer(options.fields)) {\n    fields = {};\n\n    if (Array.isArray(options.fields)) {\n      if (!options.fields.length) {\n        fields['_id'] = 1;\n      } else {\n        var l = options.fields.length;\n\n        for (i = 0; i < l; i++) {\n          fields[options.fields[i]] = 1;\n        }\n      }\n    } else {\n      fields = options.fields;\n    }\n  }\n\n  if (!options) options = {};\n  var newOptions = {}; // Make a shallow copy of the collection options\n\n  for (var key in this.s.options) {\n    if (mergeKeys.indexOf(key) != -1) {\n      newOptions[key] = this.s.options[key];\n    }\n  } // Make a shallow copy of options\n\n\n  for (var key in options) {\n    newOptions[key] = options[key];\n  } // Unpack options\n\n\n  newOptions.skip = len > 3 ? args[2] : options.skip ? options.skip : 0;\n  newOptions.limit = len > 3 ? args[3] : options.limit ? options.limit : 0;\n  newOptions.raw = options.raw != null && typeof options.raw === 'boolean' ? options.raw : this.s.raw;\n  newOptions.hint = options.hint != null ? normalizeHintField(options.hint) : this.s.collectionHint;\n  newOptions.timeout = len == 5 ? args[4] : typeof options.timeout === 'undefined' ? undefined : options.timeout; // // If we have overridden slaveOk otherwise use the default db setting\n\n  newOptions.slaveOk = options.slaveOk != null ? options.slaveOk : this.s.db.slaveOk; // Add read preference if needed\n\n  newOptions = getReadPreference(this, newOptions, this.s.db, this); // Set slave ok to true if read preference different from primary\n\n  if (newOptions.readPreference != null && (newOptions.readPreference != 'primary' || newOptions.readPreference.mode != 'primary')) {\n    newOptions.slaveOk = true;\n  } // Ensure the query is an object\n\n\n  if (selector != null && typeof selector != 'object') {\n    throw MongoError.create({\n      message: \"query selector must be an object\",\n      driver: true\n    });\n  } // Build the find command\n\n\n  var findCommand = {\n    find: this.s.namespace,\n    limit: newOptions.limit,\n    skip: newOptions.skip,\n    query: selector // Ensure we use the right await data option\n\n  };\n\n  if (typeof newOptions.awaitdata == 'boolean') {\n    newOptions.awaitData = newOptions.awaitdata;\n  } // Translate to new command option noCursorTimeout\n\n\n  if (typeof newOptions.timeout == 'boolean') newOptions.noCursorTimeout = newOptions.timeout; // Merge in options to command\n\n  for (var name in newOptions) {\n    if (newOptions[name] != null) findCommand[name] = newOptions[name];\n  } // Format the fields\n\n\n  var formatFields = function (fields) {\n    var object = {};\n\n    if (Array.isArray(fields)) {\n      for (var i = 0; i < fields.length; i++) {\n        if (Array.isArray(fields[i])) {\n          object[fields[i][0]] = fields[i][1];\n        } else {\n          object[fields[i][0]] = 1;\n        }\n      }\n    } else {\n      object = fields;\n    }\n\n    return object;\n  }; // Special treatment for the fields selector\n\n\n  if (fields) findCommand.fields = formatFields(fields); // Add db object to the new options\n\n  newOptions.db = this.s.db; // Add the promise library\n\n  newOptions.promiseLibrary = this.s.promiseLibrary; // Set raw if available at collection level\n\n  if (newOptions.raw == null && typeof this.s.raw == 'boolean') newOptions.raw = this.s.raw; // Set promoteLongs if available at collection level\n\n  if (newOptions.promoteLongs == null && typeof this.s.promoteLongs == 'boolean') newOptions.promoteLongs = this.s.promoteLongs;\n  if (newOptions.promoteValues == null && typeof this.s.promoteValues == 'boolean') newOptions.promoteValues = this.s.promoteValues;\n  if (newOptions.promoteBuffers == null && typeof this.s.promoteBuffers == 'boolean') newOptions.promoteBuffers = this.s.promoteBuffers; // Sort options\n\n  if (findCommand.sort) {\n    findCommand.sort = formattedOrderClause(findCommand.sort);\n  } // Set the readConcern\n\n\n  if (this.s.readConcern) {\n    findCommand.readConcern = this.s.readConcern;\n  } // Decorate find command with collation options\n\n\n  decorateWithCollation(findCommand, this, options); // Create the cursor\n\n  if (typeof callback == 'function') return handleCallback(callback, null, this.s.topology.cursor(this.s.namespace, findCommand, newOptions));\n  return this.s.topology.cursor(this.s.namespace, findCommand, newOptions);\n};\n\ndefine.classMethod('find', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,\n * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n * can be overridden by setting the **forceServerObjectId** flag.\n *\n * @method\n * @param {object} doc Document to insert.\n * @param {object} [options=null] Optional settings.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {Collection~insertOneWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.insertOne = function (doc, options, callback) {\n  var self = this;\n  if (typeof options == 'function') callback = options, options = {};\n  options = options || {};\n\n  if (Array.isArray(doc) && typeof callback == 'function') {\n    return callback(MongoError.create({\n      message: 'doc parameter must be an object',\n      driver: true\n    }));\n  } else if (Array.isArray(doc)) {\n    return new this.s.promiseLibrary(function (resolve, reject) {\n      reject(MongoError.create({\n        message: 'doc parameter must be an object',\n        driver: true\n      }));\n    });\n  } // Add ignoreUndefined\n\n\n  if (this.s.options.ignoreUndefined) {\n    options = shallowClone(options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  } // Execute using callback\n\n\n  if (typeof callback == 'function') return insertOne(self, doc, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    insertOne(self, doc, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar insertOne = function (self, doc, options, callback) {\n  insertDocuments(self, [doc], options, function (err, r) {\n    if (callback == null) return;\n    if (err && callback) return callback(err); // Workaround for pre 2.6 servers\n\n    if (r == null) return callback(null, {\n      result: {\n        ok: 1\n      }\n    }); // Add values to top level to ensure crud spec compatibility\n\n    r.insertedCount = r.result.n;\n    r.insertedId = doc._id;\n    if (callback) callback(null, r);\n  });\n};\n\nvar mapInsertManyResults = function (docs, r) {\n  var ids = r.getInsertedIds();\n  var keys = Object.keys(ids);\n  var finalIds = new Array(keys.length);\n\n  for (var i = 0; i < keys.length; i++) {\n    if (ids[keys[i]]._id) {\n      finalIds[ids[keys[i]].index] = ids[keys[i]]._id;\n    }\n  }\n\n  var finalResult = {\n    result: {\n      ok: 1,\n      n: r.insertedCount\n    },\n    ops: docs,\n    insertedCount: r.insertedCount,\n    insertedIds: finalIds\n  };\n\n  if (r.getLastOp()) {\n    finalResult.result.opTime = r.getLastOp();\n  }\n\n  return finalResult;\n};\n\ndefine.classMethod('insertOne', {\n  callback: true,\n  promise: true\n});\n/**\n * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n * can be overridden by setting the **forceServerObjectId** flag.\n *\n * @method\n * @param {object[]} docs Documents to insert.\n * @param {object} [options=null] Optional settings.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {boolean} [options.ordered=true] If true, when an insert fails, don't execute the remaining writes. If false, continue with remaining inserts when one fails.\n * @param {Collection~insertWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.insertMany = function (docs, options, callback) {\n  var self = this;\n  if (typeof options == 'function') callback = options, options = {};\n  options = options ? shallowClone(options) : {\n    ordered: true\n  };\n\n  if (!Array.isArray(docs) && typeof callback == 'function') {\n    return callback(MongoError.create({\n      message: 'docs parameter must be an array of documents',\n      driver: true\n    }));\n  } else if (!Array.isArray(docs)) {\n    return new this.s.promiseLibrary(function (resolve, reject) {\n      reject(MongoError.create({\n        message: 'docs parameter must be an array of documents',\n        driver: true\n      }));\n    });\n  } // Get the write concern options\n\n\n  if (typeof options.checkKeys != 'boolean') {\n    options.checkKeys = true;\n  } // If keep going set unordered\n\n\n  options['serializeFunctions'] = options['serializeFunctions'] || self.s.serializeFunctions; // Set up the force server object id\n\n  var forceServerObjectId = typeof options.forceServerObjectId == 'boolean' ? options.forceServerObjectId : self.s.db.options.forceServerObjectId; // Do we want to force the server to assign the _id key\n\n  if (forceServerObjectId !== true) {\n    // Add _id if not specified\n    for (var i = 0; i < docs.length; i++) {\n      if (docs[i]._id == null) docs[i]._id = self.s.pkFactory.createPk();\n    }\n  } // Generate the bulk write operations\n\n\n  var operations = [{\n    insertMany: docs\n  }]; // Execute using callback\n\n  if (typeof callback == 'function') return bulkWrite(self, operations, options, function (err, r) {\n    if (err) return callback(err, r);\n    callback(null, mapInsertManyResults(docs, r));\n  }); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    bulkWrite(self, operations, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(mapInsertManyResults(docs, r));\n    });\n  });\n};\n\ndefine.classMethod('insertMany', {\n  callback: true,\n  promise: true\n});\n/**\n * @typedef {Object} Collection~BulkWriteOpResult\n * @property {number} insertedCount Number of documents inserted.\n * @property {number} matchedCount Number of documents matched for update.\n * @property {number} modifiedCount Number of documents modified.\n * @property {number} deletedCount Number of documents deleted.\n * @property {number} upsertedCount Number of documents upserted.\n * @property {object} insertedIds Inserted document generated Id's, hash key is the index of the originating operation\n * @property {object} upsertedIds Upserted document generated Id's, hash key is the index of the originating operation\n * @property {object} result The command result object.\n */\n\n/**\n * The callback format for inserts\n * @callback Collection~bulkWriteOpCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection~BulkWriteOpResult} result The result object if the command was executed successfully.\n */\n\n/**\n * Perform a bulkWrite operation without a fluent API\n *\n * Legal operation types are\n *\n *  { insertOne: { document: { a: 1 } } }\n *\n *  { updateOne: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }\n *\n *  { updateMany: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }\n *\n *  { deleteOne: { filter: {c:1} } }\n *\n *  { deleteMany: { filter: {c:1} } }\n *\n *  { replaceOne: { filter: {c:3}, replacement: {c:4}, upsert:true}}\n *\n * If documents passed in do not contain the **_id** field,\n * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n * can be overridden by setting the **forceServerObjectId** flag.\n *\n * @method\n * @param {object[]} operations Bulk operations to perform.\n * @param {object} [options=null] Optional settings.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ordered=true] Execute write operation in ordered or unordered fashion.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {Collection~bulkWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.bulkWrite = function (operations, options, callback) {\n  var self = this;\n  if (typeof options == 'function') callback = options, options = {};\n  options = options || {\n    ordered: true\n  };\n\n  if (!Array.isArray(operations)) {\n    throw MongoError.create({\n      message: \"operations must be an array of documents\",\n      driver: true\n    });\n  } // Execute using callback\n\n\n  if (typeof callback == 'function') return bulkWrite(self, operations, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    bulkWrite(self, operations, options, function (err, r) {\n      if (err && r == null) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar bulkWrite = function (self, operations, options, callback) {\n  // Add ignoreUndefined\n  if (self.s.options.ignoreUndefined) {\n    options = shallowClone(options);\n    options.ignoreUndefined = self.s.options.ignoreUndefined;\n  } // Create the bulk operation\n\n\n  var bulk = options.ordered == true || options.ordered == null ? self.initializeOrderedBulkOp(options) : self.initializeUnorderedBulkOp(options); // Do we have a collation\n\n  var collation = false; // for each op go through and add to the bulk\n\n  try {\n    for (var i = 0; i < operations.length; i++) {\n      // Get the operation type\n      var key = Object.keys(operations[i])[0]; // Check if we have a collation\n\n      if (operations[i][key].collation) {\n        collation = true;\n      } // Pass to the raw bulk\n\n\n      bulk.raw(operations[i]);\n    }\n  } catch (err) {\n    return callback(err, null);\n  } // Final options for write concern\n\n\n  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);\n  var writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : {};\n  var capabilities = self.s.topology.capabilities(); // Did the user pass in a collation, check if our write server supports it\n\n  if (collation && capabilities && !capabilities.commandsTakeCollation) {\n    return callback(new MongoError(f('server/primary/mongos does not support collation')));\n  } // Execute the bulk\n\n\n  bulk.execute(writeCon, function (err, r) {\n    // We have connection level error\n    if (!r && err) return callback(err, null); // We have single error\n\n    if (r && r.hasWriteErrors() && r.getWriteErrorCount() == 1) {\n      return callback(toError(r.getWriteErrorAt(0)), r);\n    }\n\n    r.insertedCount = r.nInserted;\n    r.matchedCount = r.nMatched;\n    r.modifiedCount = r.nModified || 0;\n    r.deletedCount = r.nRemoved;\n    r.upsertedCount = r.getUpsertedIds().length;\n    r.upsertedIds = {};\n    r.insertedIds = {}; // Update the n\n\n    r.n = r.insertedCount; // Inserted documents\n\n    var inserted = r.getInsertedIds(); // Map inserted ids\n\n    for (var i = 0; i < inserted.length; i++) {\n      r.insertedIds[inserted[i].index] = inserted[i]._id;\n    } // Upserted documents\n\n\n    var upserted = r.getUpsertedIds(); // Map upserted ids\n\n    for (i = 0; i < upserted.length; i++) {\n      r.upsertedIds[upserted[i].index] = upserted[i]._id;\n    } // Check if we have write errors\n\n\n    if (r.hasWriteErrors()) {\n      // Get all the errors\n      var errors = r.getWriteErrors(); // Return the MongoError object\n\n      return callback(toError({\n        message: 'write operation failed',\n        code: errors[0].code,\n        writeErrors: errors\n      }), r);\n    } // Check if we have a writeConcern error\n\n\n    if (r.getWriteConcernError()) {\n      // Return the MongoError object\n      return callback(toError(r.getWriteConcernError()), r);\n    } // Return the results\n\n\n    callback(null, r);\n  });\n};\n\nvar insertDocuments = function (self, docs, options, callback) {\n  if (typeof options == 'function') callback = options, options = {};\n  options = options || {}; // Ensure we are operating on an array op docs\n\n  docs = Array.isArray(docs) ? docs : [docs]; // Get the write concern options\n\n  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);\n  if (typeof finalOptions.checkKeys != 'boolean') finalOptions.checkKeys = true; // If keep going set unordered\n\n  if (finalOptions.keepGoing == true) finalOptions.ordered = false;\n  finalOptions['serializeFunctions'] = options['serializeFunctions'] || self.s.serializeFunctions; // Set up the force server object id\n\n  var forceServerObjectId = typeof options.forceServerObjectId == 'boolean' ? options.forceServerObjectId : self.s.db.options.forceServerObjectId; // Add _id if not specified\n\n  if (forceServerObjectId !== true) {\n    for (var i = 0; i < docs.length; i++) {\n      if (docs[i]._id === void 0) docs[i]._id = self.s.pkFactory.createPk();\n    }\n  } // File inserts\n\n\n  self.s.topology.insert(self.s.namespace, docs, finalOptions, function (err, result) {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n    if (result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0])); // Add docs to the list\n\n    result.ops = docs; // Return the results\n\n    handleCallback(callback, null, result);\n  });\n};\n\ndefine.classMethod('bulkWrite', {\n  callback: true,\n  promise: true\n});\n/**\n * @typedef {Object} Collection~WriteOpResult\n * @property {object[]} ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany\n * @property {object} connection The connection object used for the operation.\n * @property {object} result The command result object.\n */\n\n/**\n * The callback format for inserts\n * @callback Collection~writeOpCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection~WriteOpResult} result The result object if the command was executed successfully.\n */\n\n/**\n * @typedef {Object} Collection~insertWriteOpResult\n * @property {Number} insertedCount The total amount of documents inserted.\n * @property {object[]} ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany\n * @property {ObjectId[]} insertedIds All the generated _id's for the inserted documents.\n * @property {object} connection The connection object used for the operation.\n * @property {object} result The raw command result object returned from MongoDB (content might vary by server version).\n * @property {Number} result.ok Is 1 if the command executed correctly.\n * @property {Number} result.n The total count of documents inserted.\n */\n\n/**\n * @typedef {Object} Collection~insertOneWriteOpResult\n * @property {Number} insertedCount The total amount of documents inserted.\n * @property {object[]} ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany\n * @property {ObjectId} insertedId The driver generated ObjectId for the insert operation.\n * @property {object} connection The connection object used for the operation.\n * @property {object} result The raw command result object returned from MongoDB (content might vary by server version).\n * @property {Number} result.ok Is 1 if the command executed correctly.\n * @property {Number} result.n The total count of documents inserted.\n */\n\n/**\n * The callback format for inserts\n * @callback Collection~insertWriteOpCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection~insertWriteOpResult} result The result object if the command was executed successfully.\n */\n\n/**\n * The callback format for inserts\n * @callback Collection~insertOneWriteOpCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection~insertOneWriteOpResult} result The result object if the command was executed successfully.\n */\n\n/**\n * Inserts a single document or a an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n * can be overridden by setting the **forceServerObjectId** flag.\n *\n * @method\n * @param {(object|object[])} docs Documents to insert.\n * @param {object} [options=null] Optional settings.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {Collection~insertWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated Use insertOne, insertMany or bulkWrite\n */\n\nCollection.prototype.insert = function (docs, options, callback) {\n  if (typeof options == 'function') callback = options, options = {};\n  options = options || {\n    ordered: false\n  };\n  docs = !Array.isArray(docs) ? [docs] : docs;\n\n  if (options.keepGoing == true) {\n    options.ordered = false;\n  }\n\n  return this.insertMany(docs, options, callback);\n};\n\ndefine.classMethod('insert', {\n  callback: true,\n  promise: true\n});\n/**\n * @typedef {Object} Collection~updateWriteOpResult\n * @property {Object} result The raw result returned from MongoDB, field will vary depending on server version.\n * @property {Number} result.ok Is 1 if the command executed correctly.\n * @property {Number} result.n The total count of documents scanned.\n * @property {Number} result.nModified The total count of documents modified.\n * @property {Object} connection The connection object used for the operation.\n * @property {Number} matchedCount The number of documents that matched the filter.\n * @property {Number} modifiedCount The number of documents that were modified.\n * @property {Number} upsertedCount The number of documents upserted.\n * @property {Object} upsertedId The upserted id.\n * @property {ObjectId} upsertedId._id The upserted _id returned from the server.\n */\n\n/**\n * The callback format for inserts\n * @callback Collection~updateWriteOpCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection~updateWriteOpResult} result The result object if the command was executed successfully.\n */\n\n/**\n * Update a single document on MongoDB\n * @method\n * @param {object} filter The Filter used to select the document to update\n * @param {object} update The update operations to be applied to the document\n * @param {object} [options=null] Optional settings.\n * @param {boolean} [options.upsert=false] Update operation is an upsert.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {Collection~updateWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.updateOne = function (filter, update, options, callback) {\n  var self = this;\n  if (typeof options == 'function') callback = options, options = {};\n  options = shallowClone(options); // Add ignoreUndefined\n\n  if (this.s.options.ignoreUndefined) {\n    options = shallowClone(options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  } // Execute using callback\n\n\n  if (typeof callback == 'function') return updateOne(self, filter, update, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    updateOne(self, filter, update, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar updateOne = function (self, filter, update, options, callback) {\n  // Set single document update\n  options.multi = false; // Execute update\n\n  updateDocuments(self, filter, update, options, function (err, r) {\n    if (callback == null) return;\n    if (err && callback) return callback(err);\n    if (r == null) return callback(null, {\n      result: {\n        ok: 1\n      }\n    });\n    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;\n    r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;\n    r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;\n    r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;\n    if (callback) callback(null, r);\n  });\n};\n\ndefine.classMethod('updateOne', {\n  callback: true,\n  promise: true\n});\n/**\n * Replace a document on MongoDB\n * @method\n * @param {object} filter The Filter used to select the document to update\n * @param {object} doc The Document that replaces the matching document\n * @param {object} [options=null] Optional settings.\n * @param {boolean} [options.upsert=false] Update operation is an upsert.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {Collection~updateWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.replaceOne = function (filter, doc, options, callback) {\n  var self = this;\n  if (typeof options == 'function') callback = options, options = {};\n  options = shallowClone(options); // Add ignoreUndefined\n\n  if (this.s.options.ignoreUndefined) {\n    options = shallowClone(options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  } // Execute using callback\n\n\n  if (typeof callback == 'function') return replaceOne(self, filter, doc, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    replaceOne(self, filter, doc, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar replaceOne = function (self, filter, doc, options, callback) {\n  // Set single document update\n  options.multi = false; // Execute update\n\n  updateDocuments(self, filter, doc, options, function (err, r) {\n    if (callback == null) return;\n    if (err && callback) return callback(err);\n    if (r == null) return callback(null, {\n      result: {\n        ok: 1\n      }\n    });\n    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;\n    r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;\n    r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;\n    r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;\n    r.ops = [doc];\n    if (callback) callback(null, r);\n  });\n};\n\ndefine.classMethod('replaceOne', {\n  callback: true,\n  promise: true\n});\n/**\n * Update multiple documents on MongoDB\n * @method\n * @param {object} filter The Filter used to select the document to update\n * @param {object} update The update operations to be applied to the document\n * @param {object} [options=null] Optional settings.\n * @param {boolean} [options.upsert=false] Update operation is an upsert.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {Collection~updateWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.updateMany = function (filter, update, options, callback) {\n  var self = this;\n  if (typeof options == 'function') callback = options, options = {};\n  options = shallowClone(options); // Add ignoreUndefined\n\n  if (this.s.options.ignoreUndefined) {\n    options = shallowClone(options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  } // Execute using callback\n\n\n  if (typeof callback == 'function') return updateMany(self, filter, update, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    updateMany(self, filter, update, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar updateMany = function (self, filter, update, options, callback) {\n  // Set single document update\n  options.multi = true; // Execute update\n\n  updateDocuments(self, filter, update, options, function (err, r) {\n    if (callback == null) return;\n    if (err && callback) return callback(err);\n    if (r == null) return callback(null, {\n      result: {\n        ok: 1\n      }\n    });\n    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;\n    r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;\n    r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;\n    r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;\n    if (callback) callback(null, r);\n  });\n};\n\ndefine.classMethod('updateMany', {\n  callback: true,\n  promise: true\n});\n\nvar updateDocuments = function (self, selector, document, options, callback) {\n  if ('function' === typeof options) callback = options, options = null;\n  if (options == null) options = {};\n  if (!('function' === typeof callback)) callback = null; // If we are not providing a selector or document throw\n\n  if (selector == null || typeof selector != 'object') return callback(toError(\"selector must be a valid JavaScript object\"));\n  if (document == null || typeof document != 'object') return callback(toError(\"document must be a valid JavaScript object\")); // Get the write concern options\n\n  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options); // Do we return the actual result document\n  // Either use override on the function, or go back to default on either the collection\n  // level or db\n\n  finalOptions['serializeFunctions'] = options['serializeFunctions'] || self.s.serializeFunctions; // Execute the operation\n\n  var op = {\n    q: selector,\n    u: document\n  };\n  op.upsert = options.upsert !== void 0 ? !!options.upsert : false;\n  op.multi = options.multi !== void 0 ? !!options.multi : false; // Have we specified collation\n\n  decorateWithCollation(finalOptions, self, options); // Update options\n\n  self.s.topology.update(self.s.namespace, [op], finalOptions, function (err, result) {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err, null);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n    if (result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0])); // Return the results\n\n    handleCallback(callback, null, result);\n  });\n};\n/**\n * Updates documents.\n * @method\n * @param {object} selector The selector for the update operation.\n * @param {object} document The update document.\n * @param {object} [options=null] Optional settings.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.upsert=false] Update operation is an upsert.\n * @param {boolean} [options.multi=false] Update one/all documents with operation.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {object} [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {Collection~writeOpCallback} [callback] The command result callback\n * @throws {MongoError}\n * @return {Promise} returns Promise if no callback passed\n * @deprecated use updateOne, updateMany or bulkWrite\n */\n\n\nCollection.prototype.update = function (selector, document, options, callback) {\n  var self = this; // Add ignoreUndefined\n\n  if (this.s.options.ignoreUndefined) {\n    options = shallowClone(options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  } // Execute using callback\n\n\n  if (typeof callback == 'function') return updateDocuments(self, selector, document, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    updateDocuments(self, selector, document, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\ndefine.classMethod('update', {\n  callback: true,\n  promise: true\n});\n/**\n * @typedef {Object} Collection~deleteWriteOpResult\n * @property {Object} result The raw result returned from MongoDB, field will vary depending on server version.\n * @property {Number} result.ok Is 1 if the command executed correctly.\n * @property {Number} result.n The total count of documents deleted.\n * @property {Object} connection The connection object used for the operation.\n * @property {Number} deletedCount The number of documents deleted.\n */\n\n/**\n * The callback format for inserts\n * @callback Collection~deleteWriteOpCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection~deleteWriteOpResult} result The result object if the command was executed successfully.\n */\n\n/**\n * Delete a document on MongoDB\n * @method\n * @param {object} filter The Filter used to select the document to remove\n * @param {object} [options=null] Optional settings.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {Collection~deleteWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.deleteOne = function (filter, options, callback) {\n  var self = this;\n  if (typeof options == 'function') callback = options, options = {};\n  options = shallowClone(options); // Add ignoreUndefined\n\n  if (this.s.options.ignoreUndefined) {\n    options = shallowClone(options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  } // Execute using callback\n\n\n  if (typeof callback == 'function') return deleteOne(self, filter, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    deleteOne(self, filter, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar deleteOne = function (self, filter, options, callback) {\n  options.single = true;\n  removeDocuments(self, filter, options, function (err, r) {\n    if (callback == null) return;\n    if (err && callback) return callback(err);\n    if (r == null) return callback(null, {\n      result: {\n        ok: 1\n      }\n    });\n    r.deletedCount = r.result.n;\n    if (callback) callback(null, r);\n  });\n};\n\ndefine.classMethod('deleteOne', {\n  callback: true,\n  promise: true\n});\nCollection.prototype.removeOne = Collection.prototype.deleteOne;\ndefine.classMethod('removeOne', {\n  callback: true,\n  promise: true\n});\n/**\n * Delete multiple documents on MongoDB\n * @method\n * @param {object} filter The Filter used to select the documents to remove\n * @param {object} [options=null] Optional settings.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {Collection~deleteWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.deleteMany = function (filter, options, callback) {\n  var self = this;\n  if (typeof options == 'function') callback = options, options = {};\n  options = shallowClone(options); // Add ignoreUndefined\n\n  if (this.s.options.ignoreUndefined) {\n    options = shallowClone(options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  } // Execute using callback\n\n\n  if (typeof callback == 'function') return deleteMany(self, filter, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    deleteMany(self, filter, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar deleteMany = function (self, filter, options, callback) {\n  options.single = false;\n  removeDocuments(self, filter, options, function (err, r) {\n    if (callback == null) return;\n    if (err && callback) return callback(err);\n    if (r == null) return callback(null, {\n      result: {\n        ok: 1\n      }\n    });\n    r.deletedCount = r.result.n;\n    if (callback) callback(null, r);\n  });\n};\n\nvar removeDocuments = function (self, selector, options, callback) {\n  if (typeof options == 'function') {\n    callback = options, options = {};\n  } else if (typeof selector === 'function') {\n    callback = selector;\n    options = {};\n    selector = {};\n  } // Create an empty options object if the provided one is null\n\n\n  options = options || {}; // Get the write concern options\n\n  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options); // If selector is null set empty\n\n  if (selector == null) selector = {}; // Build the op\n\n  var op = {\n    q: selector,\n    limit: 0\n  };\n  if (options.single) op.limit = 1; // Have we specified collation\n\n  decorateWithCollation(finalOptions, self, options); // Execute the remove\n\n  self.s.topology.remove(self.s.namespace, [op], finalOptions, function (err, result) {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err, null);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n    if (result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0])); // Return the results\n\n    handleCallback(callback, null, result);\n  });\n};\n\ndefine.classMethod('deleteMany', {\n  callback: true,\n  promise: true\n});\nCollection.prototype.removeMany = Collection.prototype.deleteMany;\ndefine.classMethod('removeMany', {\n  callback: true,\n  promise: true\n});\n/**\n * Remove documents.\n * @method\n * @param {object} selector The selector for the update operation.\n * @param {object} [options=null] Optional settings.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.single=false] Removes the first document found.\n * @param {Collection~writeOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated use deleteOne, deleteMany or bulkWrite\n */\n\nCollection.prototype.remove = function (selector, options, callback) {\n  var self = this; // Add ignoreUndefined\n\n  if (this.s.options.ignoreUndefined) {\n    options = shallowClone(options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  } // Execute using callback\n\n\n  if (typeof callback == 'function') return removeDocuments(self, selector, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    removeDocuments(self, selector, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\ndefine.classMethod('remove', {\n  callback: true,\n  promise: true\n});\n/**\n * Save a document. Simple full document replacement function. Not recommended for efficiency, use atomic\n * operators and update instead for more efficient operations.\n * @method\n * @param {object} doc Document to save\n * @param {object} [options=null] Optional settings.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {Collection~writeOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated use insertOne, insertMany, updateOne or updateMany\n */\n\nCollection.prototype.save = function (doc, options, callback) {\n  var self = this;\n  if (typeof options == 'function') callback = options, options = {};\n  options = options || {}; // Add ignoreUndefined\n\n  if (this.s.options.ignoreUndefined) {\n    options = shallowClone(options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  } // Execute using callback\n\n\n  if (typeof callback == 'function') return save(self, doc, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    save(self, doc, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar save = function (self, doc, options, callback) {\n  // Get the write concern options\n  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options); // Establish if we need to perform an insert or update\n\n  if (doc._id != null) {\n    finalOptions.upsert = true;\n    return updateDocuments(self, {\n      _id: doc._id\n    }, doc, finalOptions, callback);\n  } // Insert the document\n\n\n  insertDocuments(self, [doc], options, function (err, r) {\n    if (callback == null) return;\n    if (doc == null) return handleCallback(callback, null, null);\n    if (err) return handleCallback(callback, err, null);\n    handleCallback(callback, null, r);\n  });\n};\n\ndefine.classMethod('save', {\n  callback: true,\n  promise: true\n});\n/**\n * The callback format for results\n * @callback Collection~resultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {object} result The result object if the command was executed successfully.\n */\n\n/**\n * Fetches the first document that matches the query\n * @method\n * @param {object} query Query for find Operation\n * @param {object} [options=null] Optional settings.\n * @param {number} [options.limit=0] Sets the limit of documents returned in the query.\n * @param {(array|object)} [options.sort=null] Set to sort the documents coming back from the query. Array of indexes, [['a', 1]] etc.\n * @param {object} [options.fields=null] The fields to return in the query. Object of fields to include or exclude (not both), {'a':1}\n * @param {number} [options.skip=0] Set to skip N documents ahead in your query (useful for pagination).\n * @param {Object} [options.hint=null] Tell the query to use specific indexes in the query. Object of indexes to use, {'_id':1}\n * @param {boolean} [options.explain=false] Explain the query instead of returning the data.\n * @param {boolean} [options.snapshot=false] Snapshot query.\n * @param {boolean} [options.timeout=false] Specify if the cursor can timeout.\n * @param {boolean} [options.tailable=false] Specify if the cursor is tailable.\n * @param {number} [options.batchSize=0] Set the batchSize for the getMoreCommand when iterating over the query results.\n * @param {boolean} [options.returnKey=false] Only return the index key.\n * @param {number} [options.maxScan=null] Limit the number of items to scan.\n * @param {number} [options.min=null] Set index bounds.\n * @param {number} [options.max=null] Set index bounds.\n * @param {boolean} [options.showDiskLoc=false] Show disk location of results.\n * @param {string} [options.comment=null] You can put a $comment field on a query to make looking in the profiler logs simpler.\n * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.\n * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {boolean} [options.partial=false] Specify if the cursor should return partial results when querying against a sharded system\n * @param {number} [options.maxTimeMS=null] Number of milliseconds to wait before aborting the query.\n * @param {object} [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.findOne = function () {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 0);\n  var callback = args.pop();\n  if (typeof callback != 'function') args.push(callback); // Execute using callback\n\n  if (typeof callback == 'function') return findOne(self, args, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    findOne(self, args, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar findOne = function (self, args, callback) {\n  var cursor = self.find.apply(self, args).limit(-1).batchSize(1); // Return the item\n\n  cursor.next(function (err, item) {\n    if (err != null) return handleCallback(callback, toError(err), null);\n    handleCallback(callback, null, item);\n  });\n};\n\ndefine.classMethod('findOne', {\n  callback: true,\n  promise: true\n});\n/**\n * The callback format for the collection method, must be used if strict is specified\n * @callback Collection~collectionResultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection} collection The collection instance.\n */\n\n/**\n * Rename the collection.\n *\n * @method\n * @param {string} newName New name of of the collection.\n * @param {object} [options=null] Optional settings.\n * @param {boolean} [options.dropTarget=false] Drop the target name collection if it previously exists.\n * @param {Collection~collectionResultCallback} [callback] The results callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.rename = function (newName, opt, callback) {\n  var self = this;\n  if (typeof opt == 'function') callback = opt, opt = {};\n  opt = assign({}, opt, {\n    readPreference: ReadPreference.PRIMARY\n  }); // Execute using callback\n\n  if (typeof callback == 'function') return rename(self, newName, opt, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    rename(self, newName, opt, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar rename = function (self, newName, opt, callback) {\n  // Check the collection name\n  checkCollectionName(newName); // Build the command\n\n  var renameCollection = f(\"%s.%s\", self.s.dbName, self.s.name);\n  var toCollection = f(\"%s.%s\", self.s.dbName, newName);\n  var dropTarget = typeof opt.dropTarget == 'boolean' ? opt.dropTarget : false;\n  var cmd = {\n    'renameCollection': renameCollection,\n    'to': toCollection,\n    'dropTarget': dropTarget\n  }; // Decorate command with writeConcern if supported\n\n  decorateWithWriteConcern(cmd, self, opt); // Execute against admin\n\n  self.s.db.admin().command(cmd, opt, function (err, doc) {\n    if (err) return handleCallback(callback, err, null); // We have an error\n\n    if (doc.errmsg) return handleCallback(callback, toError(doc), null);\n\n    try {\n      return handleCallback(callback, null, new Collection(self.s.db, self.s.topology, self.s.dbName, newName, self.s.pkFactory, self.s.options));\n    } catch (err) {\n      return handleCallback(callback, toError(err), null);\n    }\n  });\n};\n\ndefine.classMethod('rename', {\n  callback: true,\n  promise: true\n});\n/**\n * Drop the collection from the database, removing it permanently. New accesses will create a new collection.\n *\n * @method\n * @param {object} [options=null] Optional settings.\n * @param {Collection~resultCallback} [callback] The results callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.drop = function (options, callback) {\n  var self = this;\n  if (typeof options == 'function') callback = options, options = {};\n  options = options || {}; // Execute using callback\n\n  if (typeof callback == 'function') return self.s.db.dropCollection(self.s.name, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    self.s.db.dropCollection(self.s.name, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\ndefine.classMethod('drop', {\n  callback: true,\n  promise: true\n});\n/**\n * Returns the options of the collection.\n *\n * @method\n * @param {Collection~resultCallback} [callback] The results callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.options = function (callback) {\n  var self = this; // Execute using callback\n\n  if (typeof callback == 'function') return options(self, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    options(self, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar options = function (self, callback) {\n  self.s.db.listCollections({\n    name: self.s.name\n  }).toArray(function (err, collections) {\n    if (err) return handleCallback(callback, err);\n\n    if (collections.length == 0) {\n      return handleCallback(callback, MongoError.create({\n        message: f(\"collection %s not found\", self.s.namespace),\n        driver: true\n      }));\n    }\n\n    handleCallback(callback, err, collections[0].options || null);\n  });\n};\n\ndefine.classMethod('options', {\n  callback: true,\n  promise: true\n});\n/**\n * Returns if the collection is a capped collection\n *\n * @method\n * @param {Collection~resultCallback} [callback] The results callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.isCapped = function (callback) {\n  var self = this; // Execute using callback\n\n  if (typeof callback == 'function') return isCapped(self, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    isCapped(self, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar isCapped = function (self, callback) {\n  self.options(function (err, document) {\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, null, document && document.capped);\n  });\n};\n\ndefine.classMethod('isCapped', {\n  callback: true,\n  promise: true\n});\n/**\n * Creates an index on the db and collection collection.\n * @method\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {object} [options=null] Optional settings.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.unique=false] Creates an unique index.\n * @param {boolean} [options.sparse=false] Creates a sparse index.\n * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.\n * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value\n * @param {number} [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.\n * @param {number} [options.max=null] For geospatial indexes set the high bound for the co-ordinates.\n * @param {number} [options.v=null] Specify the format version of the indexes.\n * @param {number} [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)\n * @param {string} [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)\n * @param {object} [options.partialFilterExpression=null] Creates a partial index based on the given filter object (MongoDB 3.2 or higher)\n * @param {object} [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.createIndex = function (fieldOrSpec, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  if (typeof callback != 'function') args.push(callback);\n  options = args.length ? args.shift() || {} : {};\n  options = typeof callback === 'function' ? options : callback;\n  options = options == null ? {} : options; // Execute using callback\n\n  if (typeof callback == 'function') return createIndex(self, fieldOrSpec, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    createIndex(self, fieldOrSpec, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar createIndex = function (self, fieldOrSpec, options, callback) {\n  self.s.db.createIndex(self.s.name, fieldOrSpec, options, callback);\n};\n\ndefine.classMethod('createIndex', {\n  callback: true,\n  promise: true\n});\n/**\n * Creates multiple indexes in the collection, this method is only supported for\n * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported\n * error. Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.\n * @method\n * @param {array} indexSpecs An array of index specifications to be created\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.createIndexes = function (indexSpecs, callback) {\n  var self = this; // Execute using callback\n\n  if (typeof callback == 'function') return createIndexes(self, indexSpecs, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    createIndexes(self, indexSpecs, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar createIndexes = function (self, indexSpecs, callback) {\n  var capabilities = self.s.topology.capabilities(); // Ensure we generate the correct name if the parameter is not set\n\n  for (var i = 0; i < indexSpecs.length; i++) {\n    if (indexSpecs[i].name == null) {\n      var keys = []; // Did the user pass in a collation, check if our write server supports it\n\n      if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) {\n        return callback(new MongoError(f('server/primary/mongos does not support collation')));\n      }\n\n      for (var name in indexSpecs[i].key) {\n        keys.push(f('%s_%s', name, indexSpecs[i].key[name]));\n      } // Set the name\n\n\n      indexSpecs[i].name = keys.join('_');\n    }\n  } // Execute the index\n\n\n  self.s.db.command({\n    createIndexes: self.s.name,\n    indexes: indexSpecs\n  }, {\n    readPreference: ReadPreference.PRIMARY\n  }, callback);\n};\n\ndefine.classMethod('createIndexes', {\n  callback: true,\n  promise: true\n});\n/**\n * Drops an index from this collection.\n * @method\n * @param {string} indexName Name of the index to drop.\n * @param {object} [options=null] Optional settings.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.dropIndex = function (indexName, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  if (typeof callback != 'function') args.push(callback);\n  options = args.length ? args.shift() || {} : {}; // Run only against primary\n\n  options.readPreference = ReadPreference.PRIMARY; // Execute using callback\n\n  if (typeof callback == 'function') return dropIndex(self, indexName, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    dropIndex(self, indexName, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar dropIndex = function (self, indexName, options, callback) {\n  // Delete index command\n  var cmd = {\n    'dropIndexes': self.s.name,\n    'index': indexName\n  }; // Decorate command with writeConcern if supported\n\n  decorateWithWriteConcern(cmd, self, options); // Execute command\n\n  self.s.db.command(cmd, options, function (err, result) {\n    if (typeof callback != 'function') return;\n    if (err) return handleCallback(callback, err, null);\n    handleCallback(callback, null, result);\n  });\n};\n\ndefine.classMethod('dropIndex', {\n  callback: true,\n  promise: true\n});\n/**\n * Drops all indexes from this collection.\n * @method\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.dropIndexes = function (options, callback) {\n  var self = this; // Do we have options\n\n  if (typeof options == 'function') callback = options, options = {};\n  options = options || {}; // Execute using callback\n\n  if (typeof callback == 'function') return dropIndexes(self, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    dropIndexes(self, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar dropIndexes = function (self, options, callback) {\n  self.dropIndex('*', options, function (err) {\n    if (err) return handleCallback(callback, err, false);\n    handleCallback(callback, null, true);\n  });\n};\n\ndefine.classMethod('dropIndexes', {\n  callback: true,\n  promise: true\n});\n/**\n * Drops all indexes from this collection.\n * @method\n * @deprecated use dropIndexes\n * @param {Collection~resultCallback} callback The command result callback\n * @return {Promise} returns Promise if no [callback] passed\n */\n\nCollection.prototype.dropAllIndexes = Collection.prototype.dropIndexes;\ndefine.classMethod('dropAllIndexes', {\n  callback: true,\n  promise: true\n});\n/**\n * Reindex all indexes on the collection\n * Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.\n * @method\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.reIndex = function (options, callback) {\n  var self = this;\n  if (typeof options == 'function') callback = options, options = {};\n  options = options || {}; // Execute using callback\n\n  if (typeof callback == 'function') return reIndex(self, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    reIndex(self, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar reIndex = function (self, options, callback) {\n  // Reindex\n  var cmd = {\n    'reIndex': self.s.name\n  }; // Execute the command\n\n  self.s.db.command(cmd, options, function (err, result) {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err, null);\n    handleCallback(callback, null, result.ok ? true : false);\n  });\n};\n\ndefine.classMethod('reIndex', {\n  callback: true,\n  promise: true\n});\n/**\n * Get the list of all indexes information for the collection.\n *\n * @method\n * @param {object} [options=null] Optional settings.\n * @param {number} [options.batchSize=null] The batchSize for the returned command cursor or if pre 2.8 the systems batch collection\n * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @return {CommandCursor}\n */\n\nCollection.prototype.listIndexes = function (options) {\n  options = options || {}; // Clone the options\n\n  options = shallowClone(options); // Determine the read preference in the options.\n\n  options = getReadPreference(this, options, this.s.db, this); // Set the CommandCursor constructor\n\n  options.cursorFactory = CommandCursor; // Set the promiseLibrary\n\n  options.promiseLibrary = this.s.promiseLibrary;\n\n  if (!this.s.topology.capabilities()) {\n    throw new MongoError('cannot connect to server');\n  } // We have a list collections command\n\n\n  if (this.s.topology.capabilities().hasListIndexesCommand) {\n    // Cursor options\n    var cursor = options.batchSize ? {\n      batchSize: options.batchSize\n    } : {}; // Build the command\n\n    var command = {\n      listIndexes: this.s.name,\n      cursor: cursor\n    }; // Execute the cursor\n\n    cursor = this.s.topology.cursor(f('%s.$cmd', this.s.dbName), command, options); // Do we have a readPreference, apply it\n\n    if (options.readPreference) cursor.setReadPreference(options.readPreference); // Return the cursor\n\n    return cursor;\n  } // Get the namespace\n\n\n  var ns = f('%s.system.indexes', this.s.dbName); // Get the query\n\n  cursor = this.s.topology.cursor(ns, {\n    find: ns,\n    query: {\n      ns: this.s.namespace\n    }\n  }, options); // Do we have a readPreference, apply it\n\n  if (options.readPreference) cursor.setReadPreference(options.readPreference); // Set the passed in batch size if one was provided\n\n  if (options.batchSize) cursor = cursor.batchSize(options.batchSize); // Return the cursor\n\n  return cursor;\n};\n\ndefine.classMethod('listIndexes', {\n  callback: false,\n  promise: false,\n  returns: [CommandCursor]\n});\n/**\n * Ensures that an index exists, if it does not it creates it\n * @method\n * @deprecated use createIndexes instead\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {object} [options=null] Optional settings.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.unique=false] Creates an unique index.\n * @param {boolean} [options.sparse=false] Creates a sparse index.\n * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.\n * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value\n * @param {number} [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.\n * @param {number} [options.max=null] For geospatial indexes set the high bound for the co-ordinates.\n * @param {number} [options.v=null] Specify the format version of the indexes.\n * @param {number} [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)\n * @param {number} [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)\n * @param {object} [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.ensureIndex = function (fieldOrSpec, options, callback) {\n  var self = this;\n  if (typeof options == 'function') callback = options, options = {};\n  options = options || {}; // Execute using callback\n\n  if (typeof callback == 'function') return ensureIndex(self, fieldOrSpec, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    ensureIndex(self, fieldOrSpec, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar ensureIndex = function (self, fieldOrSpec, options, callback) {\n  self.s.db.ensureIndex(self.s.name, fieldOrSpec, options, callback);\n};\n\ndefine.classMethod('ensureIndex', {\n  callback: true,\n  promise: true\n});\n/**\n * Checks if one or more indexes exist on the collection, fails on first non-existing index\n * @method\n * @param {(string|array)} indexes One or more index names to check.\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.indexExists = function (indexes, callback) {\n  var self = this; // Execute using callback\n\n  if (typeof callback == 'function') return indexExists(self, indexes, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    indexExists(self, indexes, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar indexExists = function (self, indexes, callback) {\n  self.indexInformation(function (err, indexInformation) {\n    // If we have an error return\n    if (err != null) return handleCallback(callback, err, null); // Let's check for the index names\n\n    if (!Array.isArray(indexes)) return handleCallback(callback, null, indexInformation[indexes] != null); // Check in list of indexes\n\n    for (var i = 0; i < indexes.length; i++) {\n      if (indexInformation[indexes[i]] == null) {\n        return handleCallback(callback, null, false);\n      }\n    } // All keys found return true\n\n\n    return handleCallback(callback, null, true);\n  });\n};\n\ndefine.classMethod('indexExists', {\n  callback: true,\n  promise: true\n});\n/**\n * Retrieves this collections index info.\n * @method\n * @param {object} [options=null] Optional settings.\n * @param {boolean} [options.full=false] Returns the full raw index information.\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.indexInformation = function (options, callback) {\n  var self = this; // Unpack calls\n\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  if (typeof callback != 'function') args.push(callback);\n  options = args.length ? args.shift() || {} : {}; // Execute using callback\n\n  if (typeof callback == 'function') return indexInformation(self, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    indexInformation(self, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar indexInformation = function (self, options, callback) {\n  self.s.db.indexInformation(self.s.name, options, callback);\n};\n\ndefine.classMethod('indexInformation', {\n  callback: true,\n  promise: true\n});\n/**\n * The callback format for results\n * @callback Collection~countCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {number} result The count of documents that matched the query.\n */\n\n/**\n * Count number of matching documents in the db to a query.\n * @method\n * @param {object} query The query for the count.\n * @param {object} [options=null] Optional settings.\n * @param {boolean} [options.limit=null] The limit of documents to count.\n * @param {boolean} [options.skip=null] The number of documents to skip for the count.\n * @param {string} [options.hint=null] An index name hint for the query.\n * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {number} [options.maxTimeMS=null] Number of milliseconds to wait before aborting the query.\n * @param {Collection~countCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.count = function (query, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  if (typeof callback != 'function') args.push(callback);\n  var queryOption = args.length ? args.shift() || {} : {};\n  var optionsOption = args.length ? args.shift() || {} : {}; // Execute using callback\n\n  if (typeof callback == 'function') return count(self, queryOption, optionsOption, callback); // Check if query is empty\n\n  query = query || {};\n  options = options || {}; // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    count(self, query, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar count = function (self, query, options, callback) {\n  var skip = options.skip;\n  var limit = options.limit;\n  var hint = options.hint;\n  var maxTimeMS = options.maxTimeMS; // Final query\n\n  var cmd = {\n    'count': self.s.name,\n    'query': query\n  }; // Add limit, skip and maxTimeMS if defined\n\n  if (typeof skip == 'number') cmd.skip = skip;\n  if (typeof limit == 'number') cmd.limit = limit;\n  if (typeof maxTimeMS == 'number') cmd.maxTimeMS = maxTimeMS;\n  if (hint) cmd.hint = hint;\n  options = shallowClone(options); // Ensure we have the right read preference inheritance\n\n  options = getReadPreference(self, options, self.s.db, self); // Do we have a readConcern specified\n\n  if (self.s.readConcern) {\n    cmd.readConcern = self.s.readConcern;\n  } // Have we specified collation\n\n\n  decorateWithCollation(cmd, self, options); // Execute command\n\n  self.s.db.command(cmd, options, function (err, result) {\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, null, result.n);\n  });\n};\n\ndefine.classMethod('count', {\n  callback: true,\n  promise: true\n});\n/**\n * The distinct command returns returns a list of distinct values for the given key across a collection.\n * @method\n * @param {string} key Field of the document to find distinct values for.\n * @param {object} query The query for filtering the set of documents to which we apply the distinct filter.\n * @param {object} [options=null] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {number} [options.maxTimeMS=null] Number of milliseconds to wait before aborting the query.\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.distinct = function (key, query, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  if (typeof callback != 'function') args.push(callback);\n  var queryOption = args.length ? args.shift() || {} : {};\n  var optionsOption = args.length ? args.shift() || {} : {}; // Execute using callback\n\n  if (typeof callback == 'function') return distinct(self, key, queryOption, optionsOption, callback); // Ensure the query and options are set\n\n  query = query || {};\n  options = options || {}; // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    distinct(self, key, query, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar distinct = function (self, key, query, options, callback) {\n  // maxTimeMS option\n  var maxTimeMS = options.maxTimeMS; // Distinct command\n\n  var cmd = {\n    'distinct': self.s.name,\n    'key': key,\n    'query': query\n  };\n  options = shallowClone(options); // Ensure we have the right read preference inheritance\n\n  options = getReadPreference(self, options, self.s.db, self); // Add maxTimeMS if defined\n\n  if (typeof maxTimeMS == 'number') cmd.maxTimeMS = maxTimeMS; // Do we have a readConcern specified\n\n  if (self.s.readConcern) {\n    cmd.readConcern = self.s.readConcern;\n  } // Have we specified collation\n\n\n  decorateWithCollation(cmd, self, options); // Execute the command\n\n  self.s.db.command(cmd, options, function (err, result) {\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, null, result.values);\n  });\n};\n\ndefine.classMethod('distinct', {\n  callback: true,\n  promise: true\n});\n/**\n * Retrieve all the indexes on the collection.\n * @method\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.indexes = function (callback) {\n  var self = this; // Execute using callback\n\n  if (typeof callback == 'function') return indexes(self, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    indexes(self, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar indexes = function (self, callback) {\n  self.s.db.indexInformation(self.s.name, {\n    full: true\n  }, callback);\n};\n\ndefine.classMethod('indexes', {\n  callback: true,\n  promise: true\n});\n/**\n * Get all the collection statistics.\n *\n * @method\n * @param {object} [options=null] Optional settings.\n * @param {number} [options.scale=null] Divide the returned sizes by scale value.\n * @param {Collection~resultCallback} [callback] The collection result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.stats = function (options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  if (typeof callback != 'function') args.push(callback); // Fetch all commands\n\n  options = args.length ? args.shift() || {} : {}; // Execute using callback\n\n  if (typeof callback == 'function') return stats(self, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    stats(self, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar stats = function (self, options, callback) {\n  // Build command object\n  var commandObject = {\n    collStats: self.s.name // Check if we have the scale value\n\n  };\n  if (options['scale'] != null) commandObject['scale'] = options['scale'];\n  options = shallowClone(options); // Ensure we have the right read preference inheritance\n\n  options = getReadPreference(self, options, self.s.db, self); // Execute the command\n\n  self.s.db.command(commandObject, options, callback);\n};\n\ndefine.classMethod('stats', {\n  callback: true,\n  promise: true\n});\n/**\n * @typedef {Object} Collection~findAndModifyWriteOpResult\n * @property {object} value Document returned from findAndModify command.\n * @property {object} lastErrorObject The raw lastErrorObject returned from the command.\n * @property {Number} ok Is 1 if the command executed correctly.\n */\n\n/**\n * The callback format for inserts\n * @callback Collection~findAndModifyCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection~findAndModifyWriteOpResult} result The result object if the command was executed successfully.\n */\n\n/**\n * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation.\n *\n * @method\n * @param {object} filter Document selection filter.\n * @param {object} [options=null] Optional settings.\n * @param {object} [options.projection=null] Limits the fields to return for all matching documents.\n * @param {object} [options.sort=null] Determines which document the operation modifies if the query selects multiple documents.\n * @param {number} [options.maxTimeMS=null] The maximum amount of time to allow the query to run.\n * @param {Collection~findAndModifyCallback} [callback] The collection result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.findOneAndDelete = function (filter, options, callback) {\n  var self = this;\n  if (typeof options == 'function') callback = options, options = {};\n  options = options || {}; // Basic validation\n\n  if (filter == null || typeof filter != 'object') throw toError('filter parameter must be an object'); // Execute using callback\n\n  if (typeof callback == 'function') return findOneAndDelete(self, filter, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    options = options || {};\n    findOneAndDelete(self, filter, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar findOneAndDelete = function (self, filter, options, callback) {\n  // Final options\n  var finalOptions = shallowClone(options);\n  finalOptions['fields'] = options.projection;\n  finalOptions['remove'] = true; // Execute find and Modify\n\n  self.findAndModify(filter, options.sort, null, finalOptions, callback);\n};\n\ndefine.classMethod('findOneAndDelete', {\n  callback: true,\n  promise: true\n});\n/**\n * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation.\n *\n * @method\n * @param {object} filter Document selection filter.\n * @param {object} replacement Document replacing the matching document.\n * @param {object} [options=null] Optional settings.\n * @param {object} [options.projection=null] Limits the fields to return for all matching documents.\n * @param {object} [options.sort=null] Determines which document the operation modifies if the query selects multiple documents.\n * @param {number} [options.maxTimeMS=null] The maximum amount of time to allow the query to run.\n * @param {boolean} [options.upsert=false] Upsert the document if it does not exist.\n * @param {boolean} [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.\n * @param {Collection~findAndModifyCallback} [callback] The collection result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.findOneAndReplace = function (filter, replacement, options, callback) {\n  var self = this;\n  if (typeof options == 'function') callback = options, options = {};\n  options = options || {}; // Basic validation\n\n  if (filter == null || typeof filter != 'object') throw toError('filter parameter must be an object');\n  if (replacement == null || typeof replacement != 'object') throw toError('replacement parameter must be an object'); // Execute using callback\n\n  if (typeof callback == 'function') return findOneAndReplace(self, filter, replacement, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    options = options || {};\n    findOneAndReplace(self, filter, replacement, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar findOneAndReplace = function (self, filter, replacement, options, callback) {\n  // Final options\n  var finalOptions = shallowClone(options);\n  finalOptions['fields'] = options.projection;\n  finalOptions['update'] = true;\n  finalOptions['new'] = typeof options.returnOriginal == 'boolean' ? !options.returnOriginal : false;\n  finalOptions['upsert'] = typeof options.upsert == 'boolean' ? options.upsert : false; // Execute findAndModify\n\n  self.findAndModify(filter, options.sort, replacement, finalOptions, callback);\n};\n\ndefine.classMethod('findOneAndReplace', {\n  callback: true,\n  promise: true\n});\n/**\n * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation.\n *\n * @method\n * @param {object} filter Document selection filter.\n * @param {object} update Update operations to be performed on the document\n * @param {object} [options=null] Optional settings.\n * @param {object} [options.projection=null] Limits the fields to return for all matching documents.\n * @param {object} [options.sort=null] Determines which document the operation modifies if the query selects multiple documents.\n * @param {number} [options.maxTimeMS=null] The maximum amount of time to allow the query to run.\n * @param {boolean} [options.upsert=false] Upsert the document if it does not exist.\n * @param {boolean} [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.\n * @param {Collection~findAndModifyCallback} [callback] The collection result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.findOneAndUpdate = function (filter, update, options, callback) {\n  var self = this;\n  if (typeof options == 'function') callback = options, options = {};\n  options = options || {}; // Basic validation\n\n  if (filter == null || typeof filter != 'object') throw toError('filter parameter must be an object');\n  if (update == null || typeof update != 'object') throw toError('update parameter must be an object'); // Execute using callback\n\n  if (typeof callback == 'function') return findOneAndUpdate(self, filter, update, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    options = options || {};\n    findOneAndUpdate(self, filter, update, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar findOneAndUpdate = function (self, filter, update, options, callback) {\n  // Final options\n  var finalOptions = shallowClone(options);\n  finalOptions['fields'] = options.projection;\n  finalOptions['update'] = true;\n  finalOptions['new'] = options.returnOriginal !== void 0 ? !options.returnOriginal : false;\n  finalOptions['upsert'] = options.upsert !== void 0 ? !!options.upsert : false; // Execute findAndModify\n\n  self.findAndModify(filter, options.sort, update, finalOptions, callback);\n};\n\ndefine.classMethod('findOneAndUpdate', {\n  callback: true,\n  promise: true\n});\n/**\n * Find and update a document.\n * @method\n * @param {object} query Query object to locate the object to modify.\n * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.\n * @param {object} doc The fields/vals to be updated.\n * @param {object} [options=null] Optional settings.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.remove=false] Set to true to remove the object before returning.\n * @param {boolean} [options.upsert=false] Perform an upsert operation.\n * @param {boolean} [options.new=false] Set to true if you want to return the modified object rather than the original. Ignored for remove.\n * @param {object} [options.fields=null] Object containing the field projection for the result returned from the operation.\n * @param {Collection~findAndModifyCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead\n */\n\nCollection.prototype.findAndModify = function (query, sort, doc, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  if (typeof callback != 'function') args.push(callback);\n  sort = args.length ? args.shift() || [] : [];\n  doc = args.length ? args.shift() : null;\n  options = args.length ? args.shift() || {} : {}; // Clone options\n\n  options = shallowClone(options); // Force read preference primary\n\n  options.readPreference = ReadPreference.PRIMARY; // Execute using callback\n\n  if (typeof callback == 'function') return findAndModify(self, query, sort, doc, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    options = options || {};\n    findAndModify(self, query, sort, doc, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar findAndModify = function (self, query, sort, doc, options, callback) {\n  // Create findAndModify command object\n  var queryObject = {\n    'findandmodify': self.s.name,\n    'query': query\n  };\n  sort = formattedOrderClause(sort);\n\n  if (sort) {\n    queryObject.sort = sort;\n  }\n\n  queryObject.new = options.new ? true : false;\n  queryObject.remove = options.remove ? true : false;\n  queryObject.upsert = options.upsert ? true : false;\n\n  if (options.fields) {\n    queryObject.fields = options.fields;\n  }\n\n  if (doc && !options.remove) {\n    queryObject.update = doc;\n  }\n\n  if (options.maxTimeMS) queryObject.maxTimeMS = options.maxTimeMS; // Either use override on the function, or go back to default on either the collection\n  // level or db\n\n  if (options['serializeFunctions'] != null) {\n    options['serializeFunctions'] = options['serializeFunctions'];\n  } else {\n    options['serializeFunctions'] = self.s.serializeFunctions;\n  } // No check on the documents\n\n\n  options.checkKeys = false; // Get the write concern settings\n\n  var finalOptions = writeConcern(options, self.s.db, self, options); // Decorate the findAndModify command with the write Concern\n\n  if (finalOptions.writeConcern) {\n    queryObject.writeConcern = finalOptions.writeConcern;\n  } // Have we specified bypassDocumentValidation\n\n\n  if (typeof finalOptions.bypassDocumentValidation == 'boolean') {\n    queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;\n  } // Have we specified collation\n\n\n  decorateWithCollation(queryObject, self, options); // Execute the command\n\n  self.s.db.command(queryObject, options, function (err, result) {\n    if (err) return handleCallback(callback, err, null);\n    return handleCallback(callback, null, result);\n  });\n};\n\ndefine.classMethod('findAndModify', {\n  callback: true,\n  promise: true\n});\n/**\n * Find and remove a document.\n * @method\n * @param {object} query Query object to locate the object to modify.\n * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.\n * @param {object} [options=null] Optional settings.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated use findOneAndDelete instead\n */\n\nCollection.prototype.findAndRemove = function (query, sort, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  if (typeof callback != 'function') args.push(callback);\n  sort = args.length ? args.shift() || [] : [];\n  options = args.length ? args.shift() || {} : {}; // Execute using callback\n\n  if (typeof callback == 'function') return findAndRemove(self, query, sort, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    findAndRemove(self, query, sort, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar findAndRemove = function (self, query, sort, options, callback) {\n  // Add the remove option\n  options['remove'] = true; // Execute the callback\n\n  self.findAndModify(query, sort, null, options, callback);\n};\n\ndefine.classMethod('findAndRemove', {\n  callback: true,\n  promise: true\n});\n\nfunction decorateWithWriteConcern(command, self, options) {\n  // Do we support collation 3.4 and higher\n  var capabilities = self.s.topology.capabilities(); // Do we support write concerns 3.4 and higher\n\n  if (capabilities && capabilities.commandsTakeWriteConcern) {\n    // Get the write concern settings\n    var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options); // Add the write concern to the command\n\n    if (finalOptions.writeConcern) {\n      command.writeConcern = finalOptions.writeConcern;\n    }\n  }\n}\n\nfunction decorateWithCollation(command, self, options) {\n  // Do we support collation 3.4 and higher\n  var capabilities = self.s.topology.capabilities(); // Do we support write concerns 3.4 and higher\n\n  if (capabilities && capabilities.commandsTakeCollation) {\n    if (options.collation && typeof options.collation == 'object') {\n      command.collation = options.collation;\n    }\n  }\n}\n/**\n * Execute an aggregation framework pipeline against the collection, needs MongoDB >= 2.2\n * @method\n * @param {object} pipeline Array containing all the aggregation framework commands for the execution.\n * @param {object} [options=null] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {object} [options.cursor=null] Return the query as cursor, on 2.6 > it returns as a real cursor on pre 2.6 it returns as an emulated cursor.\n * @param {number} [options.cursor.batchSize=null] The batchSize for the cursor\n * @param {boolean} [options.explain=false] Explain returns the aggregation execution plan (requires mongodb 2.6 >).\n * @param {boolean} [options.allowDiskUse=false] allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 >).\n * @param {number} [options.maxTimeMS=null] maxTimeMS specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.\n * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {object} [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {Collection~resultCallback} callback The command result callback\n * @return {(null|AggregationCursor)}\n */\n\n\nCollection.prototype.aggregate = function (pipeline, options, callback) {\n  var self = this;\n\n  if (Array.isArray(pipeline)) {\n    // Set up callback if one is provided\n    if (typeof options == 'function') {\n      callback = options;\n      options = {};\n    } // If we have no options or callback we are doing\n    // a cursor based aggregation\n\n\n    if (options == null && callback == null) {\n      options = {};\n    }\n  } else {\n    // Aggregation pipeline passed as arguments on the method\n    var args = Array.prototype.slice.call(arguments, 0); // Get the callback\n\n    callback = args.pop(); // Get the possible options object\n\n    var opts = args[args.length - 1]; // If it contains any of the admissible options pop it of the args\n\n    options = opts && (opts.readPreference || opts.explain || opts.cursor || opts.out || opts.maxTimeMS || opts.allowDiskUse) ? args.pop() : {}; // Left over arguments is the pipeline\n\n    pipeline = args;\n  } // Ignore readConcern option\n\n\n  var ignoreReadConcern = false; // Build the command\n\n  var command = {\n    aggregate: this.s.name,\n    pipeline: pipeline\n  }; // If out was specified\n\n  if (typeof options.out == 'string') {\n    pipeline.push({\n      $out: options.out\n    }); // Ignore read concern\n\n    ignoreReadConcern = true;\n  } else if (pipeline.length > 0 && pipeline[pipeline.length - 1]['$out']) {\n    ignoreReadConcern = true;\n  } // Decorate command with writeConcern if out has been specified\n\n\n  if (pipeline.length > 0 && pipeline[pipeline.length - 1]['$out']) {\n    decorateWithWriteConcern(command, self, options);\n  } // Have we specified collation\n\n\n  decorateWithCollation(command, self, options); // If we have bypassDocumentValidation set\n\n  if (typeof options.bypassDocumentValidation == 'boolean') {\n    command.bypassDocumentValidation = options.bypassDocumentValidation;\n  } // Do we have a readConcern specified\n\n\n  if (!ignoreReadConcern && this.s.readConcern) {\n    command.readConcern = this.s.readConcern;\n  } // If we have allowDiskUse defined\n\n\n  if (options.allowDiskUse) command.allowDiskUse = options.allowDiskUse;\n  if (typeof options.maxTimeMS == 'number') command.maxTimeMS = options.maxTimeMS;\n  options = shallowClone(options); // Ensure we have the right read preference inheritance\n\n  options = getReadPreference(this, options, this.s.db, this); // If explain has been specified add it\n\n  if (options.explain) command.explain = options.explain; // Validate that cursor options is valid\n\n  if (options.cursor != null && typeof options.cursor != 'object') {\n    throw toError('cursor options must be an object');\n  }\n\n  if (this.s.topology.capabilities().hasAggregationCursor) {\n    options.cursor = options.cursor || {\n      batchSize: 1000\n    };\n    command.cursor = options.cursor;\n  } // promiseLibrary\n\n\n  options.promiseLibrary = this.s.promiseLibrary; // Set the AggregationCursor constructor\n\n  options.cursorFactory = AggregationCursor;\n\n  if (typeof callback != 'function') {\n    if (!this.s.topology.capabilities()) {\n      throw new MongoError('cannot connect to server');\n    } // Allow disk usage command\n\n\n    if (typeof options.allowDiskUse == 'boolean') command.allowDiskUse = options.allowDiskUse;\n    if (typeof options.maxTimeMS == 'number') command.maxTimeMS = options.maxTimeMS; // Execute the cursor\n\n    return this.s.topology.cursor(this.s.namespace, command, options);\n  }\n\n  if (options.cursor) {\n    var cursor = this.s.topology.cursor(this.s.namespace, command, options);\n    return cursor.toArray(function (err, result) {\n      if (err) {\n        return handleCallback(callback, err);\n      }\n\n      handleCallback(callback, null, result);\n    });\n  } // For legacy server versions, we execute the command and format the result\n\n\n  this.s.db.command(command, options, function (err, result) {\n    if (err) {\n      handleCallback(callback, err);\n    } else if (result['err'] || result['errmsg']) {\n      handleCallback(callback, toError(result));\n    } else if (typeof result == 'object' && result['serverPipeline']) {\n      handleCallback(callback, null, result['serverPipeline']);\n    } else if (typeof result == 'object' && result['stages']) {\n      handleCallback(callback, null, result['stages']);\n    } else {\n      handleCallback(callback, null, result.result);\n    }\n  });\n};\n\ndefine.classMethod('aggregate', {\n  callback: true,\n  promise: false\n});\n/**\n * The callback format for results\n * @callback Collection~parallelCollectionScanCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Cursor[]} cursors A list of cursors returned allowing for parallel reading of collection.\n */\n\n/**\n * Return N number of parallel cursors for a collection allowing parallel reading of entire collection. There are\n * no ordering guarantees for returned results.\n * @method\n * @param {object} [options=null] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {number} [options.batchSize=null] Set the batchSize for the getMoreCommand when iterating over the query results.\n * @param {number} [options.numCursors=1] The maximum number of parallel command cursors to return (the number of returned cursors will be in the range 1:numCursors)\n * @param {boolean} [options.raw=false] Return all BSON documents as Raw Buffer documents.\n * @param {Collection~parallelCollectionScanCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.parallelCollectionScan = function (options, callback) {\n  var self = this;\n  if (typeof options == 'function') callback = options, options = {\n    numCursors: 1\n  }; // Set number of cursors to 1\n\n  options.numCursors = options.numCursors || 1;\n  options.batchSize = options.batchSize || 1000;\n  options = shallowClone(options); // Ensure we have the right read preference inheritance\n\n  options = getReadPreference(this, options, this.s.db, this); // Add a promiseLibrary\n\n  options.promiseLibrary = this.s.promiseLibrary; // Execute using callback\n\n  if (typeof callback == 'function') return parallelCollectionScan(self, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    parallelCollectionScan(self, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar parallelCollectionScan = function (self, options, callback) {\n  // Create command object\n  var commandObject = {\n    parallelCollectionScan: self.s.name,\n    numCursors: options.numCursors // Do we have a readConcern specified\n\n  };\n\n  if (self.s.readConcern) {\n    commandObject.readConcern = self.s.readConcern;\n  } // Store the raw value\n\n\n  var raw = options.raw;\n  delete options['raw']; // Execute the command\n\n  self.s.db.command(commandObject, options, function (err, result) {\n    if (err) return handleCallback(callback, err, null);\n    if (result == null) return handleCallback(callback, new Error(\"no result returned for parallelCollectionScan\"), null);\n    var cursors = []; // Add the raw back to the option\n\n    if (raw) options.raw = raw; // Create command cursors for each item\n\n    for (var i = 0; i < result.cursors.length; i++) {\n      var rawId = result.cursors[i].cursor.id; // Convert cursorId to Long if needed\n\n      var cursorId = typeof rawId == 'number' ? Long.fromNumber(rawId) : rawId; // Add a command cursor\n\n      cursors.push(self.s.topology.cursor(self.s.namespace, cursorId, options));\n    }\n\n    handleCallback(callback, null, cursors);\n  });\n};\n\ndefine.classMethod('parallelCollectionScan', {\n  callback: true,\n  promise: true\n});\n/**\n * Execute the geoNear command to search for items in the collection\n *\n * @method\n * @param {number} x Point to search on the x axis, ensure the indexes are ordered in the same order.\n * @param {number} y Point to search on the y axis, ensure the indexes are ordered in the same order.\n * @param {object} [options=null] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {number} [options.num=null] Max number of results to return.\n * @param {number} [options.minDistance=null] Include results starting at minDistance from a point (2.6 or higher)\n * @param {number} [options.maxDistance=null] Include results up to maxDistance from the point.\n * @param {number} [options.distanceMultiplier=null] Include a value to multiply the distances with allowing for range conversions.\n * @param {object} [options.query=null] Filter the results by a query.\n * @param {boolean} [options.spherical=false] Perform query using a spherical model.\n * @param {boolean} [options.uniqueDocs=false] The closest location in a document to the center of the search region will always be returned MongoDB > 2.X.\n * @param {boolean} [options.includeLocs=false] Include the location data fields in the top level of the results MongoDB > 2.X.\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.geoNear = function (x, y, options, callback) {\n  var self = this;\n  var point = typeof x == 'object' && x,\n      args = Array.prototype.slice.call(arguments, point ? 1 : 2);\n  callback = args.pop();\n  if (typeof callback != 'function') args.push(callback); // Fetch all commands\n\n  options = args.length ? args.shift() || {} : {}; // Execute using callback\n\n  if (typeof callback == 'function') return geoNear(self, x, y, point, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    geoNear(self, x, y, point, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar geoNear = function (self, x, y, point, options, callback) {\n  // Build command object\n  var commandObject = {\n    geoNear: self.s.name,\n    near: point || [x, y]\n  };\n  options = shallowClone(options); // Ensure we have the right read preference inheritance\n\n  options = getReadPreference(self, options, self.s.db, self); // Exclude readPreference and existing options to prevent user from\n  // shooting themselves in the foot\n\n  var exclude = {\n    readPreference: true,\n    geoNear: true,\n    near: true\n  }; // Filter out any excluded objects\n\n  commandObject = decorateCommand(commandObject, options, exclude); // Do we have a readConcern specified\n\n  if (self.s.readConcern) {\n    commandObject.readConcern = self.s.readConcern;\n  } // Have we specified collation\n\n\n  decorateWithCollation(commandObject, self, options); // Execute the command\n\n  self.s.db.command(commandObject, options, function (err, res) {\n    if (err) return handleCallback(callback, err);\n    if (res.err || res.errmsg) return handleCallback(callback, toError(res)); // should we only be returning res.results here? Not sure if the user\n    // should see the other return information\n\n    handleCallback(callback, null, res);\n  });\n};\n\ndefine.classMethod('geoNear', {\n  callback: true,\n  promise: true\n});\n/**\n * Execute a geo search using a geo haystack index on a collection.\n *\n * @method\n * @param {number} x Point to search on the x axis, ensure the indexes are ordered in the same order.\n * @param {number} y Point to search on the y axis, ensure the indexes are ordered in the same order.\n * @param {object} [options=null] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {number} [options.maxDistance=null] Include results up to maxDistance from the point.\n * @param {object} [options.search=null] Filter the results by a query.\n * @param {number} [options.limit=false] Max number of results to return.\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.geoHaystackSearch = function (x, y, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 2);\n  callback = args.pop();\n  if (typeof callback != 'function') args.push(callback); // Fetch all commands\n\n  options = args.length ? args.shift() || {} : {}; // Execute using callback\n\n  if (typeof callback == 'function') return geoHaystackSearch(self, x, y, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    geoHaystackSearch(self, x, y, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar geoHaystackSearch = function (self, x, y, options, callback) {\n  // Build command object\n  var commandObject = {\n    geoSearch: self.s.name,\n    near: [x, y] // Remove read preference from hash if it exists\n\n  };\n  commandObject = decorateCommand(commandObject, options, {\n    readPreference: true\n  });\n  options = shallowClone(options); // Ensure we have the right read preference inheritance\n\n  options = getReadPreference(self, options, self.s.db, self); // Do we have a readConcern specified\n\n  if (self.s.readConcern) {\n    commandObject.readConcern = self.s.readConcern;\n  } // Execute the command\n\n\n  self.s.db.command(commandObject, options, function (err, res) {\n    if (err) return handleCallback(callback, err);\n    if (res.err || res.errmsg) handleCallback(callback, toError(res)); // should we only be returning res.results here? Not sure if the user\n    // should see the other return information\n\n    handleCallback(callback, null, res);\n  });\n};\n\ndefine.classMethod('geoHaystackSearch', {\n  callback: true,\n  promise: true\n});\n/**\n * Group function helper\n * @ignore\n */\n// var groupFunction = function () {\n//   var c = db[ns].find(condition);\n//   var map = new Map();\n//   var reduce_function = reduce;\n//\n//   while (c.hasNext()) {\n//     var obj = c.next();\n//     var key = {};\n//\n//     for (var i = 0, len = keys.length; i < len; ++i) {\n//       var k = keys[i];\n//       key[k] = obj[k];\n//     }\n//\n//     var aggObj = map.get(key);\n//\n//     if (aggObj == null) {\n//       var newObj = Object.extend({}, key);\n//       aggObj = Object.extend(newObj, initial);\n//       map.put(key, aggObj);\n//     }\n//\n//     reduce_function(obj, aggObj);\n//   }\n//\n//   return { \"result\": map.values() };\n// }.toString();\n\nvar groupFunction = 'function () {\\nvar c = db[ns].find(condition);\\nvar map = new Map();\\nvar reduce_function = reduce;\\n\\nwhile (c.hasNext()) {\\nvar obj = c.next();\\nvar key = {};\\n\\nfor (var i = 0, len = keys.length; i < len; ++i) {\\nvar k = keys[i];\\nkey[k] = obj[k];\\n}\\n\\nvar aggObj = map.get(key);\\n\\nif (aggObj == null) {\\nvar newObj = Object.extend({}, key);\\naggObj = Object.extend(newObj, initial);\\nmap.put(key, aggObj);\\n}\\n\\nreduce_function(obj, aggObj);\\n}\\n\\nreturn { \"result\": map.values() };\\n}';\n/**\n * Run a group command across a collection\n *\n * @method\n * @param {(object|array|function|code)} keys An object, array or function expressing the keys to group by.\n * @param {object} condition An optional condition that must be true for a row to be considered.\n * @param {object} initial Initial value of the aggregation counter object.\n * @param {(function|Code)} reduce The reduce function aggregates (reduces) the objects iterated\n * @param {(function|Code)} finalize An optional function to be run on each item in the result set just before the item is returned.\n * @param {boolean} command Specify if you wish to run using the internal group command or using eval, default is true.\n * @param {object} [options=null] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated MongoDB 3.6 or higher will no longer support the group command. We recommend rewriting using the aggregation framework.\n */\n\nCollection.prototype.group = function (keys, condition, initial, reduce, finalize, command, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 3);\n  callback = args.pop();\n  if (typeof callback != 'function') args.push(callback); // Fetch all commands\n\n  reduce = args.length ? args.shift() : null;\n  finalize = args.length ? args.shift() : null;\n  command = args.length ? args.shift() : null;\n  options = args.length ? args.shift() || {} : {}; // Make sure we are backward compatible\n\n  if (!(typeof finalize == 'function')) {\n    command = finalize;\n    finalize = null;\n  }\n\n  if (!Array.isArray(keys) && keys instanceof Object && typeof keys !== 'function' && !(keys._bsontype == 'Code')) {\n    keys = Object.keys(keys);\n  }\n\n  if (typeof reduce === 'function') {\n    reduce = reduce.toString();\n  }\n\n  if (typeof finalize === 'function') {\n    finalize = finalize.toString();\n  } // Set up the command as default\n\n\n  command = command == null ? true : command; // Execute using callback\n\n  if (typeof callback == 'function') return group(self, keys, condition, initial, reduce, finalize, command, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    group(self, keys, condition, initial, reduce, finalize, command, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar group = function (self, keys, condition, initial, reduce, finalize, command, options, callback) {\n  // Execute using the command\n  if (command) {\n    var reduceFunction = reduce && reduce._bsontype == 'Code' ? reduce : new Code(reduce);\n    var selector = {\n      group: {\n        'ns': self.s.name,\n        '$reduce': reduceFunction,\n        'cond': condition,\n        'initial': initial,\n        'out': \"inline\"\n      }\n    }; // if finalize is defined\n\n    if (finalize != null) selector.group['finalize'] = finalize; // Set up group selector\n\n    if ('function' === typeof keys || keys && keys._bsontype == 'Code') {\n      selector.group.$keyf = keys && keys._bsontype == 'Code' ? keys : new Code(keys);\n    } else {\n      var hash = {};\n      keys.forEach(function (key) {\n        hash[key] = 1;\n      });\n      selector.group.key = hash;\n    }\n\n    options = shallowClone(options); // Ensure we have the right read preference inheritance\n\n    options = getReadPreference(self, options, self.s.db, self); // Do we have a readConcern specified\n\n    if (self.s.readConcern) {\n      selector.readConcern = self.s.readConcern;\n    } // Have we specified collation\n\n\n    decorateWithCollation(selector, self, options); // Execute command\n\n    self.s.db.command(selector, options, function (err, result) {\n      if (err) return handleCallback(callback, err, null);\n      handleCallback(callback, null, result.retval);\n    });\n  } else {\n    // Create execution scope\n    var scope = reduce != null && reduce._bsontype == 'Code' ? reduce.scope : {};\n    scope.ns = self.s.name;\n    scope.keys = keys;\n    scope.condition = condition;\n    scope.initial = initial; // Pass in the function text to execute within mongodb.\n\n    var groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ';');\n    self.s.db.eval(new Code(groupfn, scope), function (err, results) {\n      if (err) return handleCallback(callback, err, null);\n      handleCallback(callback, null, results.result || results);\n    });\n  }\n};\n\ndefine.classMethod('group', {\n  callback: true,\n  promise: true\n});\n/**\n * Functions that are passed as scope args must\n * be converted to Code instances.\n * @ignore\n */\n\nfunction processScope(scope) {\n  if (!isObject(scope) || scope._bsontype == 'ObjectID') {\n    return scope;\n  }\n\n  var keys = Object.keys(scope);\n  var i = keys.length;\n  var key;\n  var new_scope = {};\n\n  while (i--) {\n    key = keys[i];\n\n    if ('function' == typeof scope[key]) {\n      new_scope[key] = new Code(String(scope[key]));\n    } else {\n      new_scope[key] = processScope(scope[key]);\n    }\n  }\n\n  return new_scope;\n}\n/**\n * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n *\n * @method\n * @param {(function|string)} map The mapping function.\n * @param {(function|string)} reduce The reduce function.\n * @param {object} [options=null] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {object} [options.out=null] Sets the output target for the map reduce job. *{inline:1} | {replace:'collectionName'} | {merge:'collectionName'} | {reduce:'collectionName'}*\n * @param {object} [options.query=null] Query filter object.\n * @param {object} [options.sort=null] Sorts the input objects using this key. Useful for optimization, like sorting by the emit key for fewer reduces.\n * @param {number} [options.limit=null] Number of objects to return from collection.\n * @param {boolean} [options.keeptemp=false] Keep temporary data.\n * @param {(function|string)} [options.finalize=null] Finalize function.\n * @param {object} [options.scope=null] Can pass in variables that can be access from map/reduce/finalize.\n * @param {boolean} [options.jsMode=false] It is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X.\n * @param {boolean} [options.verbose=false] Provide statistics on job execution time.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {Collection~resultCallback} [callback] The command result callback\n * @throws {MongoError}\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nCollection.prototype.mapReduce = function (map, reduce, options, callback) {\n  var self = this;\n  if ('function' === typeof options) callback = options, options = {}; // Out must allways be defined (make sure we don't break weirdly on pre 1.8+ servers)\n\n  if (null == options.out) {\n    throw new Error(\"the out option parameter must be defined, see mongodb docs for possible values\");\n  }\n\n  if ('function' === typeof map) {\n    map = map.toString();\n  }\n\n  if ('function' === typeof reduce) {\n    reduce = reduce.toString();\n  }\n\n  if ('function' === typeof options.finalize) {\n    options.finalize = options.finalize.toString();\n  } // Execute using callback\n\n\n  if (typeof callback == 'function') return mapReduce(self, map, reduce, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    mapReduce(self, map, reduce, options, function (err, r, r1) {\n      if (err) return reject(err);\n      if (!r1) return resolve(r);\n      resolve({\n        results: r,\n        stats: r1\n      });\n    });\n  });\n};\n\nvar mapReduce = function (self, map, reduce, options, callback) {\n  var mapCommandHash = {\n    mapreduce: self.s.name,\n    map: map,\n    reduce: reduce\n  }; // Exclusion list\n\n  var exclusionList = ['readPreference']; // Add any other options passed in\n\n  for (var n in options) {\n    if ('scope' == n) {\n      mapCommandHash[n] = processScope(options[n]);\n    } else {\n      // Only include if not in exclusion list\n      if (exclusionList.indexOf(n) == -1) {\n        mapCommandHash[n] = options[n];\n      }\n    }\n  }\n\n  options = shallowClone(options); // Ensure we have the right read preference inheritance\n\n  options = getReadPreference(self, options, self.s.db, self); // If we have a read preference and inline is not set as output fail hard\n\n  if (options.readPreference != false && options.readPreference != 'primary' && options['out'] && options['out'].inline != 1 && options['out'] != 'inline') {\n    // Force readPreference to primary\n    options.readPreference = 'primary'; // Decorate command with writeConcern if supported\n\n    decorateWithWriteConcern(mapCommandHash, self, options);\n  } else if (self.s.readConcern) {\n    mapCommandHash.readConcern = self.s.readConcern;\n  } // Is bypassDocumentValidation specified\n\n\n  if (typeof options.bypassDocumentValidation == 'boolean') {\n    mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;\n  } // Have we specified collation\n\n\n  decorateWithCollation(mapCommandHash, self, options); // Execute command\n\n  self.s.db.command(mapCommandHash, {\n    readPreference: options.readPreference\n  }, function (err, result) {\n    if (err) return handleCallback(callback, err); // Check if we have an error\n\n    if (1 != result.ok || result.err || result.errmsg) {\n      return handleCallback(callback, toError(result));\n    } // Create statistics value\n\n\n    var stats = {};\n    if (result.timeMillis) stats['processtime'] = result.timeMillis;\n    if (result.counts) stats['counts'] = result.counts;\n    if (result.timing) stats['timing'] = result.timing; // invoked with inline?\n\n    if (result.results) {\n      // If we wish for no verbosity\n      if (options['verbose'] == null || !options['verbose']) {\n        return handleCallback(callback, null, result.results);\n      }\n\n      return handleCallback(callback, null, result.results, stats);\n    } // The returned collection\n\n\n    var collection = null; // If we have an object it's a different db\n\n    if (result.result != null && typeof result.result == 'object') {\n      var doc = result.result;\n      collection = self.s.db.db(doc.db).collection(doc.collection);\n    } else {\n      // Create a collection object that wraps the result collection\n      collection = self.s.db.collection(result.result);\n    } // If we wish for no verbosity\n\n\n    if (options['verbose'] == null || !options['verbose']) {\n      return handleCallback(callback, err, collection);\n    } // Return stats as third set of values\n\n\n    handleCallback(callback, err, collection, stats);\n  });\n};\n\ndefine.classMethod('mapReduce', {\n  callback: true,\n  promise: true\n});\n/**\n * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.\n *\n * @method\n * @param {object} [options=null] Optional settings.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @return {UnorderedBulkOperation}\n */\n\nCollection.prototype.initializeUnorderedBulkOp = function (options) {\n  options = options || {};\n  options.promiseLibrary = this.s.promiseLibrary;\n  return unordered(this.s.topology, this, options);\n};\n\ndefine.classMethod('initializeUnorderedBulkOp', {\n  callback: false,\n  promise: false,\n  returns: [ordered.UnorderedBulkOperation]\n});\n/**\n * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types.\n *\n * @method\n * @param {object} [options=null] Optional settings.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {OrderedBulkOperation} callback The command result callback\n * @return {null}\n */\n\nCollection.prototype.initializeOrderedBulkOp = function (options) {\n  options = options || {};\n  options.promiseLibrary = this.s.promiseLibrary;\n  return ordered(this.s.topology, this, options);\n};\n\ndefine.classMethod('initializeOrderedBulkOp', {\n  callback: false,\n  promise: false,\n  returns: [ordered.OrderedBulkOperation]\n}); // Get write concern\n\nvar writeConcern = function (target, db, col, options) {\n  if (options.w != null || options.j != null || options.fsync != null) {\n    var opts = {};\n    if (options.w != null) opts.w = options.w;\n    if (options.wtimeout != null) opts.wtimeout = options.wtimeout;\n    if (options.j != null) opts.j = options.j;\n    if (options.fsync != null) opts.fsync = options.fsync;\n    target.writeConcern = opts;\n  } else if (col.writeConcern.w != null || col.writeConcern.j != null || col.writeConcern.fsync != null) {\n    target.writeConcern = col.writeConcern;\n  } else if (db.writeConcern.w != null || db.writeConcern.j != null || db.writeConcern.fsync != null) {\n    target.writeConcern = db.writeConcern;\n  }\n\n  return target;\n}; // Figure out the read preference\n\n\nvar getReadPreference = function (self, options, db) {\n  var r = null;\n\n  if (options.readPreference) {\n    r = options.readPreference;\n  } else if (self.s.readPreference) {\n    r = self.s.readPreference;\n  } else if (db.s.readPreference) {\n    r = db.s.readPreference;\n  }\n\n  if (r instanceof ReadPreference) {\n    options.readPreference = new CoreReadPreference(r.mode, r.tags, {\n      maxStalenessSeconds: r.maxStalenessSeconds\n    });\n  } else if (typeof r == 'string') {\n    options.readPreference = new CoreReadPreference(r);\n  } else if (r && !(r instanceof ReadPreference) && typeof r == 'object') {\n    var mode = r.mode || r.preference;\n\n    if (mode && typeof mode == 'string') {\n      options.readPreference = new CoreReadPreference(mode, r.tags, {\n        maxStalenessSeconds: r.maxStalenessSeconds\n      });\n    }\n  }\n\n  return options;\n};\n\nvar testForFields = {\n  limit: 1,\n  sort: 1,\n  fields: 1,\n  skip: 1,\n  hint: 1,\n  explain: 1,\n  snapshot: 1,\n  timeout: 1,\n  tailable: 1,\n  tailableRetryInterval: 1,\n  numberOfRetries: 1,\n  awaitdata: 1,\n  awaitData: 1,\n  exhaust: 1,\n  batchSize: 1,\n  returnKey: 1,\n  maxScan: 1,\n  min: 1,\n  max: 1,\n  showDiskLoc: 1,\n  comment: 1,\n  raw: 1,\n  readPreference: 1,\n  partial: 1,\n  read: 1,\n  dbName: 1,\n  oplogReplay: 1,\n  connection: 1,\n  maxTimeMS: 1,\n  transforms: 1,\n  collation: 1,\n  noCursorTimeout: 1\n};\nmodule.exports = Collection;","map":null,"metadata":{},"sourceType":"script"}