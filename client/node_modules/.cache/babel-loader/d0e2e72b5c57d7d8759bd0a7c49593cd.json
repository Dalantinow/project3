{"ast":null,"code":"\"use strict\";\n\nvar common = require('./common'),\n    utils = require('../utils'),\n    toError = require('../utils').toError,\n    handleCallback = require('../utils').handleCallback,\n    shallowClone = utils.shallowClone,\n    BulkWriteResult = common.BulkWriteResult,\n    ObjectID = require('mongodb-core').BSON.ObjectID,\n    BSON = require('mongodb-core').BSON,\n    Define = require('../metadata'),\n    Batch = common.Batch,\n    mergeBatchResults = common.mergeBatchResults;\n\nvar bson = new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]);\n/**\n * Create a FindOperatorsUnordered instance (INTERNAL TYPE, do not instantiate directly)\n * @class\n * @property {number} length Get the number of operations in the bulk.\n * @return {FindOperatorsUnordered} a FindOperatorsUnordered instance.\n */\n\nvar FindOperatorsUnordered = function (self) {\n  this.s = self.s;\n};\n/**\n * Add a single update document to the bulk operation\n *\n * @method\n * @param {object} doc update operations\n * @throws {MongoError}\n * @return {UnorderedBulkOperation}\n */\n\n\nFindOperatorsUnordered.prototype.update = function (updateDocument) {\n  // Perform upsert\n  var upsert = typeof this.s.currentOp.upsert == 'boolean' ? this.s.currentOp.upsert : false; // Establish the update command\n\n  var document = {\n    q: this.s.currentOp.selector,\n    u: updateDocument,\n    multi: true,\n    upsert: upsert // Clear out current Op\n\n  };\n  this.s.currentOp = null; // Add the update document to the list\n\n  return addToOperationsList(this, common.UPDATE, document);\n};\n/**\n * Add a single update one document to the bulk operation\n *\n * @method\n * @param {object} doc update operations\n * @throws {MongoError}\n * @return {UnorderedBulkOperation}\n */\n\n\nFindOperatorsUnordered.prototype.updateOne = function (updateDocument) {\n  // Perform upsert\n  var upsert = typeof this.s.currentOp.upsert == 'boolean' ? this.s.currentOp.upsert : false; // Establish the update command\n\n  var document = {\n    q: this.s.currentOp.selector,\n    u: updateDocument,\n    multi: false,\n    upsert: upsert // Clear out current Op\n\n  };\n  this.s.currentOp = null; // Add the update document to the list\n\n  return addToOperationsList(this, common.UPDATE, document);\n};\n/**\n * Add a replace one operation to the bulk operation\n *\n * @method\n * @param {object} doc the new document to replace the existing one with\n * @throws {MongoError}\n * @return {UnorderedBulkOperation}\n */\n\n\nFindOperatorsUnordered.prototype.replaceOne = function (updateDocument) {\n  this.updateOne(updateDocument);\n};\n/**\n * Upsert modifier for update bulk operation\n *\n * @method\n * @throws {MongoError}\n * @return {FindOperatorsUnordered}\n */\n\n\nFindOperatorsUnordered.prototype.upsert = function () {\n  this.s.currentOp.upsert = true;\n  return this;\n};\n/**\n * Add a remove one operation to the bulk operation\n *\n * @method\n * @throws {MongoError}\n * @return {UnorderedBulkOperation}\n */\n\n\nFindOperatorsUnordered.prototype.removeOne = function () {\n  // Establish the update command\n  var document = {\n    q: this.s.currentOp.selector,\n    limit: 1 // Clear out current Op\n\n  };\n  this.s.currentOp = null; // Add the remove document to the list\n\n  return addToOperationsList(this, common.REMOVE, document);\n};\n/**\n * Add a remove operation to the bulk operation\n *\n * @method\n * @throws {MongoError}\n * @return {UnorderedBulkOperation}\n */\n\n\nFindOperatorsUnordered.prototype.remove = function () {\n  // Establish the update command\n  var document = {\n    q: this.s.currentOp.selector,\n    limit: 0 // Clear out current Op\n\n  };\n  this.s.currentOp = null; // Add the remove document to the list\n\n  return addToOperationsList(this, common.REMOVE, document);\n}; //\n// Add to the operations list\n//\n\n\nvar addToOperationsList = function (_self, docType, document) {\n  // Get the bsonSize\n  var bsonSize = bson.calculateObjectSize(document, {\n    checkKeys: false\n  }); // Throw error if the doc is bigger than the max BSON size\n\n  if (bsonSize >= _self.s.maxBatchSizeBytes) throw toError(\"document is larger than the maximum size \" + _self.s.maxBatchSizeBytes); // Holds the current batch\n\n  _self.s.currentBatch = null; // Get the right type of batch\n\n  if (docType == common.INSERT) {\n    _self.s.currentBatch = _self.s.currentInsertBatch;\n  } else if (docType == common.UPDATE) {\n    _self.s.currentBatch = _self.s.currentUpdateBatch;\n  } else if (docType == common.REMOVE) {\n    _self.s.currentBatch = _self.s.currentRemoveBatch;\n  } // Create a new batch object if we don't have a current one\n\n\n  if (_self.s.currentBatch == null) _self.s.currentBatch = new Batch(docType, _self.s.currentIndex); // Check if we need to create a new batch\n\n  if (_self.s.currentBatch.size + 1 >= _self.s.maxWriteBatchSize || _self.s.currentBatch.sizeBytes + bsonSize >= _self.s.maxBatchSizeBytes || _self.s.currentBatch.batchType != docType) {\n    // Save the batch to the execution stack\n    _self.s.batches.push(_self.s.currentBatch); // Create a new batch\n\n\n    _self.s.currentBatch = new Batch(docType, _self.s.currentIndex);\n  } // We have an array of documents\n\n\n  if (Array.isArray(document)) {\n    throw toError(\"operation passed in cannot be an Array\");\n  } else {\n    _self.s.currentBatch.operations.push(document);\n\n    _self.s.currentBatch.originalIndexes.push(_self.s.currentIndex);\n\n    _self.s.currentIndex = _self.s.currentIndex + 1;\n  } // Save back the current Batch to the right type\n\n\n  if (docType == common.INSERT) {\n    _self.s.currentInsertBatch = _self.s.currentBatch;\n\n    _self.s.bulkResult.insertedIds.push({\n      index: _self.s.bulkResult.insertedIds.length,\n      _id: document._id\n    });\n  } else if (docType == common.UPDATE) {\n    _self.s.currentUpdateBatch = _self.s.currentBatch;\n  } else if (docType == common.REMOVE) {\n    _self.s.currentRemoveBatch = _self.s.currentBatch;\n  } // Update current batch size\n\n\n  _self.s.currentBatch.size = _self.s.currentBatch.size + 1;\n  _self.s.currentBatch.sizeBytes = _self.s.currentBatch.sizeBytes + bsonSize; // Return self\n\n  return _self;\n};\n/**\n * Create a new UnorderedBulkOperation instance (INTERNAL TYPE, do not instantiate directly)\n * @class\n * @property {number} length Get the number of operations in the bulk.\n * @return {UnorderedBulkOperation} a UnorderedBulkOperation instance.\n */\n\n\nvar UnorderedBulkOperation = function (topology, collection, options) {\n  options = options == null ? {} : options; // Get the namespace for the write operations\n\n  var namespace = collection.collectionName; // Used to mark operation as executed\n\n  var executed = false; // Current item\n  // var currentBatch = null;\n\n  var currentOp = null; // Handle to the bson serializer, used to calculate running sizes\n\n  var bson = topology.bson; // Set max byte size\n\n  var maxBatchSizeBytes = topology.isMasterDoc && topology.isMasterDoc.maxBsonObjectSize ? topology.isMasterDoc.maxBsonObjectSize : 1024 * 1025 * 16;\n  var maxWriteBatchSize = topology.isMasterDoc && topology.isMasterDoc.maxWriteBatchSize ? topology.isMasterDoc.maxWriteBatchSize : 1000; // Get the write concern\n\n  var writeConcern = common.writeConcern(shallowClone(options), collection, options); // Get the promiseLibrary\n\n  var promiseLibrary = options.promiseLibrary; // No promise library selected fall back\n\n  if (!promiseLibrary) {\n    promiseLibrary = typeof global.Promise == 'function' ? global.Promise : require('es6-promise').Promise;\n  } // Final results\n\n\n  var bulkResult = {\n    ok: 1,\n    writeErrors: [],\n    writeConcernErrors: [],\n    insertedIds: [],\n    nInserted: 0,\n    nUpserted: 0,\n    nMatched: 0,\n    nModified: 0,\n    nRemoved: 0,\n    upserted: []\n  }; // Internal state\n\n  this.s = {\n    // Final result\n    bulkResult: bulkResult // Current batch state\n    ,\n    currentInsertBatch: null,\n    currentUpdateBatch: null,\n    currentRemoveBatch: null,\n    currentBatch: null,\n    currentIndex: 0,\n    batches: [] // Write concern\n    ,\n    writeConcern: writeConcern // Max batch size options\n    ,\n    maxBatchSizeBytes: maxBatchSizeBytes,\n    maxWriteBatchSize: maxWriteBatchSize // Namespace\n    ,\n    namespace: namespace // BSON\n    ,\n    bson: bson // Topology\n    ,\n    topology: topology // Options\n    ,\n    options: options // Current operation\n    ,\n    currentOp: currentOp // Executed\n    ,\n    executed: executed // Collection\n    ,\n    collection: collection // Promise Library\n    ,\n    promiseLibrary: promiseLibrary // Bypass validation\n    ,\n    bypassDocumentValidation: typeof options.bypassDocumentValidation == 'boolean' ? options.bypassDocumentValidation : false\n  };\n};\n\nvar define = UnorderedBulkOperation.define = new Define('UnorderedBulkOperation', UnorderedBulkOperation, false);\n/**\n * Add a single insert document to the bulk operation\n *\n * @param {object} doc the document to insert\n * @throws {MongoError}\n * @return {UnorderedBulkOperation}\n */\n\nUnorderedBulkOperation.prototype.insert = function (document) {\n  if (this.s.collection.s.db.options.forceServerObjectId !== true && document._id == null) document._id = new ObjectID();\n  return addToOperationsList(this, common.INSERT, document);\n};\n/**\n * Initiate a find operation for an update/updateOne/remove/removeOne/replaceOne\n *\n * @method\n * @param {object} selector The selector for the bulk operation.\n * @throws {MongoError}\n * @return {FindOperatorsUnordered}\n */\n\n\nUnorderedBulkOperation.prototype.find = function (selector) {\n  if (!selector) {\n    throw toError(\"Bulk find operation must specify a selector\");\n  } // Save a current selector\n\n\n  this.s.currentOp = {\n    selector: selector\n  };\n  return new FindOperatorsUnordered(this);\n};\n\nObject.defineProperty(UnorderedBulkOperation.prototype, 'length', {\n  enumerable: true,\n  get: function () {\n    return this.s.currentIndex;\n  }\n});\n\nUnorderedBulkOperation.prototype.raw = function (op) {\n  var key = Object.keys(op)[0]; // Set up the force server object id\n\n  var forceServerObjectId = typeof this.s.options.forceServerObjectId == 'boolean' ? this.s.options.forceServerObjectId : this.s.collection.s.db.options.forceServerObjectId; // Update operations\n\n  if (op.updateOne && op.updateOne.q || op.updateMany && op.updateMany.q || op.replaceOne && op.replaceOne.q) {\n    op[key].multi = op.updateOne || op.replaceOne ? false : true;\n    return addToOperationsList(this, common.UPDATE, op[key]);\n  } // Crud spec update format\n\n\n  if (op.updateOne || op.updateMany || op.replaceOne) {\n    var multi = op.updateOne || op.replaceOne ? false : true;\n    var operation = {\n      q: op[key].filter,\n      u: op[key].update || op[key].replacement,\n      multi: multi\n    };\n    if (op[key].upsert) operation.upsert = true;\n    return addToOperationsList(this, common.UPDATE, operation);\n  } // Remove operations\n\n\n  if (op.removeOne || op.removeMany || op.deleteOne && op.deleteOne.q || op.deleteMany && op.deleteMany.q) {\n    op[key].limit = op.removeOne ? 1 : 0;\n    return addToOperationsList(this, common.REMOVE, op[key]);\n  } // Crud spec delete operations, less efficient\n\n\n  if (op.deleteOne || op.deleteMany) {\n    var limit = op.deleteOne ? 1 : 0;\n    operation = {\n      q: op[key].filter,\n      limit: limit\n    };\n    return addToOperationsList(this, common.REMOVE, operation);\n  } // Insert operations\n\n\n  if (op.insertOne && op.insertOne.document == null) {\n    if (forceServerObjectId !== true && op.insertOne._id == null) op.insertOne._id = new ObjectID();\n    return addToOperationsList(this, common.INSERT, op.insertOne);\n  } else if (op.insertOne && op.insertOne.document) {\n    if (forceServerObjectId !== true && op.insertOne.document._id == null) op.insertOne.document._id = new ObjectID();\n    return addToOperationsList(this, common.INSERT, op.insertOne.document);\n  }\n\n  if (op.insertMany) {\n    for (var i = 0; i < op.insertMany.length; i++) {\n      if (forceServerObjectId !== true && op.insertMany[i]._id == null) op.insertMany[i]._id = new ObjectID();\n      addToOperationsList(this, common.INSERT, op.insertMany[i]);\n    }\n\n    return;\n  } // No valid type of operation\n\n\n  throw toError(\"bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany\");\n}; //\n// Execute the command\n\n\nvar executeBatch = function (self, batch, callback) {\n  var finalOptions = {\n    ordered: false\n  };\n\n  if (self.s.writeConcern != null) {\n    finalOptions.writeConcern = self.s.writeConcern;\n  }\n\n  var resultHandler = function (err, result) {\n    // Error is a driver related error not a bulk op error, terminate\n    if (err && err.driver || err && err.message) {\n      return handleCallback(callback, err);\n    } // If we have and error\n\n\n    if (err) err.ok = 0;\n    handleCallback(callback, null, mergeBatchResults(false, batch, self.s.bulkResult, err, result));\n  }; // Set an operationIf if provided\n\n\n  if (self.operationId) {\n    resultHandler.operationId = self.operationId;\n  } // Serialize functions\n\n\n  if (self.s.options.serializeFunctions) {\n    finalOptions.serializeFunctions = true;\n  } // Is the bypassDocumentValidation options specific\n\n\n  if (self.s.bypassDocumentValidation == true) {\n    finalOptions.bypassDocumentValidation = true;\n  }\n\n  try {\n    if (batch.batchType == common.INSERT) {\n      self.s.topology.insert(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);\n    } else if (batch.batchType == common.UPDATE) {\n      self.s.topology.update(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);\n    } else if (batch.batchType == common.REMOVE) {\n      self.s.topology.remove(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);\n    }\n  } catch (err) {\n    // Force top level error\n    err.ok = 0; // Merge top level error and return\n\n    handleCallback(callback, null, mergeBatchResults(false, batch, self.s.bulkResult, err, null));\n  }\n}; //\n// Execute all the commands\n\n\nvar executeBatches = function (self, callback) {\n  var numberOfCommandsToExecute = self.s.batches.length; // Execute over all the batches\n\n  for (var i = 0; i < self.s.batches.length; i++) {\n    executeBatch(self, self.s.batches[i], function (err) {\n      // Driver layer error capture it\n      if (err) error = err; // Count down the number of commands left to execute\n\n      numberOfCommandsToExecute = numberOfCommandsToExecute - 1; // Execute\n\n      if (numberOfCommandsToExecute == 0) {\n        // Driver level error\n        if (error) return handleCallback(callback, error); // Treat write errors\n\n        var error = self.s.bulkResult.writeErrors.length > 0 ? toError(self.s.bulkResult.writeErrors[0]) : null;\n        handleCallback(callback, error, new BulkWriteResult(self.s.bulkResult));\n      }\n    });\n  }\n};\n/**\n * The callback format for results\n * @callback UnorderedBulkOperation~resultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {BulkWriteResult} result The bulk write result.\n */\n\n/**\n * Execute the ordered bulk operation\n *\n * @method\n * @param {object} [options=null] Optional settings.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.fsync=false] Specify a file sync write concern.\n * @param {UnorderedBulkOperation~resultCallback} [callback] The result callback\n * @throws {MongoError}\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nUnorderedBulkOperation.prototype.execute = function (_writeConcern, callback) {\n  var self = this;\n\n  if (this.s.executed) {\n    var executedError = toError('batch cannot be re-executed');\n    return typeof callback === 'function' ? callback(executedError, null) : this.s.promiseLibrary.reject(executedError);\n  }\n\n  if (typeof _writeConcern === 'function') {\n    callback = _writeConcern;\n  } else if (_writeConcern && typeof _writeConcern === 'object') {\n    this.s.writeConcern = _writeConcern;\n  } // If we have current batch\n\n\n  if (this.s.currentInsertBatch) this.s.batches.push(this.s.currentInsertBatch);\n  if (this.s.currentUpdateBatch) this.s.batches.push(this.s.currentUpdateBatch);\n  if (this.s.currentRemoveBatch) this.s.batches.push(this.s.currentRemoveBatch); // If we have no operations in the bulk raise an error\n\n  if (this.s.batches.length == 0) {\n    var emptyBatchError = toError('Invalid Operation, no operations specified');\n    return typeof callback === 'function' ? callback(emptyBatchError, null) : this.s.promiseLibrary.reject(emptyBatchError);\n  } // Execute using callback\n\n\n  if (typeof callback === 'function') return executeBatches(this, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    executeBatches(self, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\ndefine.classMethod('execute', {\n  callback: true,\n  promise: false\n});\n/**\n * Returns an unordered batch object\n * @ignore\n */\n\nvar initializeUnorderedBulkOp = function (topology, collection, options) {\n  return new UnorderedBulkOperation(topology, collection, options);\n};\n\ninitializeUnorderedBulkOp.UnorderedBulkOperation = UnorderedBulkOperation;\nmodule.exports = initializeUnorderedBulkOp;\nmodule.exports.Bulk = UnorderedBulkOperation;","map":null,"metadata":{},"sourceType":"script"}