{"ast":null,"code":"\"use strict\";\n\nvar inherits = require('util').inherits,\n    f = require('util').format,\n    formattedOrderClause = require('./utils').formattedOrderClause,\n    handleCallback = require('./utils').handleCallback,\n    ReadPreference = require('./read_preference'),\n    MongoError = require('mongodb-core').MongoError,\n    Readable = require('stream').Readable || require('readable-stream').Readable,\n    Define = require('./metadata'),\n    CoreCursor = require('mongodb-core').Cursor,\n    Map = require('mongodb-core').BSON.Map,\n    CoreReadPreference = require('mongodb-core').ReadPreference;\n/**\n * @fileOverview The **Cursor** class is an internal class that embodies a cursor on MongoDB\n * allowing for iteration over the results returned from the underlying query. It supports\n * one by one document iteration, conversion to an array or can be iterated as a Node 0.10.X\n * or higher stream\n *\n * **CURSORS Cannot directly be instantiated**\n * @example\n * var MongoClient = require('mongodb').MongoClient,\n *   test = require('assert');\n * // Connection url\n * var url = 'mongodb://localhost:27017/test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, db) {\n *   // Create a collection we want to drop later\n *   var col = db.collection('createIndexExample1');\n *   // Insert a bunch of documents\n *   col.insert([{a:1, b:1}\n *     , {a:2, b:2}, {a:3, b:3}\n *     , {a:4, b:4}], {w:1}, function(err, result) {\n *     test.equal(null, err);\n *\n *     // Show that duplicate records got dropped\n *     col.find({}).toArray(function(err, items) {\n *       test.equal(null, err);\n *       test.equal(4, items.length);\n *       db.close();\n *     });\n *   });\n * });\n */\n\n/**\n * Namespace provided by the mongodb-core and node.js\n * @external CoreCursor\n * @external Readable\n */\n// Flags allowed for cursor\n\n\nvar flags = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];\nvar fields = ['numberOfRetries', 'tailableRetryInterval'];\nvar push = Array.prototype.push;\n/**\n * Creates a new Cursor instance (INTERNAL TYPE, do not instantiate directly)\n * @class Cursor\n * @extends external:CoreCursor\n * @extends external:Readable\n * @property {string} sortValue Cursor query sort setting.\n * @property {boolean} timeout Is Cursor able to time out.\n * @property {ReadPreference} readPreference Get cursor ReadPreference.\n * @fires Cursor#data\n * @fires Cursor#end\n * @fires Cursor#close\n * @fires Cursor#readable\n * @return {Cursor} a Cursor instance.\n * @example\n * Cursor cursor options.\n *\n * collection.find({}).project({a:1})                             // Create a projection of field a\n * collection.find({}).skip(1).limit(10)                          // Skip 1 and limit 10\n * collection.find({}).batchSize(5)                               // Set batchSize on cursor to 5\n * collection.find({}).filter({a:1})                              // Set query on the cursor\n * collection.find({}).comment('add a comment')                   // Add a comment to the query, allowing to correlate queries\n * collection.find({}).addCursorFlag('tailable', true)            // Set cursor as tailable\n * collection.find({}).addCursorFlag('oplogReplay', true)         // Set cursor as oplogReplay\n * collection.find({}).addCursorFlag('noCursorTimeout', true)     // Set cursor as noCursorTimeout\n * collection.find({}).addCursorFlag('awaitData', true)           // Set cursor as awaitData\n * collection.find({}).addCursorFlag('partial', true)             // Set cursor as partial\n * collection.find({}).addQueryModifier('$orderby', {a:1})        // Set $orderby {a:1}\n * collection.find({}).max(10)                                    // Set the cursor maxScan\n * collection.find({}).maxScan(10)                                // Set the cursor maxScan\n * collection.find({}).maxTimeMS(1000)                            // Set the cursor maxTimeMS\n * collection.find({}).min(100)                                   // Set the cursor min\n * collection.find({}).returnKey(10)                              // Set the cursor returnKey\n * collection.find({}).setReadPreference(ReadPreference.PRIMARY)  // Set the cursor readPreference\n * collection.find({}).showRecordId(true)                         // Set the cursor showRecordId\n * collection.find({}).snapshot(true)                             // Set the cursor snapshot\n * collection.find({}).sort([['a', 1]])                           // Sets the sort order of the cursor query\n * collection.find({}).hint('a_1')                                // Set the cursor hint\n *\n * All options are chainable, so one can do the following.\n *\n * collection.find({}).maxTimeMS(1000).maxScan(100).skip(1).toArray(..)\n */\n\nvar Cursor = function (bson, ns, cmd, options, topology, topologyOptions) {\n  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));\n  var self = this;\n  var state = Cursor.INIT;\n  var streamOptions = {}; // Tailable cursor options\n\n  var numberOfRetries = options.numberOfRetries || 5;\n  var tailableRetryInterval = options.tailableRetryInterval || 500;\n  var currentNumberOfRetries = numberOfRetries; // Get the promiseLibrary\n\n  var promiseLibrary = options.promiseLibrary; // No promise library selected fall back\n\n  if (!promiseLibrary) {\n    promiseLibrary = typeof global.Promise == 'function' ? global.Promise : require('es6-promise').Promise;\n  } // Set up\n\n\n  Readable.call(this, {\n    objectMode: true\n  }); // Internal cursor state\n\n  this.s = {\n    // Tailable cursor options\n    numberOfRetries: numberOfRetries,\n    tailableRetryInterval: tailableRetryInterval,\n    currentNumberOfRetries: currentNumberOfRetries // State\n    ,\n    state: state // Stream options\n    ,\n    streamOptions: streamOptions // BSON\n    ,\n    bson: bson // Namespace\n    ,\n    ns: ns // Command\n    ,\n    cmd: cmd // Options\n    ,\n    options: options // Topology\n    ,\n    topology: topology // Topology options\n    ,\n    topologyOptions: topologyOptions // Promise library\n    ,\n    promiseLibrary: promiseLibrary // Current doc\n    ,\n    currentDoc: null // Translate correctly\n\n  };\n\n  if (self.s.options.noCursorTimeout == true) {\n    self.addCursorFlag('noCursorTimeout', true);\n  } // Set the sort value\n\n\n  this.sortValue = self.s.cmd.sort; // Get the batchSize\n\n  var batchSize = cmd.cursor && cmd.cursor.batchSize ? cmd.cursor && cmd.cursor.batchSize : options.cursor && options.cursor.batchSize ? options.cursor.batchSize : 1000; // Set the batchSize\n\n  this.setCursorBatchSize(batchSize);\n};\n/**\n * Cursor stream data event, fired for each document in the cursor.\n *\n * @event Cursor#data\n * @type {object}\n */\n\n/**\n * Cursor stream end event\n *\n * @event Cursor#end\n * @type {null}\n */\n\n/**\n * Cursor stream close event\n *\n * @event Cursor#close\n * @type {null}\n */\n\n/**\n * Cursor stream readable event\n *\n * @event Cursor#readable\n * @type {null}\n */\n// Inherit from Readable\n\n\ninherits(Cursor, Readable); // Map core cursor _next method so we can apply mapping\n\nCoreCursor.prototype._next = CoreCursor.prototype.next;\n\nfor (var name in CoreCursor.prototype) {\n  Cursor.prototype[name] = CoreCursor.prototype[name];\n}\n\nvar define = Cursor.define = new Define('Cursor', Cursor, true);\n/**\n * Check if there is any document still available in the cursor\n * @method\n * @param {Cursor~resultCallback} [callback] The result callback.\n * @throws {MongoError}\n * @return {Promise} returns Promise if no callback passed\n */\n\nCursor.prototype.hasNext = function (callback) {\n  var self = this; // Execute using callback\n\n  if (typeof callback == 'function') {\n    if (self.s.currentDoc) {\n      return callback(null, true);\n    } else {\n      return nextObject(self, function (err, doc) {\n        if (err) return callback(err, null);\n        if (!doc) return callback(null, false);\n        self.s.currentDoc = doc;\n        callback(null, true);\n      });\n    }\n  } // Return a Promise\n\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    if (self.s.currentDoc) {\n      resolve(true);\n    } else {\n      nextObject(self, function (err, doc) {\n        if (self.s.state == Cursor.CLOSED || self.isDead()) return resolve(false);\n        if (err) return reject(err);\n        if (!doc) return resolve(false);\n        self.s.currentDoc = doc;\n        resolve(true);\n      });\n    }\n  });\n};\n\ndefine.classMethod('hasNext', {\n  callback: true,\n  promise: true\n});\n/**\n * Get the next available document from the cursor, returns null if no more documents are available.\n * @method\n * @param {Cursor~resultCallback} [callback] The result callback.\n * @throws {MongoError}\n * @return {Promise} returns Promise if no callback passed\n */\n\nCursor.prototype.next = function (callback) {\n  var self = this; // Execute using callback\n\n  if (typeof callback == 'function') {\n    // Return the currentDoc if someone called hasNext first\n    if (self.s.currentDoc) {\n      var doc = self.s.currentDoc;\n      self.s.currentDoc = null;\n      return callback(null, doc);\n    } // Return the next object\n\n\n    return nextObject(self, callback);\n  } // Return a Promise\n\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    // Return the currentDoc if someone called hasNext first\n    if (self.s.currentDoc) {\n      var doc = self.s.currentDoc;\n      self.s.currentDoc = null;\n      return resolve(doc);\n    }\n\n    nextObject(self, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\ndefine.classMethod('next', {\n  callback: true,\n  promise: true\n});\n/**\n * Set the cursor query\n * @method\n * @param {object} filter The filter object used for the cursor.\n * @return {Cursor}\n */\n\nCursor.prototype.filter = function (filter) {\n  if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({\n    message: \"Cursor is closed\",\n    driver: true\n  });\n  this.s.cmd.query = filter;\n  return this;\n};\n\ndefine.classMethod('filter', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Set the cursor maxScan\n * @method\n * @param {object} maxScan Constrains the query to only scan the specified number of documents when fulfilling the query\n * @return {Cursor}\n */\n\nCursor.prototype.maxScan = function (maxScan) {\n  if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({\n    message: \"Cursor is closed\",\n    driver: true\n  });\n  this.s.cmd.maxScan = maxScan;\n  return this;\n};\n\ndefine.classMethod('maxScan', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Set the cursor hint\n * @method\n * @param {object} hint If specified, then the query system will only consider plans using the hinted index.\n * @return {Cursor}\n */\n\nCursor.prototype.hint = function (hint) {\n  if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({\n    message: \"Cursor is closed\",\n    driver: true\n  });\n  this.s.cmd.hint = hint;\n  return this;\n};\n\ndefine.classMethod('hint', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Set the cursor min\n * @method\n * @param {object} min Specify a $min value to specify the inclusive lower bound for a specific index in order to constrain the results of find(). The $min specifies the lower bound for all keys of a specific index in order.\n * @return {Cursor}\n */\n\nCursor.prototype.min = function (min) {\n  if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({\n    message: \"Cursor is closed\",\n    driver: true\n  });\n  this.s.cmd.min = min;\n  return this;\n};\n\ndefine.classMethod('min', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Set the cursor max\n * @method\n * @param {object} max Specify a $max value to specify the exclusive upper bound for a specific index in order to constrain the results of find(). The $max specifies the upper bound for all keys of a specific index in order.\n * @return {Cursor}\n */\n\nCursor.prototype.max = function (max) {\n  if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({\n    message: \"Cursor is closed\",\n    driver: true\n  });\n  this.s.cmd.max = max;\n  return this;\n};\n\ndefine.classMethod('max', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Set the cursor returnKey\n * @method\n * @param {object} returnKey Only return the index field or fields for the results of the query. If $returnKey is set to true and the query does not use an index to perform the read operation, the returned documents will not contain any fields. Use one of the following forms:\n * @return {Cursor}\n */\n\nCursor.prototype.returnKey = function (value) {\n  if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({\n    message: \"Cursor is closed\",\n    driver: true\n  });\n  this.s.cmd.returnKey = value;\n  return this;\n};\n\ndefine.classMethod('returnKey', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Set the cursor showRecordId\n * @method\n * @param {object} showRecordId The $showDiskLoc option has now been deprecated and replaced with the showRecordId field. $showDiskLoc will still be accepted for OP_QUERY stye find.\n * @return {Cursor}\n */\n\nCursor.prototype.showRecordId = function (value) {\n  if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({\n    message: \"Cursor is closed\",\n    driver: true\n  });\n  this.s.cmd.showDiskLoc = value;\n  return this;\n};\n\ndefine.classMethod('showRecordId', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Set the cursor snapshot\n * @method\n * @param {object} snapshot The $snapshot operator prevents the cursor from returning a document more than once because an intervening write operation results in a move of the document.\n * @return {Cursor}\n */\n\nCursor.prototype.snapshot = function (value) {\n  if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({\n    message: \"Cursor is closed\",\n    driver: true\n  });\n  this.s.cmd.snapshot = value;\n  return this;\n};\n\ndefine.classMethod('snapshot', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Set a node.js specific cursor option\n * @method\n * @param {string} field The cursor option to set ['numberOfRetries', 'tailableRetryInterval'].\n * @param {object} value The field value.\n * @throws {MongoError}\n * @return {Cursor}\n */\n\nCursor.prototype.setCursorOption = function (field, value) {\n  if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({\n    message: \"Cursor is closed\",\n    driver: true\n  });\n  if (fields.indexOf(field) == -1) throw MongoError.create({\n    message: f(\"option %s not a supported option %s\", field, fields),\n    driver: true\n  });\n  this.s[field] = value;\n  if (field == 'numberOfRetries') this.s.currentNumberOfRetries = value;\n  return this;\n};\n\ndefine.classMethod('setCursorOption', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Add a cursor flag to the cursor\n * @method\n * @param {string} flag The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial'].\n * @param {boolean} value The flag boolean value.\n * @throws {MongoError}\n * @return {Cursor}\n */\n\nCursor.prototype.addCursorFlag = function (flag, value) {\n  if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({\n    message: \"Cursor is closed\",\n    driver: true\n  });\n  if (flags.indexOf(flag) == -1) throw MongoError.create({\n    message: f(\"flag %s not a supported flag %s\", flag, flags),\n    driver: true\n  });\n  if (typeof value != 'boolean') throw MongoError.create({\n    message: f(\"flag %s must be a boolean value\", flag),\n    driver: true\n  });\n  this.s.cmd[flag] = value;\n  return this;\n};\n\ndefine.classMethod('addCursorFlag', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Add a query modifier to the cursor query\n * @method\n * @param {string} name The query modifier (must start with $, such as $orderby etc)\n * @param {boolean} value The flag boolean value.\n * @throws {MongoError}\n * @return {Cursor}\n */\n\nCursor.prototype.addQueryModifier = function (name, value) {\n  if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({\n    message: \"Cursor is closed\",\n    driver: true\n  });\n  if (name[0] != '$') throw MongoError.create({\n    message: f(\"%s is not a valid query modifier\"),\n    driver: true\n  }); // Strip of the $\n\n  var field = name.substr(1); // Set on the command\n\n  this.s.cmd[field] = value; // Deal with the special case for sort\n\n  if (field == 'orderby') this.s.cmd.sort = this.s.cmd[field];\n  return this;\n};\n\ndefine.classMethod('addQueryModifier', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Add a comment to the cursor query allowing for tracking the comment in the log.\n * @method\n * @param {string} value The comment attached to this query.\n * @throws {MongoError}\n * @return {Cursor}\n */\n\nCursor.prototype.comment = function (value) {\n  if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({\n    message: \"Cursor is closed\",\n    driver: true\n  });\n  this.s.cmd.comment = value;\n  return this;\n};\n\ndefine.classMethod('comment', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Set a maxAwaitTimeMS on a tailing cursor query to allow to customize the timeout value for the option awaitData (Only supported on MongoDB 3.2 or higher, ignored otherwise)\n * @method\n * @param {number} value Number of milliseconds to wait before aborting the tailed query.\n * @throws {MongoError}\n * @return {Cursor}\n */\n\nCursor.prototype.maxAwaitTimeMS = function (value) {\n  if (typeof value != 'number') throw MongoError.create({\n    message: \"maxAwaitTimeMS must be a number\",\n    driver: true\n  });\n  if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({\n    message: \"Cursor is closed\",\n    driver: true\n  });\n  this.s.cmd.maxAwaitTimeMS = value;\n  return this;\n};\n\ndefine.classMethod('maxAwaitTimeMS', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n * @method\n * @param {number} value Number of milliseconds to wait before aborting the query.\n * @throws {MongoError}\n * @return {Cursor}\n */\n\nCursor.prototype.maxTimeMS = function (value) {\n  if (typeof value != 'number') throw MongoError.create({\n    message: \"maxTimeMS must be a number\",\n    driver: true\n  });\n  if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({\n    message: \"Cursor is closed\",\n    driver: true\n  });\n  this.s.cmd.maxTimeMS = value;\n  return this;\n};\n\ndefine.classMethod('maxTimeMS', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\nCursor.prototype.maxTimeMs = Cursor.prototype.maxTimeMS;\ndefine.classMethod('maxTimeMs', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Sets a field projection for the query.\n * @method\n * @param {object} value The field projection object.\n * @throws {MongoError}\n * @return {Cursor}\n */\n\nCursor.prototype.project = function (value) {\n  if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({\n    message: \"Cursor is closed\",\n    driver: true\n  });\n  this.s.cmd.fields = value;\n  return this;\n};\n\ndefine.classMethod('project', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Sets the sort order of the cursor query.\n * @method\n * @param {(string|array|object)} keyOrList The key or keys set for the sort.\n * @param {number} [direction] The direction of the sorting (1 or -1).\n * @throws {MongoError}\n * @return {Cursor}\n */\n\nCursor.prototype.sort = function (keyOrList, direction) {\n  if (this.s.options.tailable) throw MongoError.create({\n    message: \"Tailable cursor doesn't support sorting\",\n    driver: true\n  });\n  if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({\n    message: \"Cursor is closed\",\n    driver: true\n  });\n  var order = keyOrList; // We have an array of arrays, we need to preserve the order of the sort\n  // so we will us a Map\n\n  if (Array.isArray(order) && Array.isArray(order[0])) {\n    order = new Map(order.map(function (x) {\n      var value = [x[0], null];\n\n      if (x[1] == 'asc') {\n        value[1] = 1;\n      } else if (x[1] == 'desc') {\n        value[1] = -1;\n      } else if (x[1] == 1 || x[1] == -1) {\n        value[1] = x[1];\n      } else {\n        throw new MongoError(\"Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]\");\n      }\n\n      return value;\n    }));\n  }\n\n  if (direction != null) {\n    order = [[keyOrList, direction]];\n  }\n\n  this.s.cmd.sort = order;\n  this.sortValue = order;\n  return this;\n};\n\ndefine.classMethod('sort', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Set the batch size for the cursor.\n * @method\n * @param {number} value The batchSize for the cursor.\n * @throws {MongoError}\n * @return {Cursor}\n */\n\nCursor.prototype.batchSize = function (value) {\n  if (this.s.options.tailable) throw MongoError.create({\n    message: \"Tailable cursor doesn't support batchSize\",\n    driver: true\n  });\n  if (this.s.state == Cursor.CLOSED || this.isDead()) throw MongoError.create({\n    message: \"Cursor is closed\",\n    driver: true\n  });\n  if (typeof value != 'number') throw MongoError.create({\n    message: \"batchSize requires an integer\",\n    driver: true\n  });\n  this.s.cmd.batchSize = value;\n  this.setCursorBatchSize(value);\n  return this;\n};\n\ndefine.classMethod('batchSize', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Set the collation options for the cursor.\n * @method\n * @param {object} value The cursor collation options (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @throws {MongoError}\n * @return {Cursor}\n */\n\nCursor.prototype.collation = function (value) {\n  this.s.cmd.collation = value;\n  return this;\n};\n\ndefine.classMethod('collation', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Set the limit for the cursor.\n * @method\n * @param {number} value The limit for the cursor query.\n * @throws {MongoError}\n * @return {Cursor}\n */\n\nCursor.prototype.limit = function (value) {\n  if (this.s.options.tailable) throw MongoError.create({\n    message: \"Tailable cursor doesn't support limit\",\n    driver: true\n  });\n  if (this.s.state == Cursor.OPEN || this.s.state == Cursor.CLOSED || this.isDead()) throw MongoError.create({\n    message: \"Cursor is closed\",\n    driver: true\n  });\n  if (typeof value != 'number') throw MongoError.create({\n    message: \"limit requires an integer\",\n    driver: true\n  });\n  this.s.cmd.limit = value; // this.cursorLimit = value;\n\n  this.setCursorLimit(value);\n  return this;\n};\n\ndefine.classMethod('limit', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Set the skip for the cursor.\n * @method\n * @param {number} value The skip for the cursor query.\n * @throws {MongoError}\n * @return {Cursor}\n */\n\nCursor.prototype.skip = function (value) {\n  if (this.s.options.tailable) throw MongoError.create({\n    message: \"Tailable cursor doesn't support skip\",\n    driver: true\n  });\n  if (this.s.state == Cursor.OPEN || this.s.state == Cursor.CLOSED || this.isDead()) throw MongoError.create({\n    message: \"Cursor is closed\",\n    driver: true\n  });\n  if (typeof value != 'number') throw MongoError.create({\n    message: \"skip requires an integer\",\n    driver: true\n  });\n  this.s.cmd.skip = value;\n  this.setCursorSkip(value);\n  return this;\n};\n\ndefine.classMethod('skip', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * The callback format for results\n * @callback Cursor~resultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {(object|null|boolean)} result The result object if the command was executed successfully.\n */\n\n/**\n * Clone the cursor\n * @function external:CoreCursor#clone\n * @return {Cursor}\n */\n\n/**\n * Resets the cursor\n * @function external:CoreCursor#rewind\n * @return {null}\n */\n\n/**\n * Get the next available document from the cursor, returns null if no more documents are available.\n * @method\n * @param {Cursor~resultCallback} [callback] The result callback.\n * @throws {MongoError}\n * @deprecated\n * @return {Promise} returns Promise if no callback passed\n */\n\nCursor.prototype.nextObject = Cursor.prototype.next;\n\nvar nextObject = function (self, callback) {\n  if (self.s.state == Cursor.CLOSED || self.isDead && self.isDead()) return handleCallback(callback, MongoError.create({\n    message: \"Cursor is closed\",\n    driver: true\n  }));\n\n  if (self.s.state == Cursor.INIT && self.s.cmd.sort) {\n    try {\n      self.s.cmd.sort = formattedOrderClause(self.s.cmd.sort);\n    } catch (err) {\n      return handleCallback(callback, err);\n    }\n  } // Get the next object\n\n\n  self._next(function (err, doc) {\n    self.s.state = Cursor.OPEN;\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, null, doc);\n  });\n};\n\ndefine.classMethod('nextObject', {\n  callback: true,\n  promise: true\n}); // Trampoline emptying the number of retrieved items\n// without incurring a nextTick operation\n\nvar loop = function (self, callback) {\n  // No more items we are done\n  if (self.bufferedCount() == 0) return; // Get the next document\n\n  self._next(callback); // Loop\n\n\n  return loop;\n};\n\nCursor.prototype.next = Cursor.prototype.nextObject;\ndefine.classMethod('next', {\n  callback: true,\n  promise: true\n});\n/**\n * Iterates over all the documents for this cursor. As with **{cursor.toArray}**,\n * not all of the elements will be iterated if this cursor had been previously accessed.\n * In that case, **{cursor.rewind}** can be used to reset the cursor. However, unlike\n * **{cursor.toArray}**, the cursor will only hold a maximum of batch size elements\n * at any given time if batch size is specified. Otherwise, the caller is responsible\n * for making sure that the entire result can fit the memory.\n * @method\n * @deprecated\n * @param {Cursor~resultCallback} callback The result callback.\n * @throws {MongoError}\n * @return {null}\n */\n\nCursor.prototype.each = function (callback) {\n  // Rewind cursor state\n  this.rewind(); // Set current cursor to INIT\n\n  this.s.state = Cursor.INIT; // Run the query\n\n  _each(this, callback);\n};\n\ndefine.classMethod('each', {\n  callback: true,\n  promise: false\n}); // Run the each loop\n\nvar _each = function (self, callback) {\n  if (!callback) throw MongoError.create({\n    message: 'callback is mandatory',\n    driver: true\n  });\n  if (self.isNotified()) return;\n\n  if (self.s.state == Cursor.CLOSED || self.isDead()) {\n    return handleCallback(callback, MongoError.create({\n      message: \"Cursor is closed\",\n      driver: true\n    }));\n  }\n\n  if (self.s.state == Cursor.INIT) self.s.state = Cursor.OPEN; // Define function to avoid global scope escape\n\n  var fn = null; // Trampoline all the entries\n\n  if (self.bufferedCount() > 0) {\n    while (fn = loop(self, callback)) fn(self, callback);\n\n    _each(self, callback);\n  } else {\n    self.next(function (err, item) {\n      if (err) return handleCallback(callback, err);\n\n      if (item == null) {\n        self.s.state = Cursor.CLOSED;\n        return handleCallback(callback, null, null);\n      }\n\n      if (handleCallback(callback, null, item) == false) return;\n\n      _each(self, callback);\n    });\n  }\n};\n/**\n * The callback format for the forEach iterator method\n * @callback Cursor~iteratorCallback\n * @param {Object} doc An emitted document for the iterator\n */\n\n/**\n * The callback error format for the forEach iterator method\n * @callback Cursor~endCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n */\n\n/**\n * Iterates over all the documents for this cursor using the iterator, callback pattern.\n * @method\n * @param {Cursor~iteratorCallback} iterator The iteration callback.\n * @param {Cursor~endCallback} callback The end callback.\n * @throws {MongoError}\n * @return {null}\n */\n\n\nCursor.prototype.forEach = function (iterator, callback) {\n  this.each(function (err, doc) {\n    if (err) {\n      callback(err);\n      return false;\n    }\n\n    if (doc != null) {\n      iterator(doc);\n      return true;\n    }\n\n    if (doc == null && callback) {\n      var internalCallback = callback;\n      callback = null;\n      internalCallback(null);\n      return false;\n    }\n  });\n};\n\ndefine.classMethod('forEach', {\n  callback: true,\n  promise: false\n});\n/**\n * Set the ReadPreference for the cursor.\n * @method\n * @param {(string|ReadPreference)} readPreference The new read preference for the cursor.\n * @throws {MongoError}\n * @return {Cursor}\n */\n\nCursor.prototype.setReadPreference = function (r) {\n  if (this.s.state != Cursor.INIT) throw MongoError.create({\n    message: 'cannot change cursor readPreference after cursor has been accessed',\n    driver: true\n  });\n\n  if (r instanceof ReadPreference) {\n    this.s.options.readPreference = new CoreReadPreference(r.mode, r.tags, {\n      maxStalenessSeconds: r.maxStalenessSeconds\n    });\n  } else if (typeof r == 'string') {\n    this.s.options.readPreference = new CoreReadPreference(r);\n  } else if (r instanceof CoreReadPreference) {\n    this.s.options.readPreference = r;\n  }\n\n  return this;\n};\n\ndefine.classMethod('setReadPreference', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * The callback format for results\n * @callback Cursor~toArrayResultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {object[]} documents All the documents the satisfy the cursor.\n */\n\n/**\n * Returns an array of documents. The caller is responsible for making sure that there\n * is enough memory to store the results. Note that the array only contain partial\n * results when this cursor had been previously accessed. In that case,\n * cursor.rewind() can be used to reset the cursor.\n * @method\n * @param {Cursor~toArrayResultCallback} [callback] The result callback.\n * @throws {MongoError}\n * @return {Promise} returns Promise if no callback passed\n */\n\nCursor.prototype.toArray = function (callback) {\n  var self = this;\n  if (self.s.options.tailable) throw MongoError.create({\n    message: 'Tailable cursor cannot be converted to array',\n    driver: true\n  }); // Execute using callback\n\n  if (typeof callback == 'function') return toArray(self, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    toArray(self, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar toArray = function (self, callback) {\n  var items = []; // Reset cursor\n\n  self.rewind();\n  self.s.state = Cursor.INIT; // Fetch all the documents\n\n  var fetchDocs = function () {\n    self._next(function (err, doc) {\n      if (err) return handleCallback(callback, err);\n\n      if (doc == null) {\n        self.s.state = Cursor.CLOSED;\n        return handleCallback(callback, null, items);\n      } // Add doc to items\n\n\n      items.push(doc); // Get all buffered objects\n\n      if (self.bufferedCount() > 0) {\n        var docs = self.readBufferedDocuments(self.bufferedCount()); // Transform the doc if transform method added\n\n        if (self.s.transforms && typeof self.s.transforms.doc == 'function') {\n          docs = docs.map(self.s.transforms.doc);\n        }\n\n        push.apply(items, docs);\n      } // Attempt a fetch\n\n\n      fetchDocs();\n    });\n  };\n\n  fetchDocs();\n};\n\ndefine.classMethod('toArray', {\n  callback: true,\n  promise: true\n});\n/**\n * The callback format for results\n * @callback Cursor~countResultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {number} count The count of documents.\n */\n\n/**\n * Get the count of documents for this cursor\n * @method\n * @param {boolean} [applySkipLimit=true] Should the count command apply limit and skip settings on the cursor or in the passed in options.\n * @param {object} [options=null] Optional settings.\n * @param {number} [options.skip=null] The number of documents to skip.\n * @param {number} [options.limit=null] The maximum amounts to count before aborting.\n * @param {number} [options.maxTimeMS=null] Number of milliseconds to wait before aborting the query.\n * @param {string} [options.hint=null] An index name hint for the query.\n * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {Cursor~countResultCallback} [callback] The result callback.\n * @return {Promise} returns Promise if no callback passed\n */\n\nCursor.prototype.count = function (applySkipLimit, opts, callback) {\n  var self = this;\n  if (self.s.cmd.query == null) throw MongoError.create({\n    message: \"count can only be used with find command\",\n    driver: true\n  });\n  if (typeof opts == 'function') callback = opts, opts = {};\n  opts = opts || {}; // Execute using callback\n\n  if (typeof callback == 'function') return count(self, applySkipLimit, opts, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    count(self, applySkipLimit, opts, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar count = function (self, applySkipLimit, opts, callback) {\n  if (typeof applySkipLimit == 'function') {\n    callback = applySkipLimit;\n    applySkipLimit = true;\n  }\n\n  if (applySkipLimit) {\n    if (typeof self.cursorSkip() == 'number') opts.skip = self.cursorSkip();\n    if (typeof self.cursorLimit() == 'number') opts.limit = self.cursorLimit();\n  } // Command\n\n\n  var delimiter = self.s.ns.indexOf('.');\n  var command = {\n    'count': self.s.ns.substr(delimiter + 1),\n    'query': self.s.cmd.query // Apply a readConcern if set\n\n  };\n\n  if (self.s.cmd.readConcern) {\n    command.readConcern = self.s.cmd.readConcern;\n  } // Apply a hint if set\n\n\n  if (self.s.cmd.hint) {\n    command.hint = self.s.cmd.hint;\n  }\n\n  if (typeof opts.maxTimeMS == 'number') {\n    command.maxTimeMS = opts.maxTimeMS;\n  } else if (self.s.cmd && typeof self.s.cmd.maxTimeMS == 'number') {\n    command.maxTimeMS = self.s.cmd.maxTimeMS;\n  } // Merge in any options\n\n\n  if (opts.skip) command.skip = opts.skip;\n  if (opts.limit) command.limit = opts.limit;\n  if (self.s.options.hint) command.hint = self.s.options.hint; // Set cursor server to the same as the topology\n\n  self.server = self.topology; // Execute the command\n\n  self.topology.command(f(\"%s.$cmd\", self.s.ns.substr(0, delimiter)), command, function (err, result) {\n    callback(err, result ? result.result.n : null);\n  }, self.options);\n};\n\ndefine.classMethod('count', {\n  callback: true,\n  promise: true\n});\n/**\n * Close the cursor, sending a KillCursor command and emitting close.\n * @method\n * @param {Cursor~resultCallback} [callback] The result callback.\n * @return {Promise} returns Promise if no callback passed\n */\n\nCursor.prototype.close = function (callback) {\n  this.s.state = Cursor.CLOSED; // Kill the cursor\n\n  this.kill(); // Emit the close event for the cursor\n\n  this.emit('close'); // Callback if provided\n\n  if (typeof callback == 'function') return handleCallback(callback, null, this); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve) {\n    resolve();\n  });\n};\n\ndefine.classMethod('close', {\n  callback: true,\n  promise: true\n});\n/**\n * Map all documents using the provided function\n * @method\n * @param {function} [transform] The mapping transformation method.\n * @return {Cursor}\n */\n\nCursor.prototype.map = function (transform) {\n  if (this.cursorState.transforms && this.cursorState.transforms.doc) {\n    var oldTransform = this.cursorState.transforms.doc;\n\n    this.cursorState.transforms.doc = function (doc) {\n      return transform(oldTransform(doc));\n    };\n  } else {\n    this.cursorState.transforms = {\n      doc: transform\n    };\n  }\n\n  return this;\n};\n\ndefine.classMethod('map', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Is the cursor closed\n * @method\n * @return {boolean}\n */\n\nCursor.prototype.isClosed = function () {\n  return this.isDead();\n};\n\ndefine.classMethod('isClosed', {\n  callback: false,\n  promise: false,\n  returns: [Boolean]\n});\n\nCursor.prototype.destroy = function (err) {\n  if (err) this.emit('error', err);\n  this.pause();\n  this.close();\n};\n\ndefine.classMethod('destroy', {\n  callback: false,\n  promise: false\n});\n/**\n * Return a modified Readable stream including a possible transform method.\n * @method\n * @param {object} [options=null] Optional settings.\n * @param {function} [options.transform=null] A transformation method applied to each document emitted by the stream.\n * @return {Cursor}\n */\n\nCursor.prototype.stream = function (options) {\n  this.s.streamOptions = options || {};\n  return this;\n};\n\ndefine.classMethod('stream', {\n  callback: false,\n  promise: false,\n  returns: [Cursor]\n});\n/**\n * Execute the explain for the cursor\n * @method\n * @param {Cursor~resultCallback} [callback] The result callback.\n * @return {Promise} returns Promise if no callback passed\n */\n\nCursor.prototype.explain = function (callback) {\n  var self = this;\n  this.s.cmd.explain = true; // Do we have a readConcern\n\n  if (this.s.cmd.readConcern) {\n    delete this.s.cmd['readConcern'];\n  } // Execute using callback\n\n\n  if (typeof callback == 'function') return this._next(callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    self._next(function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\ndefine.classMethod('explain', {\n  callback: true,\n  promise: true\n});\n\nCursor.prototype._read = function () {\n  var self = this;\n\n  if (self.s.state == Cursor.CLOSED || self.isDead()) {\n    return self.push(null);\n  } // Get the next item\n\n\n  self.nextObject(function (err, result) {\n    if (err) {\n      if (self.listeners('error') && self.listeners('error').length > 0) {\n        self.emit('error', err);\n      }\n\n      if (!self.isDead()) self.close(); // Emit end event\n\n      self.emit('end');\n      return self.emit('finish');\n    } // If we provided a transformation method\n\n\n    if (typeof self.s.streamOptions.transform == 'function' && result != null) {\n      return self.push(self.s.streamOptions.transform(result));\n    } // If we provided a map function\n\n\n    if (self.cursorState.transforms && typeof self.cursorState.transforms.doc == 'function' && result != null) {\n      return self.push(self.cursorState.transforms.doc(result));\n    } // Return the result\n\n\n    self.push(result);\n  });\n};\n\nObject.defineProperty(Cursor.prototype, 'readPreference', {\n  enumerable: true,\n  get: function () {\n    if (!this || !this.s) {\n      return null;\n    }\n\n    return this.s.options.readPreference;\n  }\n});\nObject.defineProperty(Cursor.prototype, 'namespace', {\n  enumerable: true,\n  get: function () {\n    if (!this || !this.s) {\n      return null;\n    } // TODO: refactor this logic into core\n\n\n    var ns = this.s.ns || '';\n    var firstDot = ns.indexOf('.');\n\n    if (firstDot < 0) {\n      return {\n        database: this.s.ns,\n        collection: ''\n      };\n    }\n\n    return {\n      database: ns.substr(0, firstDot),\n      collection: ns.substr(firstDot + 1)\n    };\n  }\n});\n/**\n * The read() method pulls some data out of the internal buffer and returns it. If there is no data available, then it will return null.\n * @function external:Readable#read\n * @param {number} size Optional argument to specify how much data to read.\n * @return {(String | Buffer | null)}\n */\n\n/**\n * Call this function to cause the stream to return strings of the specified encoding instead of Buffer objects.\n * @function external:Readable#setEncoding\n * @param {string} encoding The encoding to use.\n * @return {null}\n */\n\n/**\n * This method will cause the readable stream to resume emitting data events.\n * @function external:Readable#resume\n * @return {null}\n */\n\n/**\n * This method will cause a stream in flowing-mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.\n * @function external:Readable#pause\n * @return {null}\n */\n\n/**\n * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.\n * @function external:Readable#pipe\n * @param {Writable} destination The destination for writing data\n * @param {object} [options] Pipe options\n * @return {null}\n */\n\n/**\n * This method will remove the hooks set up for a previous pipe() call.\n * @function external:Readable#unpipe\n * @param {Writable} [destination] The destination for writing data\n * @return {null}\n */\n\n/**\n * This is useful in certain cases where a stream is being consumed by a parser, which needs to \"un-consume\" some data that it has optimistically pulled out of the source, so that the stream can be passed on to some other party.\n * @function external:Readable#unshift\n * @param {(Buffer|string)} chunk Chunk of data to unshift onto the read queue.\n * @return {null}\n */\n\n/**\n * Versions of Node prior to v0.10 had streams that did not implement the entire Streams API as it is today. (See \"Compatibility\" below for more information.)\n * @function external:Readable#wrap\n * @param {Stream} stream An \"old style\" readable stream.\n * @return {null}\n */\n\nCursor.INIT = 0;\nCursor.OPEN = 1;\nCursor.CLOSED = 2;\nCursor.GET_MORE = 3;\nmodule.exports = Cursor;","map":null,"metadata":{},"sourceType":"script"}