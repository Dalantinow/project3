{"ast":null,"code":"\"use strict\";\n\nvar Query = require('../connection/commands').Query,\n    retrieveBSON = require('../connection/utils').retrieveBSON,\n    f = require('util').format,\n    MongoError = require('../error'),\n    getReadPreference = require('./shared').getReadPreference;\n\nvar BSON = retrieveBSON(),\n    Long = BSON.Long;\n\nvar WireProtocol = function (legacyWireProtocol) {\n  this.legacyWireProtocol = legacyWireProtocol;\n}; //\n// Execute a write operation\n\n\nvar executeWrite = function (pool, bson, type, opsField, ns, ops, options, callback) {\n  if (ops.length == 0) throw new MongoError(\"insert must contain at least one document\");\n\n  if (typeof options == 'function') {\n    callback = options;\n    options = {};\n    options = options || {};\n  } // Split the ns up to get db and collection\n\n\n  var p = ns.split(\".\");\n  var d = p.shift(); // Options\n\n  var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;\n  var writeConcern = options.writeConcern; // return skeleton\n\n  var writeCommand = {};\n  writeCommand[type] = p.join('.');\n  writeCommand[opsField] = ops;\n  writeCommand.ordered = ordered; // Did we specify a write concern\n\n  if (writeConcern && Object.keys(writeConcern).length > 0) {\n    writeCommand.writeConcern = writeConcern;\n  } // If we have collation passed in\n\n\n  if (options.collation) {\n    for (var i = 0; i < writeCommand[opsField].length; i++) {\n      if (!writeCommand[opsField][i].collation) {\n        writeCommand[opsField][i].collation = options.collation;\n      }\n    }\n  } // Do we have bypassDocumentValidation set, then enable it on the write command\n\n\n  if (typeof options.bypassDocumentValidation == 'boolean') {\n    writeCommand.bypassDocumentValidation = options.bypassDocumentValidation;\n  } // Options object\n\n\n  var opts = {\n    command: true\n  };\n  var queryOptions = {\n    checkKeys: false,\n    numberToSkip: 0,\n    numberToReturn: 1\n  };\n  if (type == 'insert') queryOptions.checkKeys = true;\n  if (typeof options.checkKeys == 'boolean') queryOptions.checkKeys = options.checkKeys; // Ensure we support serialization of functions\n\n  if (options.serializeFunctions) queryOptions.serializeFunctions = options.serializeFunctions; // Do not serialize the undefined fields\n\n  if (options.ignoreUndefined) queryOptions.ignoreUndefined = options.ignoreUndefined;\n\n  try {\n    // Create write command\n    var cmd = new Query(bson, f(\"%s.$cmd\", d), writeCommand, queryOptions); // Execute command\n\n    pool.write(cmd, opts, callback);\n  } catch (err) {\n    callback(err);\n  }\n}; //\n// Needs to support legacy mass insert as well as ordered/unordered legacy\n// emulation\n//\n\n\nWireProtocol.prototype.insert = function (pool, ismaster, ns, bson, ops, options, callback) {\n  executeWrite(pool, bson, 'insert', 'documents', ns, ops, options, callback);\n};\n\nWireProtocol.prototype.update = function (pool, ismaster, ns, bson, ops, options, callback) {\n  executeWrite(pool, bson, 'update', 'updates', ns, ops, options, callback);\n};\n\nWireProtocol.prototype.remove = function (pool, ismaster, ns, bson, ops, options, callback) {\n  executeWrite(pool, bson, 'delete', 'deletes', ns, ops, options, callback);\n};\n\nWireProtocol.prototype.killCursor = function (bson, ns, cursorId, pool, callback) {\n  // Build command namespace\n  var parts = ns.split(/\\./); // Command namespace\n\n  var commandns = f('%s.$cmd', parts.shift()); // Create getMore command\n\n  var killcursorCmd = {\n    killCursors: parts.join('.'),\n    cursors: [cursorId] // Build Query object\n\n  };\n  var query = new Query(bson, commandns, killcursorCmd, {\n    numberToSkip: 0,\n    numberToReturn: -1,\n    checkKeys: false,\n    returnFieldSelector: null\n  }); // Set query flags\n\n  query.slaveOk = true; // Kill cursor callback\n\n  var killCursorCallback = function (err, result) {\n    if (err) {\n      if (typeof callback != 'function') return;\n      return callback(err);\n    } // Result\n\n\n    var r = result.message; // If we have a timed out query or a cursor that was killed\n\n    if ((r.responseFlags & 1 << 0) != 0) {\n      if (typeof callback != 'function') return;\n      return callback(new MongoError(\"cursor killed or timed out\"), null);\n    }\n\n    if (!Array.isArray(r.documents) || r.documents.length == 0) {\n      if (typeof callback != 'function') return;\n      return callback(new MongoError(f('invalid killCursors result returned for cursor id %s', cursorId)));\n    } // Return the result\n\n\n    if (typeof callback == 'function') {\n      callback(null, r.documents[0]);\n    }\n  }; // Execute the kill cursor command\n\n\n  if (pool && pool.isConnected()) {\n    pool.write(query, {\n      command: true\n    }, killCursorCallback);\n  }\n};\n\nWireProtocol.prototype.getMore = function (bson, ns, cursorState, batchSize, raw, connection, options, callback) {\n  options = options || {}; // Build command namespace\n\n  var parts = ns.split(/\\./); // Command namespace\n\n  var commandns = f('%s.$cmd', parts.shift()); // Create getMore command\n\n  var getMoreCmd = {\n    getMore: cursorState.cursorId,\n    collection: parts.join('.'),\n    batchSize: Math.abs(batchSize)\n  };\n\n  if (cursorState.cmd.tailable && typeof cursorState.cmd.maxAwaitTimeMS == 'number') {\n    getMoreCmd.maxTimeMS = cursorState.cmd.maxAwaitTimeMS;\n  } // Build Query object\n\n\n  var query = new Query(bson, commandns, getMoreCmd, {\n    numberToSkip: 0,\n    numberToReturn: -1,\n    checkKeys: false,\n    returnFieldSelector: null\n  }); // Set query flags\n\n  query.slaveOk = true; // Query callback\n\n  var queryCallback = function (err, result) {\n    if (err) return callback(err); // Get the raw message\n\n    var r = result.message; // If we have a timed out query or a cursor that was killed\n\n    if ((r.responseFlags & 1 << 0) != 0) {\n      return callback(new MongoError(\"cursor killed or timed out\"), null);\n    } // Raw, return all the extracted documents\n\n\n    if (raw) {\n      cursorState.documents = r.documents;\n      cursorState.cursorId = r.cursorId;\n      return callback(null, r.documents);\n    } // We have an error detected\n\n\n    if (r.documents[0].ok == 0) {\n      return callback(MongoError.create(r.documents[0]));\n    } // Ensure we have a Long valid cursor id\n\n\n    var cursorId = typeof r.documents[0].cursor.id == 'number' ? Long.fromNumber(r.documents[0].cursor.id) : r.documents[0].cursor.id; // Set all the values\n\n    cursorState.documents = r.documents[0].cursor.nextBatch;\n    cursorState.cursorId = cursorId; // Return the result\n\n    callback(null, r.documents[0], r.connection);\n  }; // Query options\n\n\n  var queryOptions = {\n    command: true\n  }; // If we have a raw query decorate the function\n\n  if (raw) {\n    queryOptions.raw = raw;\n  } // Add the result field needed\n\n\n  queryOptions.documentsReturnedIn = 'nextBatch'; // Check if we need to promote longs\n\n  if (typeof cursorState.promoteLongs == 'boolean') {\n    queryOptions.promoteLongs = cursorState.promoteLongs;\n  }\n\n  if (typeof cursorState.promoteValues == 'boolean') {\n    queryOptions.promoteValues = cursorState.promoteValues;\n  }\n\n  if (typeof cursorState.promoteBuffers == 'boolean') {\n    queryOptions.promoteBuffers = cursorState.promoteBuffers;\n  } // Write out the getMore command\n\n\n  connection.write(query, queryOptions, queryCallback);\n};\n\nWireProtocol.prototype.command = function (bson, ns, cmd, cursorState, topology, options) {\n  options = options || {}; // Check if this is a wire protocol command or not\n\n  var wireProtocolCommand = typeof options.wireProtocolCommand == 'boolean' ? options.wireProtocolCommand : true; // Establish type of command\n\n  if (cmd.find && wireProtocolCommand) {\n    // Create the find command\n    var query = executeFindCommand(bson, ns, cmd, cursorState, topology, options); // Mark the cmd as virtual\n\n    cmd.virtual = false; // Signal the documents are in the firstBatch value\n\n    query.documentsReturnedIn = 'firstBatch'; // Return the query\n\n    return query;\n  } else if (cursorState.cursorId != null) {\n    return;\n  } else if (cmd) {\n    return setupCommand(bson, ns, cmd, cursorState, topology, options);\n  } else {\n    throw new MongoError(f(\"command %s does not return a cursor\", JSON.stringify(cmd)));\n  }\n}; // // Command\n// {\n//     find: ns\n//   , query: <object>\n//   , limit: <n>\n//   , fields: <object>\n//   , skip: <n>\n//   , hint: <string>\n//   , explain: <boolean>\n//   , snapshot: <boolean>\n//   , batchSize: <n>\n//   , returnKey: <boolean>\n//   , maxScan: <n>\n//   , min: <n>\n//   , max: <n>\n//   , showDiskLoc: <boolean>\n//   , comment: <string>\n//   , maxTimeMS: <n>\n//   , raw: <boolean>\n//   , readPreference: <ReadPreference>\n//   , tailable: <boolean>\n//   , oplogReplay: <boolean>\n//   , noCursorTimeout: <boolean>\n//   , awaitdata: <boolean>\n//   , exhaust: <boolean>\n//   , partial: <boolean>\n// }\n// FIND/GETMORE SPEC\n// {\n//     “find”: <string>,\n//     “filter”: { ... },\n//     “sort”: { ... },\n//     “projection”: { ... },\n//     “hint”: { ... },\n//     “skip”: <int>,\n//     “limit”: <int>,\n//     “batchSize”: <int>,\n//     “singleBatch”: <bool>,\n//     “comment”: <string>,\n//     “maxScan”: <int>,\n//     “maxTimeMS”: <int>,\n//     “max”: { ... },\n//     “min”: { ... },\n//     “returnKey”: <bool>,\n//     “showRecordId”: <bool>,\n//     “snapshot”: <bool>,\n//     “tailable”: <bool>,\n//     “oplogReplay”: <bool>,\n//     “noCursorTimeout”: <bool>,\n//     “awaitData”: <bool>,\n//     “partial”: <bool>,\n//     “$readPreference”: { ... }\n// }\n//\n// Execute a find command\n\n\nvar executeFindCommand = function (bson, ns, cmd, cursorState, topology, options) {\n  // Ensure we have at least some options\n  options = options || {}; // Get the readPreference\n\n  var readPreference = getReadPreference(cmd, options); // Set the optional batchSize\n\n  cursorState.batchSize = cmd.batchSize || cursorState.batchSize; // Build command namespace\n\n  var parts = ns.split(/\\./); // Command namespace\n\n  var commandns = f('%s.$cmd', parts.shift()); // Build actual find command\n\n  var findCmd = {\n    find: parts.join('.')\n  }; // I we provided a filter\n\n  if (cmd.query) {\n    // Check if the user is passing in the $query parameter\n    if (cmd.query['$query']) {\n      findCmd.filter = cmd.query['$query'];\n    } else {\n      findCmd.filter = cmd.query;\n    }\n  } // Sort value\n\n\n  var sortValue = cmd.sort; // Handle issue of sort being an Array\n\n  if (Array.isArray(sortValue)) {\n    var sortObject = {};\n\n    if (sortValue.length > 0 && !Array.isArray(sortValue[0])) {\n      var sortDirection = sortValue[1]; // Translate the sort order text\n\n      if (sortDirection == 'asc') {\n        sortDirection = 1;\n      } else if (sortDirection == 'desc') {\n        sortDirection = -1;\n      } // Set the sort order\n\n\n      sortObject[sortValue[0]] = sortDirection;\n    } else {\n      for (var i = 0; i < sortValue.length; i++) {\n        sortDirection = sortValue[i][1]; // Translate the sort order text\n\n        if (sortDirection == 'asc') {\n          sortDirection = 1;\n        } else if (sortDirection == 'desc') {\n          sortDirection = -1;\n        } // Set the sort order\n\n\n        sortObject[sortValue[i][0]] = sortDirection;\n      }\n    }\n\n    sortValue = sortObject;\n  } // Add sort to command\n\n\n  if (cmd.sort) findCmd.sort = sortValue; // Add a projection to the command\n\n  if (cmd.fields) findCmd.projection = cmd.fields; // Add a hint to the command\n\n  if (cmd.hint) findCmd.hint = cmd.hint; // Add a skip\n\n  if (cmd.skip) findCmd.skip = cmd.skip; // Add a limit\n\n  if (cmd.limit) findCmd.limit = cmd.limit; // Check if we wish to have a singleBatch\n\n  if (cmd.limit < 0) {\n    findCmd.limit = Math.abs(cmd.limit);\n    findCmd.singleBatch = true;\n  } // Add a batchSize\n\n\n  if (typeof cmd.batchSize == 'number') {\n    if (cmd.batchSize < 0) {\n      if (cmd.limit != 0 && Math.abs(cmd.batchSize) < Math.abs(cmd.limit)) {\n        findCmd.limit = Math.abs(cmd.batchSize);\n      }\n\n      findCmd.singleBatch = true;\n    }\n\n    findCmd.batchSize = Math.abs(cmd.batchSize);\n  } // If we have comment set\n\n\n  if (cmd.comment) findCmd.comment = cmd.comment; // If we have maxScan\n\n  if (cmd.maxScan) findCmd.maxScan = cmd.maxScan; // If we have maxTimeMS set\n\n  if (cmd.maxTimeMS) findCmd.maxTimeMS = cmd.maxTimeMS; // If we have min\n\n  if (cmd.min) findCmd.min = cmd.min; // If we have max\n\n  if (cmd.max) findCmd.max = cmd.max; // If we have returnKey set\n\n  if (cmd.returnKey) findCmd.returnKey = cmd.returnKey; // If we have showDiskLoc set\n\n  if (cmd.showDiskLoc) findCmd.showRecordId = cmd.showDiskLoc; // If we have snapshot set\n\n  if (cmd.snapshot) findCmd.snapshot = cmd.snapshot; // If we have tailable set\n\n  if (cmd.tailable) findCmd.tailable = cmd.tailable; // If we have oplogReplay set\n\n  if (cmd.oplogReplay) findCmd.oplogReplay = cmd.oplogReplay; // If we have noCursorTimeout set\n\n  if (cmd.noCursorTimeout) findCmd.noCursorTimeout = cmd.noCursorTimeout; // If we have awaitData set\n\n  if (cmd.awaitData) findCmd.awaitData = cmd.awaitData;\n  if (cmd.awaitdata) findCmd.awaitData = cmd.awaitdata; // If we have partial set\n\n  if (cmd.partial) findCmd.partial = cmd.partial; // If we have collation passed in\n\n  if (cmd.collation) findCmd.collation = cmd.collation; // If we have explain, we need to rewrite the find command\n  // to wrap it in the explain command\n\n  if (cmd.explain) {\n    findCmd = {\n      explain: findCmd\n    };\n  } // Did we provide a readConcern\n\n\n  if (cmd.readConcern) findCmd.readConcern = cmd.readConcern; // Set up the serialize and ignoreUndefined fields\n\n  var serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;\n  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false; // We have a Mongos topology, check if we need to add a readPreference\n\n  if (topology.type == 'mongos' && readPreference && readPreference.preference != 'primary') {\n    findCmd = {\n      '$query': findCmd,\n      '$readPreference': readPreference.toJSON()\n    };\n  } // Build Query object\n\n\n  var query = new Query(bson, commandns, findCmd, {\n    numberToSkip: 0,\n    numberToReturn: 1,\n    checkKeys: false,\n    returnFieldSelector: null,\n    serializeFunctions: serializeFunctions,\n    ignoreUndefined: ignoreUndefined\n  }); // Set query flags\n\n  query.slaveOk = readPreference.slaveOk(); // Return the query\n\n  return query;\n}; //\n// Set up a command cursor\n\n\nvar setupCommand = function (bson, ns, cmd, cursorState, topology, options) {\n  // Set empty options object\n  options = options || {}; // Get the readPreference\n\n  var readPreference = getReadPreference(cmd, options); // Final query\n\n  var finalCmd = {};\n\n  for (var name in cmd) {\n    finalCmd[name] = cmd[name];\n  } // Build command namespace\n\n\n  var parts = ns.split(/\\./); // Serialize functions\n\n  var serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false; // Set up the serialize and ignoreUndefined fields\n\n  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false; // We have a Mongos topology, check if we need to add a readPreference\n\n  if (topology.type == 'mongos' && readPreference && readPreference.preference != 'primary') {\n    finalCmd = {\n      '$query': finalCmd,\n      '$readPreference': readPreference.toJSON()\n    };\n  } // Build Query object\n\n\n  var query = new Query(bson, f('%s.$cmd', parts.shift()), finalCmd, {\n    numberToSkip: 0,\n    numberToReturn: -1,\n    checkKeys: false,\n    serializeFunctions: serializeFunctions,\n    ignoreUndefined: ignoreUndefined\n  }); // Set query flags\n\n  query.slaveOk = readPreference.slaveOk(); // Return the query\n\n  return query;\n};\n\nmodule.exports = WireProtocol;","map":null,"metadata":{},"sourceType":"script"}