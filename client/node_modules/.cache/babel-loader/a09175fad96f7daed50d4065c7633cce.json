{"ast":null,"code":"\"use strict\";\n\nvar Long = require('mongodb-core').BSON.Long,\n    Timestamp = require('mongodb-core').BSON.Timestamp; // Error codes\n\n\nvar UNKNOWN_ERROR = 8;\nvar INVALID_BSON_ERROR = 22;\nvar WRITE_CONCERN_ERROR = 64;\nvar MULTIPLE_ERROR = 65; // Insert types\n\nvar INSERT = 1;\nvar UPDATE = 2;\nvar REMOVE = 3; // Get write concern\n\nvar writeConcern = function (target, col, options) {\n  var writeConcern = {}; // Collection level write concern\n\n  if (col.writeConcern && col.writeConcern.w != null) writeConcern.w = col.writeConcern.w;\n  if (col.writeConcern && col.writeConcern.j != null) writeConcern.j = col.writeConcern.j;\n  if (col.writeConcern && col.writeConcern.fsync != null) writeConcern.fsync = col.writeConcern.fsync;\n  if (col.writeConcern && col.writeConcern.wtimeout != null) writeConcern.wtimeout = col.writeConcern.wtimeout; // Options level write concern\n\n  if (options && options.w != null) writeConcern.w = options.w;\n  if (options && options.wtimeout != null) writeConcern.wtimeout = options.wtimeout;\n  if (options && options.j != null) writeConcern.j = options.j;\n  if (options && options.fsync != null) writeConcern.fsync = options.fsync; // Return write concern\n\n  return writeConcern;\n};\n/**\n * Helper function to define properties\n * @ignore\n */\n\n\nvar defineReadOnlyProperty = function (self, name, value) {\n  Object.defineProperty(self, name, {\n    enumerable: true,\n    get: function () {\n      return value;\n    }\n  });\n};\n/**\n * Keeps the state of a unordered batch so we can rewrite the results\n * correctly after command execution\n * @ignore\n */\n\n\nvar Batch = function (batchType, originalZeroIndex) {\n  this.originalZeroIndex = originalZeroIndex;\n  this.currentIndex = 0;\n  this.originalIndexes = [];\n  this.batchType = batchType;\n  this.operations = [];\n  this.size = 0;\n  this.sizeBytes = 0;\n};\n/**\n * Wraps a legacy operation so we can correctly rewrite it's error\n * @ignore\n */\n\n\nvar LegacyOp = function (batchType, operation, index) {\n  this.batchType = batchType;\n  this.index = index;\n  this.operation = operation;\n};\n/**\n * Create a new BulkWriteResult instance (INTERNAL TYPE, do not instantiate directly)\n *\n * @class\n * @property {boolean} ok Did bulk operation correctly execute\n * @property {number} nInserted number of inserted documents\n * @property {number} nUpdated number of documents updated logically\n * @property {number} nUpserted Number of upserted documents\n * @property {number} nModified Number of documents updated physically on disk\n * @property {number} nRemoved Number of removed documents\n * @return {BulkWriteResult} a BulkWriteResult instance\n */\n\n\nvar BulkWriteResult = function (bulkResult) {\n  defineReadOnlyProperty(this, \"ok\", bulkResult.ok);\n  defineReadOnlyProperty(this, \"nInserted\", bulkResult.nInserted);\n  defineReadOnlyProperty(this, \"nUpserted\", bulkResult.nUpserted);\n  defineReadOnlyProperty(this, \"nMatched\", bulkResult.nMatched);\n  defineReadOnlyProperty(this, \"nModified\", bulkResult.nModified);\n  defineReadOnlyProperty(this, \"nRemoved\", bulkResult.nRemoved);\n  /**\n   * Return an array of inserted ids\n   *\n   * @return {object[]}\n   */\n\n  this.getInsertedIds = function () {\n    return bulkResult.insertedIds;\n  };\n  /**\n   * Return an array of upserted ids\n   *\n   * @return {object[]}\n   */\n\n\n  this.getUpsertedIds = function () {\n    return bulkResult.upserted;\n  };\n  /**\n   * Return the upserted id at position x\n   *\n   * @param {number} index the number of the upserted id to return, returns undefined if no result for passed in index\n   * @return {object}\n   */\n\n\n  this.getUpsertedIdAt = function (index) {\n    return bulkResult.upserted[index];\n  };\n  /**\n   * Return raw internal result\n   *\n   * @return {object}\n   */\n\n\n  this.getRawResponse = function () {\n    return bulkResult;\n  };\n  /**\n   * Returns true if the bulk operation contains a write error\n   *\n   * @return {boolean}\n   */\n\n\n  this.hasWriteErrors = function () {\n    return bulkResult.writeErrors.length > 0;\n  };\n  /**\n   * Returns the number of write errors off the bulk operation\n   *\n   * @return {number}\n   */\n\n\n  this.getWriteErrorCount = function () {\n    return bulkResult.writeErrors.length;\n  };\n  /**\n   * Returns a specific write error object\n   *\n   * @param {number} index of the write error to return, returns null if there is no result for passed in index\n   * @return {WriteError}\n   */\n\n\n  this.getWriteErrorAt = function (index) {\n    if (index < bulkResult.writeErrors.length) {\n      return bulkResult.writeErrors[index];\n    }\n\n    return null;\n  };\n  /**\n   * Retrieve all write errors\n   *\n   * @return {object[]}\n   */\n\n\n  this.getWriteErrors = function () {\n    return bulkResult.writeErrors;\n  };\n  /**\n   * Retrieve lastOp if available\n   *\n   * @return {object}\n   */\n\n\n  this.getLastOp = function () {\n    return bulkResult.lastOp;\n  };\n  /**\n   * Retrieve the write concern error if any\n   *\n   * @return {WriteConcernError}\n   */\n\n\n  this.getWriteConcernError = function () {\n    if (bulkResult.writeConcernErrors.length == 0) {\n      return null;\n    } else if (bulkResult.writeConcernErrors.length == 1) {\n      // Return the error\n      return bulkResult.writeConcernErrors[0];\n    } else {\n      // Combine the errors\n      var errmsg = \"\";\n\n      for (var i = 0; i < bulkResult.writeConcernErrors.length; i++) {\n        var err = bulkResult.writeConcernErrors[i];\n        errmsg = errmsg + err.errmsg; // TODO: Something better\n\n        if (i == 0) errmsg = errmsg + \" and \";\n      }\n\n      return new WriteConcernError({\n        errmsg: errmsg,\n        code: WRITE_CONCERN_ERROR\n      });\n    }\n  };\n\n  this.toJSON = function () {\n    return bulkResult;\n  };\n\n  this.toString = function () {\n    return \"BulkWriteResult(\" + this.toJSON(bulkResult) + \")\";\n  };\n\n  this.isOk = function () {\n    return bulkResult.ok == 1;\n  };\n};\n/**\n * Create a new WriteConcernError instance (INTERNAL TYPE, do not instantiate directly)\n *\n * @class\n * @property {number} code Write concern error code.\n * @property {string} errmsg Write concern error message.\n * @return {WriteConcernError} a WriteConcernError instance\n */\n\n\nvar WriteConcernError = function (err) {\n  if (!(this instanceof WriteConcernError)) return new WriteConcernError(err); // Define properties\n\n  defineReadOnlyProperty(this, \"code\", err.code);\n  defineReadOnlyProperty(this, \"errmsg\", err.errmsg);\n\n  this.toJSON = function () {\n    return {\n      code: err.code,\n      errmsg: err.errmsg\n    };\n  };\n\n  this.toString = function () {\n    return \"WriteConcernError(\" + err.errmsg + \")\";\n  };\n};\n/**\n * Create a new WriteError instance (INTERNAL TYPE, do not instantiate directly)\n *\n * @class\n * @property {number} code Write concern error code.\n * @property {number} index Write concern error original bulk operation index.\n * @property {string} errmsg Write concern error message.\n * @return {WriteConcernError} a WriteConcernError instance\n */\n\n\nvar WriteError = function (err) {\n  if (!(this instanceof WriteError)) return new WriteError(err); // Define properties\n\n  defineReadOnlyProperty(this, \"code\", err.code);\n  defineReadOnlyProperty(this, \"index\", err.index);\n  defineReadOnlyProperty(this, \"errmsg\", err.errmsg); //\n  // Define access methods\n\n  this.getOperation = function () {\n    return err.op;\n  };\n\n  this.toJSON = function () {\n    return {\n      code: err.code,\n      index: err.index,\n      errmsg: err.errmsg,\n      op: err.op\n    };\n  };\n\n  this.toString = function () {\n    return \"WriteError(\" + JSON.stringify(this.toJSON()) + \")\";\n  };\n};\n/**\n * Merges results into shared data structure\n * @ignore\n */\n\n\nvar mergeBatchResults = function (ordered, batch, bulkResult, err, result) {\n  // If we have an error set the result to be the err object\n  if (err) {\n    result = err;\n  } else if (result && result.result) {\n    result = result.result;\n  } else if (result == null) {\n    return;\n  } // Do we have a top level error stop processing and return\n\n\n  if (result.ok == 0 && bulkResult.ok == 1) {\n    bulkResult.ok = 0;\n    var writeError = {\n      index: 0,\n      code: result.code || 0,\n      errmsg: result.message,\n      op: batch.operations[0]\n    };\n    bulkResult.writeErrors.push(new WriteError(writeError));\n    return;\n  } else if (result.ok == 0 && bulkResult.ok == 0) {\n    return;\n  } // Deal with opTime if available\n\n\n  if (result.opTime || result.lastOp) {\n    var opTime = result.lastOp || result.opTime;\n    var lastOpTS = null;\n    var lastOpT = null; // We have a time stamp\n\n    if (opTime && opTime._bsontype == 'Timestamp') {\n      if (bulkResult.lastOp == null) {\n        bulkResult.lastOp = opTime;\n      } else if (opTime.greaterThan(bulkResult.lastOp)) {\n        bulkResult.lastOp = opTime;\n      }\n    } else {\n      // Existing TS\n      if (bulkResult.lastOp) {\n        lastOpTS = typeof bulkResult.lastOp.ts == 'number' ? Long.fromNumber(bulkResult.lastOp.ts) : bulkResult.lastOp.ts;\n        lastOpT = typeof bulkResult.lastOp.t == 'number' ? Long.fromNumber(bulkResult.lastOp.t) : bulkResult.lastOp.t;\n      } // Current OpTime TS\n\n\n      var opTimeTS = typeof opTime.ts == 'number' ? Long.fromNumber(opTime.ts) : opTime.ts;\n      var opTimeT = typeof opTime.t == 'number' ? Long.fromNumber(opTime.t) : opTime.t; // Compare the opTime's\n\n      if (bulkResult.lastOp == null) {\n        bulkResult.lastOp = opTime;\n      } else if (opTimeTS.greaterThan(lastOpTS)) {\n        bulkResult.lastOp = opTime;\n      } else if (opTimeTS.equals(lastOpTS)) {\n        if (opTimeT.greaterThan(lastOpT)) {\n          bulkResult.lastOp = opTime;\n        }\n      }\n    }\n  } // If we have an insert Batch type\n\n\n  if (batch.batchType == INSERT && result.n) {\n    bulkResult.nInserted = bulkResult.nInserted + result.n;\n  } // If we have an insert Batch type\n\n\n  if (batch.batchType == REMOVE && result.n) {\n    bulkResult.nRemoved = bulkResult.nRemoved + result.n;\n  }\n\n  var nUpserted = 0; // We have an array of upserted values, we need to rewrite the indexes\n\n  if (Array.isArray(result.upserted)) {\n    nUpserted = result.upserted.length;\n\n    for (var i = 0; i < result.upserted.length; i++) {\n      bulkResult.upserted.push({\n        index: result.upserted[i].index + batch.originalZeroIndex,\n        _id: result.upserted[i]._id\n      });\n    }\n  } else if (result.upserted) {\n    nUpserted = 1;\n    bulkResult.upserted.push({\n      index: batch.originalZeroIndex,\n      _id: result.upserted\n    });\n  } // If we have an update Batch type\n\n\n  if (batch.batchType == UPDATE && result.n) {\n    var nModified = result.nModified;\n    bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;\n    bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);\n\n    if (typeof nModified == 'number') {\n      bulkResult.nModified = bulkResult.nModified + nModified;\n    } else {\n      bulkResult.nModified = null;\n    }\n  }\n\n  if (Array.isArray(result.writeErrors)) {\n    for (i = 0; i < result.writeErrors.length; i++) {\n      writeError = {\n        index: batch.originalZeroIndex + result.writeErrors[i].index,\n        code: result.writeErrors[i].code,\n        errmsg: result.writeErrors[i].errmsg,\n        op: batch.operations[result.writeErrors[i].index]\n      };\n      bulkResult.writeErrors.push(new WriteError(writeError));\n    }\n  }\n\n  if (result.writeConcernError) {\n    bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));\n  }\n}; //\n// Clone the options\n\n\nvar cloneOptions = function (options) {\n  var clone = {};\n  var keys = Object.keys(options);\n\n  for (var i = 0; i < keys.length; i++) {\n    clone[keys[i]] = options[keys[i]];\n  }\n\n  return clone;\n}; // Exports symbols\n\n\nexports.BulkWriteResult = BulkWriteResult;\nexports.WriteError = WriteError;\nexports.Batch = Batch;\nexports.LegacyOp = LegacyOp;\nexports.mergeBatchResults = mergeBatchResults;\nexports.cloneOptions = cloneOptions;\nexports.writeConcern = writeConcern;\nexports.INVALID_BSON_ERROR = INVALID_BSON_ERROR;\nexports.WRITE_CONCERN_ERROR = WRITE_CONCERN_ERROR;\nexports.MULTIPLE_ERROR = MULTIPLE_ERROR;\nexports.UNKNOWN_ERROR = UNKNOWN_ERROR;\nexports.INSERT = INSERT;\nexports.UPDATE = UPDATE;\nexports.REMOVE = REMOVE;","map":null,"metadata":{},"sourceType":"script"}