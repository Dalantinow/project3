{"ast":null,"code":"\"use strict\";\n\nvar inherits = require('util').inherits,\n    EventEmitter = require('events').EventEmitter,\n    net = require('net'),\n    tls = require('tls'),\n    crypto = require('crypto'),\n    f = require('util').format,\n    debugOptions = require('./utils').debugOptions,\n    Response = require('./commands').Response,\n    MongoError = require('../error'),\n    Logger = require('./logger');\n\nvar _id = 0;\nvar debugFields = ['host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'socketTimeout', 'singleBufferSerializtion', 'ssl', 'ca', 'crl', 'cert', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'checkServerIdentity'];\nvar connectionAccounting = false;\nvar connections = {};\n/**\n * Creates a new Connection instance\n * @class\n * @param {string} options.host The server host\n * @param {number} options.port The server port\n * @param {number} [options.family=null] IP version for DNS lookup, passed down to Node's [`dns.lookup()` function](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback). If set to `6`, will only look for ipv6 addresses.\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=300000] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=360000] TCP Socket timeout setting\n * @param {boolean} [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @fires Connection#connect\n * @fires Connection#close\n * @fires Connection#error\n * @fires Connection#timeout\n * @fires Connection#parseError\n * @return {Connection} A cursor instance\n */\n\nvar Connection = function (messageHandler, options) {\n  // Add event listener\n  EventEmitter.call(this); // Set empty if no options passed\n\n  this.options = options || {}; // Identification information\n\n  this.id = _id++; // Logger instance\n\n  this.logger = Logger('Connection', options); // No bson parser passed in\n\n  if (!options.bson) throw new Error(\"must pass in valid bson parser\"); // Get bson parser\n\n  this.bson = options.bson; // Grouping tag used for debugging purposes\n\n  this.tag = options.tag; // Message handler\n\n  this.messageHandler = messageHandler; // Max BSON message size\n\n  this.maxBsonMessageSize = options.maxBsonMessageSize || 1024 * 1024 * 16 * 4; // Debug information\n\n  if (this.logger.isDebug()) this.logger.debug(f('creating connection %s with options [%s]', this.id, JSON.stringify(debugOptions(debugFields, options)))); // Default options\n\n  this.port = options.port || 27017;\n  this.host = options.host || 'localhost';\n  this.family = typeof options.family == 'number' ? options.family : void 0;\n  this.keepAlive = typeof options.keepAlive == 'boolean' ? options.keepAlive : true;\n  this.keepAliveInitialDelay = typeof options.keepAliveInitialDelay == 'number' ? options.keepAliveInitialDelay : 300000;\n  this.noDelay = typeof options.noDelay == 'boolean' ? options.noDelay : true;\n  this.connectionTimeout = typeof options.connectionTimeout == 'number' ? options.connectionTimeout : 30000;\n  this.socketTimeout = typeof options.socketTimeout == 'number' ? options.socketTimeout : 360000; // Is the keepAliveInitialDelay > socketTimeout set it to half of socketTimeout\n\n  if (this.keepAliveInitialDelay > this.socketTimeout) {\n    this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);\n  } // If connection was destroyed\n\n\n  this.destroyed = false; // Check if we have a domain socket\n\n  this.domainSocket = this.host.indexOf('\\/') != -1; // Serialize commands using function\n\n  this.singleBufferSerializtion = typeof options.singleBufferSerializtion == 'boolean' ? options.singleBufferSerializtion : true;\n  this.serializationFunction = this.singleBufferSerializtion ? 'toBinUnified' : 'toBin'; // SSL options\n\n  this.ca = options.ca || null;\n  this.crl = options.crl || null;\n  this.cert = options.cert || null;\n  this.key = options.key || null;\n  this.passphrase = options.passphrase || null;\n  this.ciphers = options.ciphers || null;\n  this.ecdhCurve = options.ecdhCurve || null;\n  this.ssl = typeof options.ssl == 'boolean' ? options.ssl : false;\n  this.rejectUnauthorized = typeof options.rejectUnauthorized == 'boolean' ? options.rejectUnauthorized : true;\n  this.checkServerIdentity = typeof options.checkServerIdentity == 'boolean' || typeof options.checkServerIdentity == 'function' ? options.checkServerIdentity : true; // If ssl not enabled\n\n  if (!this.ssl) this.rejectUnauthorized = false; // Response options\n\n  this.responseOptions = {\n    promoteLongs: typeof options.promoteLongs == 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues == 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers == 'boolean' ? options.promoteBuffers : false // Flushing\n\n  };\n  this.flushing = false;\n  this.queue = []; // Internal state\n\n  this.connection = null;\n  this.writeStream = null; // Create hash method\n\n  var hash = crypto.createHash('sha1');\n  hash.update(f('%s:%s', this.host, this.port)); // Create a hash name\n\n  this.hashedName = hash.digest('hex'); // All operations in flight on the connection\n\n  this.workItems = [];\n};\n\ninherits(Connection, EventEmitter);\n\nConnection.prototype.setSocketTimeout = function (value) {\n  if (this.connection) {\n    this.connection.setTimeout(value);\n  }\n};\n\nConnection.prototype.resetSocketTimeout = function () {\n  if (this.connection) {\n    this.connection.setTimeout(this.socketTimeout);\n  }\n};\n\nConnection.enableConnectionAccounting = function () {\n  connectionAccounting = true;\n  connections = {};\n};\n\nConnection.disableConnectionAccounting = function () {\n  connectionAccounting = false;\n};\n\nConnection.connections = function () {\n  return connections;\n};\n\nfunction deleteConnection(id) {\n  // console.log(\"=== deleted connection \" + id + \" :: \" + (connections[id] ? connections[id].port : ''))\n  delete connections[id];\n}\n\nfunction addConnection(id, connection) {\n  // console.log(\"=== added connection \" + id + \" :: \" + connection.port)\n  connections[id] = connection;\n} //\n// Connection handlers\n\n\nvar errorHandler = function (self) {\n  return function (err) {\n    if (connectionAccounting) deleteConnection(self.id); // Debug information\n\n    if (self.logger.isDebug()) self.logger.debug(f('connection %s for [%s:%s] errored out with [%s]', self.id, self.host, self.port, JSON.stringify(err))); // Emit the error\n\n    if (self.listeners('error').length > 0) self.emit(\"error\", MongoError.create(err), self);\n  };\n};\n\nvar timeoutHandler = function (self) {\n  return function () {\n    if (connectionAccounting) deleteConnection(self.id); // Debug information\n\n    if (self.logger.isDebug()) self.logger.debug(f('connection %s for [%s:%s] timed out', self.id, self.host, self.port)); // Emit timeout error\n\n    self.emit(\"timeout\", MongoError.create(f(\"connection %s to %s:%s timed out\", self.id, self.host, self.port)), self);\n  };\n};\n\nvar closeHandler = function (self) {\n  return function (hadError) {\n    if (connectionAccounting) deleteConnection(self.id); // Debug information\n\n    if (self.logger.isDebug()) self.logger.debug(f('connection %s with for [%s:%s] closed', self.id, self.host, self.port)); // Emit close event\n\n    if (!hadError) {\n      self.emit(\"close\", MongoError.create(f(\"connection %s to %s:%s closed\", self.id, self.host, self.port)), self);\n    }\n  };\n};\n\nvar dataHandler = function (self) {\n  return function (data) {\n    // Parse until we are done with the data\n    while (data.length > 0) {\n      // If we still have bytes to read on the current message\n      if (self.bytesRead > 0 && self.sizeOfMessage > 0) {\n        // Calculate the amount of remaining bytes\n        var remainingBytesToRead = self.sizeOfMessage - self.bytesRead; // Check if the current chunk contains the rest of the message\n\n        if (remainingBytesToRead > data.length) {\n          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)\n          data.copy(self.buffer, self.bytesRead); // Adjust the number of bytes read so it point to the correct index in the buffer\n\n          self.bytesRead = self.bytesRead + data.length; // Reset state of buffer\n\n          data = new Buffer(0);\n        } else {\n          // Copy the missing part of the data into our current buffer\n          data.copy(self.buffer, self.bytesRead, 0, remainingBytesToRead); // Slice the overflow into a new buffer that we will then re-parse\n\n          data = data.slice(remainingBytesToRead); // Emit current complete message\n\n          try {\n            var emitBuffer = self.buffer; // Reset state of buffer\n\n            self.buffer = null;\n            self.sizeOfMessage = 0;\n            self.bytesRead = 0;\n            self.stubBuffer = null; // Emit the buffer\n\n            self.messageHandler(new Response(self.bson, emitBuffer, self.responseOptions), self);\n          } catch (err) {\n            var errorObject = {\n              err: \"socketHandler\",\n              trace: err,\n              bin: self.buffer,\n              parseState: {\n                sizeOfMessage: self.sizeOfMessage,\n                bytesRead: self.bytesRead,\n                stubBuffer: self.stubBuffer\n              }\n            }; // We got a parse Error fire it off then keep going\n\n            self.emit(\"parseError\", errorObject, self);\n          }\n        }\n      } else {\n        // Stub buffer is kept in case we don't get enough bytes to determine the\n        // size of the message (< 4 bytes)\n        if (self.stubBuffer != null && self.stubBuffer.length > 0) {\n          // If we have enough bytes to determine the message size let's do it\n          if (self.stubBuffer.length + data.length > 4) {\n            // Prepad the data\n            var newData = new Buffer(self.stubBuffer.length + data.length);\n            self.stubBuffer.copy(newData, 0);\n            data.copy(newData, self.stubBuffer.length); // Reassign for parsing\n\n            data = newData; // Reset state of buffer\n\n            self.buffer = null;\n            self.sizeOfMessage = 0;\n            self.bytesRead = 0;\n            self.stubBuffer = null;\n          } else {\n            // Add the the bytes to the stub buffer\n            var newStubBuffer = new Buffer(self.stubBuffer.length + data.length); // Copy existing stub buffer\n\n            self.stubBuffer.copy(newStubBuffer, 0); // Copy missing part of the data\n\n            data.copy(newStubBuffer, self.stubBuffer.length); // Exit parsing loop\n\n            data = new Buffer(0);\n          }\n        } else {\n          if (data.length > 4) {\n            // Retrieve the message size\n            // var sizeOfMessage = data.readUInt32LE(0);\n            var sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24; // If we have a negative sizeOfMessage emit error and return\n\n            if (sizeOfMessage < 0 || sizeOfMessage > self.maxBsonMessageSize) {\n              errorObject = {\n                err: \"socketHandler\",\n                trace: '',\n                bin: self.buffer,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: self.bytesRead,\n                  stubBuffer: self.stubBuffer\n                }\n              }; // We got a parse Error fire it off then keep going\n\n              self.emit(\"parseError\", errorObject, self);\n              return;\n            } // Ensure that the size of message is larger than 0 and less than the max allowed\n\n\n            if (sizeOfMessage > 4 && sizeOfMessage < self.maxBsonMessageSize && sizeOfMessage > data.length) {\n              self.buffer = new Buffer(sizeOfMessage); // Copy all the data into the buffer\n\n              data.copy(self.buffer, 0); // Update bytes read\n\n              self.bytesRead = data.length; // Update sizeOfMessage\n\n              self.sizeOfMessage = sizeOfMessage; // Ensure stub buffer is null\n\n              self.stubBuffer = null; // Exit parsing loop\n\n              data = new Buffer(0);\n            } else if (sizeOfMessage > 4 && sizeOfMessage < self.maxBsonMessageSize && sizeOfMessage == data.length) {\n              try {\n                emitBuffer = data; // Reset state of buffer\n\n                self.buffer = null;\n                self.sizeOfMessage = 0;\n                self.bytesRead = 0;\n                self.stubBuffer = null; // Exit parsing loop\n\n                data = new Buffer(0); // Emit the message\n\n                self.messageHandler(new Response(self.bson, emitBuffer, self.responseOptions), self);\n              } catch (err) {\n                self.emit(\"parseError\", err, self);\n              }\n            } else if (sizeOfMessage <= 4 || sizeOfMessage > self.maxBsonMessageSize) {\n              errorObject = {\n                err: \"socketHandler\",\n                trace: null,\n                bin: data,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: 0,\n                  buffer: null,\n                  stubBuffer: null\n                }\n              }; // We got a parse Error fire it off then keep going\n\n              self.emit(\"parseError\", errorObject, self); // Clear out the state of the parser\n\n              self.buffer = null;\n              self.sizeOfMessage = 0;\n              self.bytesRead = 0;\n              self.stubBuffer = null; // Exit parsing loop\n\n              data = new Buffer(0);\n            } else {\n              emitBuffer = data.slice(0, sizeOfMessage); // Reset state of buffer\n\n              self.buffer = null;\n              self.sizeOfMessage = 0;\n              self.bytesRead = 0;\n              self.stubBuffer = null; // Copy rest of message\n\n              data = data.slice(sizeOfMessage); // Emit the message\n\n              self.messageHandler(new Response(self.bson, emitBuffer, self.responseOptions), self);\n            }\n          } else {\n            // Create a buffer that contains the space for the non-complete message\n            self.stubBuffer = new Buffer(data.length); // Copy the data to the stub buffer\n\n            data.copy(self.stubBuffer, 0); // Exit parsing loop\n\n            data = new Buffer(0);\n          }\n        }\n      }\n    }\n  };\n}; // List of socket level valid ssl options\n\n\nvar legalSslSocketOptions = ['pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers', 'NPNProtocols', 'ALPNProtocols', 'servername', 'ecdhCurve', 'secureProtocol', 'secureContext', 'session', 'minDHSize'];\n\nfunction merge(options1, options2) {\n  // Merge in any allowed ssl options\n  for (var name in options2) {\n    if (options2[name] != null && legalSslSocketOptions.indexOf(name) != -1) {\n      options1[name] = options2[name];\n    }\n  }\n}\n/**\n * Connect\n * @method\n */\n\n\nConnection.prototype.connect = function (_options) {\n  var self = this;\n  _options = _options || {}; // Set the connections\n\n  if (connectionAccounting) addConnection(this.id, this); // Check if we are overriding the promoteLongs\n\n  if (typeof _options.promoteLongs == 'boolean') {\n    self.responseOptions.promoteLongs = _options.promoteLongs;\n    self.responseOptions.promoteValues = _options.promoteValues;\n    self.responseOptions.promoteBuffers = _options.promoteBuffers;\n  } // Create new connection instance\n\n\n  var connection_options;\n\n  if (self.domainSocket) {\n    connection_options = {\n      path: self.host\n    };\n  } else {\n    connection_options = {\n      port: self.port,\n      host: self.host\n    };\n\n    if (self.family !== void 0) {\n      connection_options.family = self.family;\n    }\n  }\n\n  self.connection = net.createConnection(connection_options); // Set the options for the connection\n\n  self.connection.setKeepAlive(self.keepAlive, self.keepAliveInitialDelay);\n  self.connection.setTimeout(self.connectionTimeout);\n  self.connection.setNoDelay(self.noDelay); // If we have ssl enabled\n\n  if (self.ssl) {\n    var sslOptions = {\n      socket: self.connection,\n      rejectUnauthorized: self.rejectUnauthorized // Merge in options\n\n    };\n    merge(sslOptions, this.options);\n    merge(sslOptions, _options); // Set options for ssl\n\n    if (self.ca) sslOptions.ca = self.ca;\n    if (self.crl) sslOptions.crl = self.crl;\n    if (self.cert) sslOptions.cert = self.cert;\n    if (self.key) sslOptions.key = self.key;\n    if (self.passphrase) sslOptions.passphrase = self.passphrase; // Override checkServerIdentity behavior\n\n    if (self.checkServerIdentity == false) {\n      // Skip the identiy check by retuning undefined as per node documents\n      // https://nodejs.org/api/tls.html#tls_tls_connect_options_callback\n      sslOptions.checkServerIdentity = function () {\n        return undefined;\n      };\n    } else if (typeof self.checkServerIdentity == 'function') {\n      sslOptions.checkServerIdentity = self.checkServerIdentity;\n    } // Set default sni servername to be the same as host\n\n\n    if (sslOptions.servername == null) {\n      sslOptions.servername = self.host;\n    } // Attempt SSL connection\n\n\n    self.connection = tls.connect(self.port, self.host, sslOptions, function () {\n      // Error on auth or skip\n      if (self.connection.authorizationError && self.rejectUnauthorized) {\n        return self.emit(\"error\", self.connection.authorizationError, self, {\n          ssl: true\n        });\n      } // Set socket timeout instead of connection timeout\n\n\n      self.connection.setTimeout(self.socketTimeout); // We are done emit connect\n\n      self.emit('connect', self);\n    });\n    self.connection.setTimeout(self.connectionTimeout);\n  } else {\n    self.connection.once('connect', function () {\n      // Set socket timeout instead of connection timeout\n      self.connection.setTimeout(self.socketTimeout); // Emit connect event\n\n      self.emit('connect', self);\n    });\n  } // Add handlers for events\n\n\n  self.connection.once('error', errorHandler(self));\n  self.connection.once('timeout', timeoutHandler(self));\n  self.connection.once('close', closeHandler(self));\n  self.connection.on('data', dataHandler(self));\n};\n/**\n * Unref this connection\n * @method\n * @return {boolean}\n */\n\n\nConnection.prototype.unref = function () {\n  if (this.connection) this.connection.unref();else {\n    var self = this;\n    this.once('connect', function () {\n      self.connection.unref();\n    });\n  }\n};\n/**\n * Destroy connection\n * @method\n */\n\n\nConnection.prototype.destroy = function () {\n  // Set the connections\n  if (connectionAccounting) deleteConnection(this.id);\n\n  if (this.connection) {\n    // Catch posssible exception thrown by node 0.10.x\n    try {\n      this.connection.end();\n    } catch (err) {} // Destroy connection\n\n\n    this.connection.destroy();\n  }\n\n  this.destroyed = true;\n};\n/**\n * Write to connection\n * @method\n * @param {Command} command Command to write out need to implement toBin and toBinUnified\n */\n\n\nConnection.prototype.write = function (buffer) {\n  var i; // Debug Log\n\n  if (this.logger.isDebug()) {\n    if (!Array.isArray(buffer)) {\n      this.logger.debug(f('writing buffer [%s] to %s:%s', buffer.toString('hex'), this.host, this.port));\n    } else {\n      for (i = 0; i < buffer.length; i++) this.logger.debug(f('writing buffer [%s] to %s:%s', buffer[i].toString('hex'), this.host, this.port));\n    }\n  } // Double check that the connection is not destroyed\n\n\n  if (this.connection.destroyed === false) {\n    // Write out the command\n    if (!Array.isArray(buffer)) {\n      this.connection.write(buffer, 'binary');\n      return true;\n    } // Iterate over all buffers and write them in order to the socket\n\n\n    for (i = 0; i < buffer.length; i++) this.connection.write(buffer[i], 'binary');\n\n    return true;\n  } // Connection is destroyed return write failed\n\n\n  return false;\n};\n/**\n * Return id of connection as a string\n * @method\n * @return {string}\n */\n\n\nConnection.prototype.toString = function () {\n  return \"\" + this.id;\n};\n/**\n * Return json object of connection\n * @method\n * @return {object}\n */\n\n\nConnection.prototype.toJSON = function () {\n  return {\n    id: this.id,\n    host: this.host,\n    port: this.port\n  };\n};\n/**\n * Is the connection connected\n * @method\n * @return {boolean}\n */\n\n\nConnection.prototype.isConnected = function () {\n  if (this.destroyed) return false;\n  return !this.connection.destroyed && this.connection.writable;\n};\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Connection#connect\n * @type {Connection}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Connection#close\n * @type {Connection}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Connection#error\n * @type {Connection}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Connection#timeout\n * @type {Connection}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Connection#parseError\n * @type {Connection}\n */\n\n\nmodule.exports = Connection;","map":null,"metadata":{},"sourceType":"script"}