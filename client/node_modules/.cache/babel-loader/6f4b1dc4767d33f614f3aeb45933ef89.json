{"ast":null,"code":"\"use strict\";\n\nvar toError = require('./utils').toError,\n    Define = require('./metadata'),\n    shallowClone = require('./utils').shallowClone,\n    assign = require('./utils').assign,\n    authenticate = require('./authenticate');\n/**\n * @fileOverview The **Admin** class is an internal class that allows convenient access to\n * the admin functionality and commands for MongoDB.\n *\n * **ADMIN Cannot directly be instantiated**\n * @example\n * var MongoClient = require('mongodb').MongoClient,\n *   test = require('assert');\n * // Connection url\n * var url = 'mongodb://localhost:27017/test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, db) {\n *   // Use the admin database for the operation\n *   var adminDb = db.admin();\n *\n *   // List all the available databases\n *   adminDb.listDatabases(function(err, dbs) {\n *     test.equal(null, err);\n *     test.ok(dbs.databases.length > 0);\n *     db.close();\n *   });\n * });\n */\n\n/**\n * Create a new Admin instance (INTERNAL TYPE, do not instantiate directly)\n * @class\n * @return {Admin} a collection instance.\n */\n\n\nvar Admin = function (db, topology, promiseLibrary) {\n  if (!(this instanceof Admin)) return new Admin(db, topology); // Internal state\n\n  this.s = {\n    db: db,\n    topology: topology,\n    promiseLibrary: promiseLibrary\n  };\n};\n\nvar define = Admin.define = new Define('Admin', Admin, false);\n/**\n * The callback format for results\n * @callback Admin~resultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {object} result The result object if the command was executed successfully.\n */\n\n/**\n * Execute a command\n * @method\n * @param {object} command The command hash\n * @param {object} [options=null] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {number} [options.maxTimeMS=null] Number of milliseconds to wait before aborting the query.\n * @param {Admin~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nAdmin.prototype.command = function (command, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  if (typeof callback != 'function') args.push(callback);\n  options = args.length ? args.shift() : {}; // Execute using callback\n\n  if (typeof callback == 'function') return this.s.db.executeDbAdminCommand(command, options, function (err, doc) {\n    return callback != null ? callback(err, doc) : null;\n  }); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    self.s.db.executeDbAdminCommand(command, options, function (err, doc) {\n      if (err) return reject(err);\n      resolve(doc);\n    });\n  });\n};\n\ndefine.classMethod('command', {\n  callback: true,\n  promise: true\n});\n/**\n * Retrieve the server information for the current\n * instance of the db client\n *\n * @param {Admin~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nAdmin.prototype.buildInfo = function (callback) {\n  var self = this; // Execute using callback\n\n  if (typeof callback == 'function') return this.serverInfo(callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    self.serverInfo(function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\ndefine.classMethod('buildInfo', {\n  callback: true,\n  promise: true\n});\n/**\n * Retrieve the server information for the current\n * instance of the db client\n *\n * @param {Admin~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nAdmin.prototype.serverInfo = function (callback) {\n  var self = this; // Execute using callback\n\n  if (typeof callback == 'function') return this.s.db.executeDbAdminCommand({\n    buildinfo: 1\n  }, function (err, doc) {\n    if (err != null) return callback(err, null);\n    callback(null, doc);\n  }); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    self.s.db.executeDbAdminCommand({\n      buildinfo: 1\n    }, function (err, doc) {\n      if (err) return reject(err);\n      resolve(doc);\n    });\n  });\n};\n\ndefine.classMethod('serverInfo', {\n  callback: true,\n  promise: true\n});\n/**\n * Retrieve this db's server status.\n *\n * @param {Admin~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nAdmin.prototype.serverStatus = function (callback) {\n  var self = this; // Execute using callback\n\n  if (typeof callback == 'function') return serverStatus(self, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    serverStatus(self, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar serverStatus = function (self, callback) {\n  self.s.db.executeDbAdminCommand({\n    serverStatus: 1\n  }, function (err, doc) {\n    if (err == null && doc.ok === 1) {\n      callback(null, doc);\n    } else {\n      if (err) return callback(err, false);\n      return callback(toError(doc), false);\n    }\n  });\n};\n\ndefine.classMethod('serverStatus', {\n  callback: true,\n  promise: true\n});\n/**\n * Retrieve the current profiling Level for MongoDB\n *\n * @param {Admin~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nAdmin.prototype.profilingLevel = function (callback) {\n  var self = this; // Execute using callback\n\n  if (typeof callback == 'function') return profilingLevel(self, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    profilingLevel(self, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar profilingLevel = function (self, callback) {\n  self.s.db.executeDbAdminCommand({\n    profile: -1\n  }, function (err, doc) {\n    if (err == null && doc.ok === 1) {\n      var was = doc.was;\n      if (was == 0) return callback(null, \"off\");\n      if (was == 1) return callback(null, \"slow_only\");\n      if (was == 2) return callback(null, \"all\");\n      return callback(new Error(\"Error: illegal profiling level value \" + was), null);\n    } else {\n      err != null ? callback(err, null) : callback(new Error(\"Error with profile command\"), null);\n    }\n  });\n};\n\ndefine.classMethod('profilingLevel', {\n  callback: true,\n  promise: true\n});\n/**\n * Ping the MongoDB server and retrieve results\n *\n * @param {Admin~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nAdmin.prototype.ping = function (options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  if (typeof callback != 'function') args.push(callback); // Execute using callback\n\n  if (typeof callback == 'function') return this.s.db.executeDbAdminCommand({\n    ping: 1\n  }, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    self.s.db.executeDbAdminCommand({\n      ping: 1\n    }, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\ndefine.classMethod('ping', {\n  callback: true,\n  promise: true\n});\n/**\n * Authenticate a user against the server.\n * @method\n * @param {string} username The username.\n * @param {string} [password] The password.\n * @param {Admin~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated This method will no longer be available in the next major release 3.x as MongoDB 3.6 will only allow auth against users in the admin db and will no longer allow multiple credentials on a socket. Please authenticate using MongoClient.connect with auth credentials.\n */\n\nAdmin.prototype.authenticate = function (username, password, options, callback) {\n  console.warn(\"Admin.prototype.authenticate method will no longer be available in the next major release 3.x as MongoDB 3.6 will only allow auth against users in the admin db and will no longer allow multiple credentials on a socket. Please authenticate using MongoClient.connect with auth credentials.\");\n  var finalArguments = [this.s.db];\n  if (typeof username == 'string') finalArguments.push(username);\n  if (typeof password == 'string') finalArguments.push(password);\n\n  if (typeof options == 'function') {\n    finalArguments.push({\n      authdb: 'admin'\n    });\n    finalArguments.push(options);\n  } else {\n    finalArguments.push(assign({}, options, {\n      authdb: 'admin'\n    }));\n  }\n\n  if (typeof callback == 'function') finalArguments.push(callback); // Execute authenticate method\n\n  return authenticate.apply(this.s.db, finalArguments);\n};\n\ndefine.classMethod('authenticate', {\n  callback: true,\n  promise: true\n});\n/**\n * Logout user from server, fire off on all connections and remove all auth info\n * @method\n * @param {Admin~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nAdmin.prototype.logout = function (callback) {\n  var self = this; // Execute using callback\n\n  if (typeof callback == 'function') return this.s.db.logout({\n    dbName: 'admin'\n  }, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    self.s.db.logout({\n      dbName: 'admin'\n    }, function (err) {\n      if (err) return reject(err);\n      resolve(true);\n    });\n  });\n};\n\ndefine.classMethod('logout', {\n  callback: true,\n  promise: true\n}); // Get write concern\n\nvar writeConcern = function (options, db) {\n  options = shallowClone(options); // If options already contain write concerns return it\n\n  if (options.w || options.wtimeout || options.j || options.fsync) {\n    return options;\n  } // Set db write concern if available\n\n\n  if (db.writeConcern) {\n    if (options.w) options.w = db.writeConcern.w;\n    if (options.wtimeout) options.wtimeout = db.writeConcern.wtimeout;\n    if (options.j) options.j = db.writeConcern.j;\n    if (options.fsync) options.fsync = db.writeConcern.fsync;\n  } // Return modified options\n\n\n  return options;\n};\n/**\n * Add a user to the database.\n * @method\n * @param {string} username The username.\n * @param {string} password The password.\n * @param {object} [options=null] Optional settings.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.fsync=false] Specify a file sync write concern.\n * @param {object} [options.customData=null] Custom data associated with the user (only Mongodb 2.6 or higher)\n * @param {object[]} [options.roles=null] Roles associated with the created user (only Mongodb 2.6 or higher)\n * @param {Admin~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nAdmin.prototype.addUser = function (username, password, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 2);\n  callback = args.pop();\n  if (typeof callback != 'function') args.push(callback);\n  options = args.length ? args.shift() : {};\n  options = options || {}; // Get the options\n\n  options = writeConcern(options, self.s.db); // Set the db name to admin\n\n  options.dbName = 'admin'; // Execute using callback\n\n  if (typeof callback == 'function') return self.s.db.addUser(username, password, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    self.s.db.addUser(username, password, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\ndefine.classMethod('addUser', {\n  callback: true,\n  promise: true\n});\n/**\n * Remove a user from a database\n * @method\n * @param {string} username The username.\n * @param {object} [options=null] Optional settings.\n * @param {(number|string)} [options.w=null] The write concern.\n * @param {number} [options.wtimeout=null] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.fsync=false] Specify a file sync write concern.\n * @param {Admin~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nAdmin.prototype.removeUser = function (username, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  if (typeof callback != 'function') args.push(callback);\n  options = args.length ? args.shift() : {};\n  options = options || {}; // Get the options\n\n  options = writeConcern(options, self.s.db); // Set the db name\n\n  options.dbName = 'admin'; // Execute using callback\n\n  if (typeof callback == 'function') return self.s.db.removeUser(username, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    self.s.db.removeUser(username, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\ndefine.classMethod('removeUser', {\n  callback: true,\n  promise: true\n});\n/**\n * Set the current profiling level of MongoDB\n *\n * @param {string} level The new profiling level (off, slow_only, all).\n * @param {Admin~resultCallback} [callback] The command result callback.\n * @return {Promise} returns Promise if no callback passed\n */\n\nAdmin.prototype.setProfilingLevel = function (level, callback) {\n  var self = this; // Execute using callback\n\n  if (typeof callback == 'function') return setProfilingLevel(self, level, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    setProfilingLevel(self, level, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar setProfilingLevel = function (self, level, callback) {\n  var command = {};\n  var profile = 0;\n\n  if (level == \"off\") {\n    profile = 0;\n  } else if (level == \"slow_only\") {\n    profile = 1;\n  } else if (level == \"all\") {\n    profile = 2;\n  } else {\n    return callback(new Error(\"Error: illegal profiling level value \" + level));\n  } // Set up the profile number\n\n\n  command['profile'] = profile;\n  self.s.db.executeDbAdminCommand(command, function (err, doc) {\n    if (err == null && doc.ok === 1) return callback(null, level);\n    return err != null ? callback(err, null) : callback(new Error(\"Error with profile command\"), null);\n  });\n};\n\ndefine.classMethod('setProfilingLevel', {\n  callback: true,\n  promise: true\n});\n/**\n * Retrieve the current profiling information for MongoDB\n *\n * @param {Admin~resultCallback} [callback] The command result callback.\n * @return {Promise} returns Promise if no callback passed\n * @deprecated Query the system.profile collection directly.\n */\n\nAdmin.prototype.profilingInfo = function (callback) {\n  var self = this; // Execute using callback\n\n  if (typeof callback == 'function') return profilingInfo(self, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    profilingInfo(self, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar profilingInfo = function (self, callback) {\n  try {\n    self.s.topology.cursor(\"admin.system.profile\", {\n      find: 'system.profile',\n      query: {}\n    }, {}).toArray(callback);\n  } catch (err) {\n    return callback(err, null);\n  }\n};\n\ndefine.classMethod('profilingLevel', {\n  callback: true,\n  promise: true\n});\n/**\n * Validate an existing collection\n *\n * @param {string} collectionName The name of the collection to validate.\n * @param {object} [options=null] Optional settings.\n * @param {Admin~resultCallback} [callback] The command result callback.\n * @return {Promise} returns Promise if no callback passed\n */\n\nAdmin.prototype.validateCollection = function (collectionName, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  if (typeof callback != 'function') args.push(callback);\n  options = args.length ? args.shift() : {};\n  options = options || {}; // Execute using callback\n\n  if (typeof callback == 'function') return validateCollection(self, collectionName, options, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    validateCollection(self, collectionName, options, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar validateCollection = function (self, collectionName, options, callback) {\n  var command = {\n    validate: collectionName\n  };\n  var keys = Object.keys(options); // Decorate command with extra options\n\n  for (var i = 0; i < keys.length; i++) {\n    if (options.hasOwnProperty(keys[i])) {\n      command[keys[i]] = options[keys[i]];\n    }\n  }\n\n  self.s.db.command(command, function (err, doc) {\n    if (err != null) return callback(err, null);\n    if (doc.ok === 0) return callback(new Error(\"Error with validate command\"), null);\n    if (doc.result != null && doc.result.constructor != String) return callback(new Error(\"Error with validation data\"), null);\n    if (doc.result != null && doc.result.match(/exception|corrupt/) != null) return callback(new Error(\"Error: invalid collection \" + collectionName), null);\n    if (doc.valid != null && !doc.valid) return callback(new Error(\"Error: invalid collection \" + collectionName), null);\n    return callback(null, doc);\n  });\n};\n\ndefine.classMethod('validateCollection', {\n  callback: true,\n  promise: true\n});\n/**\n * List the available databases\n *\n * @param {Admin~resultCallback} [callback] The command result callback.\n * @return {Promise} returns Promise if no callback passed\n */\n\nAdmin.prototype.listDatabases = function (callback) {\n  var self = this; // Execute using callback\n\n  if (typeof callback == 'function') return self.s.db.executeDbAdminCommand({\n    listDatabases: 1\n  }, {}, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    self.s.db.executeDbAdminCommand({\n      listDatabases: 1\n    }, {}, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\ndefine.classMethod('listDatabases', {\n  callback: true,\n  promise: true\n});\n/**\n * Get ReplicaSet status\n *\n * @param {Admin~resultCallback} [callback] The command result callback.\n * @return {Promise} returns Promise if no callback passed\n */\n\nAdmin.prototype.replSetGetStatus = function (callback) {\n  var self = this; // Execute using callback\n\n  if (typeof callback == 'function') return replSetGetStatus(self, callback); // Return a Promise\n\n  return new this.s.promiseLibrary(function (resolve, reject) {\n    replSetGetStatus(self, function (err, r) {\n      if (err) return reject(err);\n      resolve(r);\n    });\n  });\n};\n\nvar replSetGetStatus = function (self, callback) {\n  self.s.db.executeDbAdminCommand({\n    replSetGetStatus: 1\n  }, function (err, doc) {\n    if (err == null && doc.ok === 1) return callback(null, doc);\n    if (err) return callback(err, false);\n    callback(toError(doc), false);\n  });\n};\n\ndefine.classMethod('replSetGetStatus', {\n  callback: true,\n  promise: true\n});\nmodule.exports = Admin;","map":null,"metadata":{},"sourceType":"script"}